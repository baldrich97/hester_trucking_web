
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CustomerLoadTypes
 * 
 */
export type CustomerLoadTypes = $Result.DefaultSelection<Prisma.$CustomerLoadTypesPayload>
/**
 * Model Customers
 * 
 */
export type Customers = $Result.DefaultSelection<Prisma.$CustomersPayload>
/**
 * Model DeliveryLocations
 * 
 */
export type DeliveryLocations = $Result.DefaultSelection<Prisma.$DeliveryLocationsPayload>
/**
 * Model Drivers
 * 
 */
export type Drivers = $Result.DefaultSelection<Prisma.$DriversPayload>
/**
 * Model Invoices
 * 
 */
export type Invoices = $Result.DefaultSelection<Prisma.$InvoicesPayload>
/**
 * Model LoadTypes
 * 
 */
export type LoadTypes = $Result.DefaultSelection<Prisma.$LoadTypesPayload>
/**
 * Model States
 * 
 */
export type States = $Result.DefaultSelection<Prisma.$StatesPayload>
/**
 * Model Trucks
 * 
 */
export type Trucks = $Result.DefaultSelection<Prisma.$TrucksPayload>
/**
 * Model TrucksDriven
 * 
 */
export type TrucksDriven = $Result.DefaultSelection<Prisma.$TrucksDrivenPayload>
/**
 * Model Loads
 * 
 */
export type Loads = $Result.DefaultSelection<Prisma.$LoadsPayload>
/**
 * Model CustomerDeliveryLocations
 * 
 */
export type CustomerDeliveryLocations = $Result.DefaultSelection<Prisma.$CustomerDeliveryLocationsPayload>
/**
 * Model Dailies
 * 
 */
export type Dailies = $Result.DefaultSelection<Prisma.$DailiesPayload>
/**
 * Model Jobs
 * 
 */
export type Jobs = $Result.DefaultSelection<Prisma.$JobsPayload>
/**
 * Model Weeklies
 * 
 */
export type Weeklies = $Result.DefaultSelection<Prisma.$WeekliesPayload>
/**
 * Model PayStubs
 * 
 */
export type PayStubs = $Result.DefaultSelection<Prisma.$PayStubsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerLoadTypes`: Exposes CRUD operations for the **CustomerLoadTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerLoadTypes
    * const customerLoadTypes = await prisma.customerLoadTypes.findMany()
    * ```
    */
  get customerLoadTypes(): Prisma.CustomerLoadTypesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryLocations`: Exposes CRUD operations for the **DeliveryLocations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryLocations
    * const deliveryLocations = await prisma.deliveryLocations.findMany()
    * ```
    */
  get deliveryLocations(): Prisma.DeliveryLocationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drivers`: Exposes CRUD operations for the **Drivers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.drivers.findMany()
    * ```
    */
  get drivers(): Prisma.DriversDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **Invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoices.findMany()
    * ```
    */
  get invoices(): Prisma.InvoicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loadTypes`: Exposes CRUD operations for the **LoadTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoadTypes
    * const loadTypes = await prisma.loadTypes.findMany()
    * ```
    */
  get loadTypes(): Prisma.LoadTypesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.states`: Exposes CRUD operations for the **States** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.states.findMany()
    * ```
    */
  get states(): Prisma.StatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trucks`: Exposes CRUD operations for the **Trucks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trucks
    * const trucks = await prisma.trucks.findMany()
    * ```
    */
  get trucks(): Prisma.TrucksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trucksDriven`: Exposes CRUD operations for the **TrucksDriven** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrucksDrivens
    * const trucksDrivens = await prisma.trucksDriven.findMany()
    * ```
    */
  get trucksDriven(): Prisma.TrucksDrivenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loads`: Exposes CRUD operations for the **Loads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loads
    * const loads = await prisma.loads.findMany()
    * ```
    */
  get loads(): Prisma.LoadsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerDeliveryLocations`: Exposes CRUD operations for the **CustomerDeliveryLocations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerDeliveryLocations
    * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findMany()
    * ```
    */
  get customerDeliveryLocations(): Prisma.CustomerDeliveryLocationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailies`: Exposes CRUD operations for the **Dailies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dailies
    * const dailies = await prisma.dailies.findMany()
    * ```
    */
  get dailies(): Prisma.DailiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.JobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weeklies`: Exposes CRUD operations for the **Weeklies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weeklies
    * const weeklies = await prisma.weeklies.findMany()
    * ```
    */
  get weeklies(): Prisma.WeekliesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payStubs`: Exposes CRUD operations for the **PayStubs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayStubs
    * const payStubs = await prisma.payStubs.findMany()
    * ```
    */
  get payStubs(): Prisma.PayStubsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    CustomerLoadTypes: 'CustomerLoadTypes',
    Customers: 'Customers',
    DeliveryLocations: 'DeliveryLocations',
    Drivers: 'Drivers',
    Invoices: 'Invoices',
    LoadTypes: 'LoadTypes',
    States: 'States',
    Trucks: 'Trucks',
    TrucksDriven: 'TrucksDriven',
    Loads: 'Loads',
    CustomerDeliveryLocations: 'CustomerDeliveryLocations',
    Dailies: 'Dailies',
    Jobs: 'Jobs',
    Weeklies: 'Weeklies',
    PayStubs: 'PayStubs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customerLoadTypes" | "customers" | "deliveryLocations" | "drivers" | "invoices" | "loadTypes" | "states" | "trucks" | "trucksDriven" | "loads" | "customerDeliveryLocations" | "dailies" | "jobs" | "weeklies" | "payStubs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CustomerLoadTypes: {
        payload: Prisma.$CustomerLoadTypesPayload<ExtArgs>
        fields: Prisma.CustomerLoadTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerLoadTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerLoadTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload>
          }
          findFirst: {
            args: Prisma.CustomerLoadTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerLoadTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload>
          }
          findMany: {
            args: Prisma.CustomerLoadTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload>[]
          }
          create: {
            args: Prisma.CustomerLoadTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload>
          }
          createMany: {
            args: Prisma.CustomerLoadTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerLoadTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload>
          }
          update: {
            args: Prisma.CustomerLoadTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload>
          }
          deleteMany: {
            args: Prisma.CustomerLoadTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerLoadTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerLoadTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLoadTypesPayload>
          }
          aggregate: {
            args: Prisma.CustomerLoadTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerLoadTypes>
          }
          groupBy: {
            args: Prisma.CustomerLoadTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerLoadTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerLoadTypesCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerLoadTypesCountAggregateOutputType> | number
          }
        }
      }
      Customers: {
        payload: Prisma.$CustomersPayload<ExtArgs>
        fields: Prisma.CustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findFirst: {
            args: Prisma.CustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findMany: {
            args: Prisma.CustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          create: {
            args: Prisma.CustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          createMany: {
            args: Prisma.CustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          update: {
            args: Prisma.CustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          deleteMany: {
            args: Prisma.CustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.CustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      DeliveryLocations: {
        payload: Prisma.$DeliveryLocationsPayload<ExtArgs>
        fields: Prisma.DeliveryLocationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryLocationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryLocationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload>
          }
          findFirst: {
            args: Prisma.DeliveryLocationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryLocationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload>
          }
          findMany: {
            args: Prisma.DeliveryLocationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload>[]
          }
          create: {
            args: Prisma.DeliveryLocationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload>
          }
          createMany: {
            args: Prisma.DeliveryLocationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeliveryLocationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload>
          }
          update: {
            args: Prisma.DeliveryLocationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryLocationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryLocationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryLocationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLocationsPayload>
          }
          aggregate: {
            args: Prisma.DeliveryLocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryLocations>
          }
          groupBy: {
            args: Prisma.DeliveryLocationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryLocationsCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLocationsCountAggregateOutputType> | number
          }
        }
      }
      Drivers: {
        payload: Prisma.$DriversPayload<ExtArgs>
        fields: Prisma.DriversFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriversFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriversFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload>
          }
          findFirst: {
            args: Prisma.DriversFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriversFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload>
          }
          findMany: {
            args: Prisma.DriversFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload>[]
          }
          create: {
            args: Prisma.DriversCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload>
          }
          createMany: {
            args: Prisma.DriversCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DriversDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload>
          }
          update: {
            args: Prisma.DriversUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload>
          }
          deleteMany: {
            args: Prisma.DriversDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriversUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriversUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriversPayload>
          }
          aggregate: {
            args: Prisma.DriversAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrivers>
          }
          groupBy: {
            args: Prisma.DriversGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriversGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriversCountArgs<ExtArgs>
            result: $Utils.Optional<DriversCountAggregateOutputType> | number
          }
        }
      }
      Invoices: {
        payload: Prisma.$InvoicesPayload<ExtArgs>
        fields: Prisma.InvoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          findFirst: {
            args: Prisma.InvoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          findMany: {
            args: Prisma.InvoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>[]
          }
          create: {
            args: Prisma.InvoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          createMany: {
            args: Prisma.InvoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          update: {
            args: Prisma.InvoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          deleteMany: {
            args: Prisma.InvoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          aggregate: {
            args: Prisma.InvoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoices>
          }
          groupBy: {
            args: Prisma.InvoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoicesCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicesCountAggregateOutputType> | number
          }
        }
      }
      LoadTypes: {
        payload: Prisma.$LoadTypesPayload<ExtArgs>
        fields: Prisma.LoadTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoadTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoadTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload>
          }
          findFirst: {
            args: Prisma.LoadTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoadTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload>
          }
          findMany: {
            args: Prisma.LoadTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload>[]
          }
          create: {
            args: Prisma.LoadTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload>
          }
          createMany: {
            args: Prisma.LoadTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LoadTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload>
          }
          update: {
            args: Prisma.LoadTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload>
          }
          deleteMany: {
            args: Prisma.LoadTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoadTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoadTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadTypesPayload>
          }
          aggregate: {
            args: Prisma.LoadTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoadTypes>
          }
          groupBy: {
            args: Prisma.LoadTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoadTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoadTypesCountArgs<ExtArgs>
            result: $Utils.Optional<LoadTypesCountAggregateOutputType> | number
          }
        }
      }
      States: {
        payload: Prisma.$StatesPayload<ExtArgs>
        fields: Prisma.StatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload>
          }
          findFirst: {
            args: Prisma.StatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload>
          }
          findMany: {
            args: Prisma.StatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload>[]
          }
          create: {
            args: Prisma.StatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload>
          }
          createMany: {
            args: Prisma.StatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload>
          }
          update: {
            args: Prisma.StatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload>
          }
          deleteMany: {
            args: Prisma.StatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatesPayload>
          }
          aggregate: {
            args: Prisma.StatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStates>
          }
          groupBy: {
            args: Prisma.StatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatesCountArgs<ExtArgs>
            result: $Utils.Optional<StatesCountAggregateOutputType> | number
          }
        }
      }
      Trucks: {
        payload: Prisma.$TrucksPayload<ExtArgs>
        fields: Prisma.TrucksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrucksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrucksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload>
          }
          findFirst: {
            args: Prisma.TrucksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrucksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload>
          }
          findMany: {
            args: Prisma.TrucksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload>[]
          }
          create: {
            args: Prisma.TrucksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload>
          }
          createMany: {
            args: Prisma.TrucksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrucksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload>
          }
          update: {
            args: Prisma.TrucksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload>
          }
          deleteMany: {
            args: Prisma.TrucksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrucksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrucksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksPayload>
          }
          aggregate: {
            args: Prisma.TrucksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrucks>
          }
          groupBy: {
            args: Prisma.TrucksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrucksGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrucksCountArgs<ExtArgs>
            result: $Utils.Optional<TrucksCountAggregateOutputType> | number
          }
        }
      }
      TrucksDriven: {
        payload: Prisma.$TrucksDrivenPayload<ExtArgs>
        fields: Prisma.TrucksDrivenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrucksDrivenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrucksDrivenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload>
          }
          findFirst: {
            args: Prisma.TrucksDrivenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrucksDrivenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload>
          }
          findMany: {
            args: Prisma.TrucksDrivenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload>[]
          }
          create: {
            args: Prisma.TrucksDrivenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload>
          }
          createMany: {
            args: Prisma.TrucksDrivenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrucksDrivenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload>
          }
          update: {
            args: Prisma.TrucksDrivenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload>
          }
          deleteMany: {
            args: Prisma.TrucksDrivenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrucksDrivenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrucksDrivenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrucksDrivenPayload>
          }
          aggregate: {
            args: Prisma.TrucksDrivenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrucksDriven>
          }
          groupBy: {
            args: Prisma.TrucksDrivenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrucksDrivenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrucksDrivenCountArgs<ExtArgs>
            result: $Utils.Optional<TrucksDrivenCountAggregateOutputType> | number
          }
        }
      }
      Loads: {
        payload: Prisma.$LoadsPayload<ExtArgs>
        fields: Prisma.LoadsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoadsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoadsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload>
          }
          findFirst: {
            args: Prisma.LoadsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoadsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload>
          }
          findMany: {
            args: Prisma.LoadsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload>[]
          }
          create: {
            args: Prisma.LoadsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload>
          }
          createMany: {
            args: Prisma.LoadsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LoadsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload>
          }
          update: {
            args: Prisma.LoadsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload>
          }
          deleteMany: {
            args: Prisma.LoadsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoadsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoadsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoadsPayload>
          }
          aggregate: {
            args: Prisma.LoadsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoads>
          }
          groupBy: {
            args: Prisma.LoadsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoadsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoadsCountArgs<ExtArgs>
            result: $Utils.Optional<LoadsCountAggregateOutputType> | number
          }
        }
      }
      CustomerDeliveryLocations: {
        payload: Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>
        fields: Prisma.CustomerDeliveryLocationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerDeliveryLocationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerDeliveryLocationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload>
          }
          findFirst: {
            args: Prisma.CustomerDeliveryLocationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerDeliveryLocationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload>
          }
          findMany: {
            args: Prisma.CustomerDeliveryLocationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload>[]
          }
          create: {
            args: Prisma.CustomerDeliveryLocationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload>
          }
          createMany: {
            args: Prisma.CustomerDeliveryLocationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeliveryLocationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload>
          }
          update: {
            args: Prisma.CustomerDeliveryLocationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeliveryLocationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerDeliveryLocationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerDeliveryLocationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDeliveryLocationsPayload>
          }
          aggregate: {
            args: Prisma.CustomerDeliveryLocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerDeliveryLocations>
          }
          groupBy: {
            args: Prisma.CustomerDeliveryLocationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerDeliveryLocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerDeliveryLocationsCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerDeliveryLocationsCountAggregateOutputType> | number
          }
        }
      }
      Dailies: {
        payload: Prisma.$DailiesPayload<ExtArgs>
        fields: Prisma.DailiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload>
          }
          findFirst: {
            args: Prisma.DailiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload>
          }
          findMany: {
            args: Prisma.DailiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload>[]
          }
          create: {
            args: Prisma.DailiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload>
          }
          createMany: {
            args: Prisma.DailiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DailiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload>
          }
          update: {
            args: Prisma.DailiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload>
          }
          deleteMany: {
            args: Prisma.DailiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailiesPayload>
          }
          aggregate: {
            args: Prisma.DailiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailies>
          }
          groupBy: {
            args: Prisma.DailiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailiesCountArgs<ExtArgs>
            result: $Utils.Optional<DailiesCountAggregateOutputType> | number
          }
        }
      }
      Jobs: {
        payload: Prisma.$JobsPayload<ExtArgs>
        fields: Prisma.JobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findFirst: {
            args: Prisma.JobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findMany: {
            args: Prisma.JobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          create: {
            args: Prisma.JobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          createMany: {
            args: Prisma.JobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          update: {
            args: Prisma.JobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          deleteMany: {
            args: Prisma.JobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.JobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      Weeklies: {
        payload: Prisma.$WeekliesPayload<ExtArgs>
        fields: Prisma.WeekliesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeekliesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeekliesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload>
          }
          findFirst: {
            args: Prisma.WeekliesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeekliesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload>
          }
          findMany: {
            args: Prisma.WeekliesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload>[]
          }
          create: {
            args: Prisma.WeekliesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload>
          }
          createMany: {
            args: Prisma.WeekliesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WeekliesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload>
          }
          update: {
            args: Prisma.WeekliesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload>
          }
          deleteMany: {
            args: Prisma.WeekliesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeekliesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeekliesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeekliesPayload>
          }
          aggregate: {
            args: Prisma.WeekliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklies>
          }
          groupBy: {
            args: Prisma.WeekliesGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeekliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeekliesCountArgs<ExtArgs>
            result: $Utils.Optional<WeekliesCountAggregateOutputType> | number
          }
        }
      }
      PayStubs: {
        payload: Prisma.$PayStubsPayload<ExtArgs>
        fields: Prisma.PayStubsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayStubsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayStubsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload>
          }
          findFirst: {
            args: Prisma.PayStubsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayStubsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload>
          }
          findMany: {
            args: Prisma.PayStubsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload>[]
          }
          create: {
            args: Prisma.PayStubsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload>
          }
          createMany: {
            args: Prisma.PayStubsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PayStubsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload>
          }
          update: {
            args: Prisma.PayStubsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload>
          }
          deleteMany: {
            args: Prisma.PayStubsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayStubsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayStubsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStubsPayload>
          }
          aggregate: {
            args: Prisma.PayStubsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayStubs>
          }
          groupBy: {
            args: Prisma.PayStubsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayStubsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayStubsCountArgs<ExtArgs>
            result: $Utils.Optional<PayStubsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customerLoadTypes?: CustomerLoadTypesOmit
    customers?: CustomersOmit
    deliveryLocations?: DeliveryLocationsOmit
    drivers?: DriversOmit
    invoices?: InvoicesOmit
    loadTypes?: LoadTypesOmit
    states?: StatesOmit
    trucks?: TrucksOmit
    trucksDriven?: TrucksDrivenOmit
    loads?: LoadsOmit
    customerDeliveryLocations?: CustomerDeliveryLocationsOmit
    dailies?: DailiesOmit
    jobs?: JobsOmit
    weeklies?: WeekliesOmit
    payStubs?: PayStubsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    CustomerDeliveryLocations: number
    CustomerLoadTypes: number
    DeliveryLocations: number
    Invoices: number
    Jobs: number
    Loads: number
    Weeklies: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerDeliveryLocations?: boolean | CustomersCountOutputTypeCountCustomerDeliveryLocationsArgs
    CustomerLoadTypes?: boolean | CustomersCountOutputTypeCountCustomerLoadTypesArgs
    DeliveryLocations?: boolean | CustomersCountOutputTypeCountDeliveryLocationsArgs
    Invoices?: boolean | CustomersCountOutputTypeCountInvoicesArgs
    Jobs?: boolean | CustomersCountOutputTypeCountJobsArgs
    Loads?: boolean | CustomersCountOutputTypeCountLoadsArgs
    Weeklies?: boolean | CustomersCountOutputTypeCountWeekliesArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountCustomerDeliveryLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDeliveryLocationsWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountCustomerLoadTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerLoadTypesWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountDeliveryLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLocationsWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicesWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountWeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekliesWhereInput
  }


  /**
   * Count Type DeliveryLocationsCountOutputType
   */

  export type DeliveryLocationsCountOutputType = {
    CustomerDeliveryLocations: number
    Jobs: number
    Loads: number
    Weeklies: number
  }

  export type DeliveryLocationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerDeliveryLocations?: boolean | DeliveryLocationsCountOutputTypeCountCustomerDeliveryLocationsArgs
    Jobs?: boolean | DeliveryLocationsCountOutputTypeCountJobsArgs
    Loads?: boolean | DeliveryLocationsCountOutputTypeCountLoadsArgs
    Weeklies?: boolean | DeliveryLocationsCountOutputTypeCountWeekliesArgs
  }

  // Custom InputTypes
  /**
   * DeliveryLocationsCountOutputType without action
   */
  export type DeliveryLocationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocationsCountOutputType
     */
    select?: DeliveryLocationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryLocationsCountOutputType without action
   */
  export type DeliveryLocationsCountOutputTypeCountCustomerDeliveryLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDeliveryLocationsWhereInput
  }

  /**
   * DeliveryLocationsCountOutputType without action
   */
  export type DeliveryLocationsCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * DeliveryLocationsCountOutputType without action
   */
  export type DeliveryLocationsCountOutputTypeCountLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
  }

  /**
   * DeliveryLocationsCountOutputType without action
   */
  export type DeliveryLocationsCountOutputTypeCountWeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekliesWhereInput
  }


  /**
   * Count Type DriversCountOutputType
   */

  export type DriversCountOutputType = {
    Dailies: number
    Jobs: number
    Loads: number
    PayStubs: number
    TrucksDriven: number
  }

  export type DriversCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Dailies?: boolean | DriversCountOutputTypeCountDailiesArgs
    Jobs?: boolean | DriversCountOutputTypeCountJobsArgs
    Loads?: boolean | DriversCountOutputTypeCountLoadsArgs
    PayStubs?: boolean | DriversCountOutputTypeCountPayStubsArgs
    TrucksDriven?: boolean | DriversCountOutputTypeCountTrucksDrivenArgs
  }

  // Custom InputTypes
  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriversCountOutputType
     */
    select?: DriversCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeCountDailiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailiesWhereInput
  }

  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeCountLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
  }

  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeCountPayStubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayStubsWhereInput
  }

  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeCountTrucksDrivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrucksDrivenWhereInput
  }


  /**
   * Count Type InvoicesCountOutputType
   */

  export type InvoicesCountOutputType = {
    Loads: number
    Weeklies: number
  }

  export type InvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loads?: boolean | InvoicesCountOutputTypeCountLoadsArgs
    Weeklies?: boolean | InvoicesCountOutputTypeCountWeekliesArgs
  }

  // Custom InputTypes
  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicesCountOutputType
     */
    select?: InvoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountWeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekliesWhereInput
  }


  /**
   * Count Type LoadTypesCountOutputType
   */

  export type LoadTypesCountOutputType = {
    CustomerLoadTypes: number
    Jobs: number
    Loads: number
    Weeklies: number
  }

  export type LoadTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerLoadTypes?: boolean | LoadTypesCountOutputTypeCountCustomerLoadTypesArgs
    Jobs?: boolean | LoadTypesCountOutputTypeCountJobsArgs
    Loads?: boolean | LoadTypesCountOutputTypeCountLoadsArgs
    Weeklies?: boolean | LoadTypesCountOutputTypeCountWeekliesArgs
  }

  // Custom InputTypes
  /**
   * LoadTypesCountOutputType without action
   */
  export type LoadTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypesCountOutputType
     */
    select?: LoadTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoadTypesCountOutputType without action
   */
  export type LoadTypesCountOutputTypeCountCustomerLoadTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerLoadTypesWhereInput
  }

  /**
   * LoadTypesCountOutputType without action
   */
  export type LoadTypesCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * LoadTypesCountOutputType without action
   */
  export type LoadTypesCountOutputTypeCountLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
  }

  /**
   * LoadTypesCountOutputType without action
   */
  export type LoadTypesCountOutputTypeCountWeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekliesWhereInput
  }


  /**
   * Count Type StatesCountOutputType
   */

  export type StatesCountOutputType = {
    Customers: number
    Drivers: number
  }

  export type StatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | StatesCountOutputTypeCountCustomersArgs
    Drivers?: boolean | StatesCountOutputTypeCountDriversArgs
  }

  // Custom InputTypes
  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatesCountOutputType
     */
    select?: StatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
  }

  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriversWhereInput
  }


  /**
   * Count Type TrucksCountOutputType
   */

  export type TrucksCountOutputType = {
    Loads: number
    TrucksDriven: number
  }

  export type TrucksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loads?: boolean | TrucksCountOutputTypeCountLoadsArgs
    TrucksDriven?: boolean | TrucksCountOutputTypeCountTrucksDrivenArgs
  }

  // Custom InputTypes
  /**
   * TrucksCountOutputType without action
   */
  export type TrucksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksCountOutputType
     */
    select?: TrucksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrucksCountOutputType without action
   */
  export type TrucksCountOutputTypeCountLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
  }

  /**
   * TrucksCountOutputType without action
   */
  export type TrucksCountOutputTypeCountTrucksDrivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrucksDrivenWhereInput
  }


  /**
   * Count Type DailiesCountOutputType
   */

  export type DailiesCountOutputType = {
    Jobs: number
  }

  export type DailiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jobs?: boolean | DailiesCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * DailiesCountOutputType without action
   */
  export type DailiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailiesCountOutputType
     */
    select?: DailiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailiesCountOutputType without action
   */
  export type DailiesCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }


  /**
   * Count Type JobsCountOutputType
   */

  export type JobsCountOutputType = {
    Loads: number
  }

  export type JobsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loads?: boolean | JobsCountOutputTypeCountLoadsArgs
  }

  // Custom InputTypes
  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobsCountOutputType
     */
    select?: JobsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
  }


  /**
   * Count Type WeekliesCountOutputType
   */

  export type WeekliesCountOutputType = {
    Jobs: number
  }

  export type WeekliesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jobs?: boolean | WeekliesCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * WeekliesCountOutputType without action
   */
  export type WeekliesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeekliesCountOutputType
     */
    select?: WeekliesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeekliesCountOutputType without action
   */
  export type WeekliesCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }


  /**
   * Count Type PayStubsCountOutputType
   */

  export type PayStubsCountOutputType = {
    Jobs: number
  }

  export type PayStubsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Jobs?: boolean | PayStubsCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * PayStubsCountOutputType without action
   */
  export type PayStubsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubsCountOutputType
     */
    select?: PayStubsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayStubsCountOutputType without action
   */
  export type PayStubsCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    organization: string | null
    password: string | null
    username: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    organization: string | null
    password: string | null
    username: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    organization: number
    password: number
    username: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    organization?: true
    password?: true
    username?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    organization?: true
    password?: true
    username?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    organization?: true
    password?: true
    username?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    organization: string
    password: string
    username: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    organization?: boolean
    password?: boolean
    username?: boolean
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    organization?: boolean
    password?: boolean
    username?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "organization" | "password" | "username", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      organization: string
      password: string
      username: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly organization: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model CustomerLoadTypes
   */

  export type AggregateCustomerLoadTypes = {
    _count: CustomerLoadTypesCountAggregateOutputType | null
    _avg: CustomerLoadTypesAvgAggregateOutputType | null
    _sum: CustomerLoadTypesSumAggregateOutputType | null
    _min: CustomerLoadTypesMinAggregateOutputType | null
    _max: CustomerLoadTypesMaxAggregateOutputType | null
  }

  export type CustomerLoadTypesAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
  }

  export type CustomerLoadTypesSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
  }

  export type CustomerLoadTypesMinAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
    DateDelivered: Date | null
  }

  export type CustomerLoadTypesMaxAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
    DateDelivered: Date | null
  }

  export type CustomerLoadTypesCountAggregateOutputType = {
    ID: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: number
    _all: number
  }


  export type CustomerLoadTypesAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
  }

  export type CustomerLoadTypesSumAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
  }

  export type CustomerLoadTypesMinAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
    DateDelivered?: true
  }

  export type CustomerLoadTypesMaxAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
    DateDelivered?: true
  }

  export type CustomerLoadTypesCountAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
    DateDelivered?: true
    _all?: true
  }

  export type CustomerLoadTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerLoadTypes to aggregate.
     */
    where?: CustomerLoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLoadTypes to fetch.
     */
    orderBy?: CustomerLoadTypesOrderByWithRelationInput | CustomerLoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerLoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLoadTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerLoadTypes
    **/
    _count?: true | CustomerLoadTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerLoadTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerLoadTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerLoadTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerLoadTypesMaxAggregateInputType
  }

  export type GetCustomerLoadTypesAggregateType<T extends CustomerLoadTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerLoadTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerLoadTypes[P]>
      : GetScalarType<T[P], AggregateCustomerLoadTypes[P]>
  }




  export type CustomerLoadTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerLoadTypesWhereInput
    orderBy?: CustomerLoadTypesOrderByWithAggregationInput | CustomerLoadTypesOrderByWithAggregationInput[]
    by: CustomerLoadTypesScalarFieldEnum[] | CustomerLoadTypesScalarFieldEnum
    having?: CustomerLoadTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerLoadTypesCountAggregateInputType | true
    _avg?: CustomerLoadTypesAvgAggregateInputType
    _sum?: CustomerLoadTypesSumAggregateInputType
    _min?: CustomerLoadTypesMinAggregateInputType
    _max?: CustomerLoadTypesMaxAggregateInputType
  }

  export type CustomerLoadTypesGroupByOutputType = {
    ID: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: Date
    _count: CustomerLoadTypesCountAggregateOutputType | null
    _avg: CustomerLoadTypesAvgAggregateOutputType | null
    _sum: CustomerLoadTypesSumAggregateOutputType | null
    _min: CustomerLoadTypesMinAggregateOutputType | null
    _max: CustomerLoadTypesMaxAggregateOutputType | null
  }

  type GetCustomerLoadTypesGroupByPayload<T extends CustomerLoadTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerLoadTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerLoadTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerLoadTypesGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerLoadTypesGroupByOutputType[P]>
        }
      >
    >


  export type CustomerLoadTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CustomerID?: boolean
    LoadTypeID?: boolean
    DateDelivered?: boolean
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    LoadTypes?: boolean | LoadTypesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerLoadTypes"]>



  export type CustomerLoadTypesSelectScalar = {
    ID?: boolean
    CustomerID?: boolean
    LoadTypeID?: boolean
    DateDelivered?: boolean
  }

  export type CustomerLoadTypesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "CustomerID" | "LoadTypeID" | "DateDelivered", ExtArgs["result"]["customerLoadTypes"]>
  export type CustomerLoadTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    LoadTypes?: boolean | LoadTypesDefaultArgs<ExtArgs>
  }

  export type $CustomerLoadTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerLoadTypes"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>
      LoadTypes: Prisma.$LoadTypesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      CustomerID: number
      LoadTypeID: number
      /**
       * @zod.custom(z.coerce.date())
       */
      DateDelivered: Date
    }, ExtArgs["result"]["customerLoadTypes"]>
    composites: {}
  }

  type CustomerLoadTypesGetPayload<S extends boolean | null | undefined | CustomerLoadTypesDefaultArgs> = $Result.GetResult<Prisma.$CustomerLoadTypesPayload, S>

  type CustomerLoadTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerLoadTypesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerLoadTypesCountAggregateInputType | true
    }

  export interface CustomerLoadTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerLoadTypes'], meta: { name: 'CustomerLoadTypes' } }
    /**
     * Find zero or one CustomerLoadTypes that matches the filter.
     * @param {CustomerLoadTypesFindUniqueArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerLoadTypesFindUniqueArgs>(args: SelectSubset<T, CustomerLoadTypesFindUniqueArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerLoadTypes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerLoadTypesFindUniqueOrThrowArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerLoadTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerLoadTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerLoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesFindFirstArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerLoadTypesFindFirstArgs>(args?: SelectSubset<T, CustomerLoadTypesFindFirstArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerLoadTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesFindFirstOrThrowArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerLoadTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerLoadTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerLoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findMany()
     * 
     * // Get first 10 CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const customerLoadTypesWithIDOnly = await prisma.customerLoadTypes.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends CustomerLoadTypesFindManyArgs>(args?: SelectSubset<T, CustomerLoadTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerLoadTypes.
     * @param {CustomerLoadTypesCreateArgs} args - Arguments to create a CustomerLoadTypes.
     * @example
     * // Create one CustomerLoadTypes
     * const CustomerLoadTypes = await prisma.customerLoadTypes.create({
     *   data: {
     *     // ... data to create a CustomerLoadTypes
     *   }
     * })
     * 
     */
    create<T extends CustomerLoadTypesCreateArgs>(args: SelectSubset<T, CustomerLoadTypesCreateArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerLoadTypes.
     * @param {CustomerLoadTypesCreateManyArgs} args - Arguments to create many CustomerLoadTypes.
     * @example
     * // Create many CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerLoadTypesCreateManyArgs>(args?: SelectSubset<T, CustomerLoadTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerLoadTypes.
     * @param {CustomerLoadTypesDeleteArgs} args - Arguments to delete one CustomerLoadTypes.
     * @example
     * // Delete one CustomerLoadTypes
     * const CustomerLoadTypes = await prisma.customerLoadTypes.delete({
     *   where: {
     *     // ... filter to delete one CustomerLoadTypes
     *   }
     * })
     * 
     */
    delete<T extends CustomerLoadTypesDeleteArgs>(args: SelectSubset<T, CustomerLoadTypesDeleteArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerLoadTypes.
     * @param {CustomerLoadTypesUpdateArgs} args - Arguments to update one CustomerLoadTypes.
     * @example
     * // Update one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerLoadTypesUpdateArgs>(args: SelectSubset<T, CustomerLoadTypesUpdateArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerLoadTypes.
     * @param {CustomerLoadTypesDeleteManyArgs} args - Arguments to filter CustomerLoadTypes to delete.
     * @example
     * // Delete a few CustomerLoadTypes
     * const { count } = await prisma.customerLoadTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerLoadTypesDeleteManyArgs>(args?: SelectSubset<T, CustomerLoadTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerLoadTypesUpdateManyArgs>(args: SelectSubset<T, CustomerLoadTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerLoadTypes.
     * @param {CustomerLoadTypesUpsertArgs} args - Arguments to update or create a CustomerLoadTypes.
     * @example
     * // Update or create a CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.upsert({
     *   create: {
     *     // ... data to create a CustomerLoadTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerLoadTypes we want to update
     *   }
     * })
     */
    upsert<T extends CustomerLoadTypesUpsertArgs>(args: SelectSubset<T, CustomerLoadTypesUpsertArgs<ExtArgs>>): Prisma__CustomerLoadTypesClient<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesCountArgs} args - Arguments to filter CustomerLoadTypes to count.
     * @example
     * // Count the number of CustomerLoadTypes
     * const count = await prisma.customerLoadTypes.count({
     *   where: {
     *     // ... the filter for the CustomerLoadTypes we want to count
     *   }
     * })
    **/
    count<T extends CustomerLoadTypesCountArgs>(
      args?: Subset<T, CustomerLoadTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerLoadTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerLoadTypesAggregateArgs>(args: Subset<T, CustomerLoadTypesAggregateArgs>): Prisma.PrismaPromise<GetCustomerLoadTypesAggregateType<T>>

    /**
     * Group by CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerLoadTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerLoadTypesGroupByArgs['orderBy'] }
        : { orderBy?: CustomerLoadTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerLoadTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerLoadTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerLoadTypes model
   */
  readonly fields: CustomerLoadTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerLoadTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerLoadTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LoadTypes<T extends LoadTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoadTypesDefaultArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerLoadTypes model
   */
  interface CustomerLoadTypesFieldRefs {
    readonly ID: FieldRef<"CustomerLoadTypes", 'Int'>
    readonly CustomerID: FieldRef<"CustomerLoadTypes", 'Int'>
    readonly LoadTypeID: FieldRef<"CustomerLoadTypes", 'Int'>
    readonly DateDelivered: FieldRef<"CustomerLoadTypes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerLoadTypes findUnique
   */
  export type CustomerLoadTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     */
    where: CustomerLoadTypesWhereUniqueInput
  }

  /**
   * CustomerLoadTypes findUniqueOrThrow
   */
  export type CustomerLoadTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     */
    where: CustomerLoadTypesWhereUniqueInput
  }

  /**
   * CustomerLoadTypes findFirst
   */
  export type CustomerLoadTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     */
    where?: CustomerLoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLoadTypes to fetch.
     */
    orderBy?: CustomerLoadTypesOrderByWithRelationInput | CustomerLoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerLoadTypes.
     */
    cursor?: CustomerLoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLoadTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerLoadTypes.
     */
    distinct?: CustomerLoadTypesScalarFieldEnum | CustomerLoadTypesScalarFieldEnum[]
  }

  /**
   * CustomerLoadTypes findFirstOrThrow
   */
  export type CustomerLoadTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     */
    where?: CustomerLoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLoadTypes to fetch.
     */
    orderBy?: CustomerLoadTypesOrderByWithRelationInput | CustomerLoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerLoadTypes.
     */
    cursor?: CustomerLoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLoadTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerLoadTypes.
     */
    distinct?: CustomerLoadTypesScalarFieldEnum | CustomerLoadTypesScalarFieldEnum[]
  }

  /**
   * CustomerLoadTypes findMany
   */
  export type CustomerLoadTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     */
    where?: CustomerLoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLoadTypes to fetch.
     */
    orderBy?: CustomerLoadTypesOrderByWithRelationInput | CustomerLoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerLoadTypes.
     */
    cursor?: CustomerLoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLoadTypes.
     */
    skip?: number
    distinct?: CustomerLoadTypesScalarFieldEnum | CustomerLoadTypesScalarFieldEnum[]
  }

  /**
   * CustomerLoadTypes create
   */
  export type CustomerLoadTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerLoadTypes.
     */
    data: XOR<CustomerLoadTypesCreateInput, CustomerLoadTypesUncheckedCreateInput>
  }

  /**
   * CustomerLoadTypes createMany
   */
  export type CustomerLoadTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerLoadTypes.
     */
    data: CustomerLoadTypesCreateManyInput | CustomerLoadTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerLoadTypes update
   */
  export type CustomerLoadTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerLoadTypes.
     */
    data: XOR<CustomerLoadTypesUpdateInput, CustomerLoadTypesUncheckedUpdateInput>
    /**
     * Choose, which CustomerLoadTypes to update.
     */
    where: CustomerLoadTypesWhereUniqueInput
  }

  /**
   * CustomerLoadTypes updateMany
   */
  export type CustomerLoadTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerLoadTypes.
     */
    data: XOR<CustomerLoadTypesUpdateManyMutationInput, CustomerLoadTypesUncheckedUpdateManyInput>
    /**
     * Filter which CustomerLoadTypes to update
     */
    where?: CustomerLoadTypesWhereInput
    /**
     * Limit how many CustomerLoadTypes to update.
     */
    limit?: number
  }

  /**
   * CustomerLoadTypes upsert
   */
  export type CustomerLoadTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerLoadTypes to update in case it exists.
     */
    where: CustomerLoadTypesWhereUniqueInput
    /**
     * In case the CustomerLoadTypes found by the `where` argument doesn't exist, create a new CustomerLoadTypes with this data.
     */
    create: XOR<CustomerLoadTypesCreateInput, CustomerLoadTypesUncheckedCreateInput>
    /**
     * In case the CustomerLoadTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerLoadTypesUpdateInput, CustomerLoadTypesUncheckedUpdateInput>
  }

  /**
   * CustomerLoadTypes delete
   */
  export type CustomerLoadTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    /**
     * Filter which CustomerLoadTypes to delete.
     */
    where: CustomerLoadTypesWhereUniqueInput
  }

  /**
   * CustomerLoadTypes deleteMany
   */
  export type CustomerLoadTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerLoadTypes to delete
     */
    where?: CustomerLoadTypesWhereInput
    /**
     * Limit how many CustomerLoadTypes to delete.
     */
    limit?: number
  }

  /**
   * CustomerLoadTypes without action
   */
  export type CustomerLoadTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
  }


  /**
   * Model Customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type CustomersSumAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type CustomersMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    Phone: string | null
    Email: string | null
    Notes: string | null
    MainContact: string | null
    Deleted: boolean | null
  }

  export type CustomersMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    Phone: string | null
    Email: string | null
    Notes: string | null
    MainContact: string | null
    Deleted: boolean | null
  }

  export type CustomersCountAggregateOutputType = {
    ID: number
    Name: number
    Street: number
    City: number
    State: number
    ZIP: number
    Phone: number
    Email: number
    Notes: number
    MainContact: number
    Deleted: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    ID?: true
    State?: true
  }

  export type CustomersSumAggregateInputType = {
    ID?: true
    State?: true
  }

  export type CustomersMinAggregateInputType = {
    ID?: true
    Name?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    Phone?: true
    Email?: true
    Notes?: true
    MainContact?: true
    Deleted?: true
  }

  export type CustomersMaxAggregateInputType = {
    ID?: true
    Name?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    Phone?: true
    Email?: true
    Notes?: true
    MainContact?: true
    Deleted?: true
  }

  export type CustomersCountAggregateInputType = {
    ID?: true
    Name?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    Phone?: true
    Email?: true
    Notes?: true
    MainContact?: true
    Deleted?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithAggregationInput | CustomersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    ID: number
    Name: string
    Street: string
    City: string
    State: number
    ZIP: string
    Phone: string | null
    Email: string | null
    Notes: string | null
    MainContact: string | null
    Deleted: boolean | null
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    Street?: boolean
    City?: boolean
    State?: boolean
    ZIP?: boolean
    Phone?: boolean
    Email?: boolean
    Notes?: boolean
    MainContact?: boolean
    Deleted?: boolean
    States?: boolean | StatesDefaultArgs<ExtArgs>
    CustomerDeliveryLocations?: boolean | Customers$CustomerDeliveryLocationsArgs<ExtArgs>
    CustomerLoadTypes?: boolean | Customers$CustomerLoadTypesArgs<ExtArgs>
    DeliveryLocations?: boolean | Customers$DeliveryLocationsArgs<ExtArgs>
    Invoices?: boolean | Customers$InvoicesArgs<ExtArgs>
    Jobs?: boolean | Customers$JobsArgs<ExtArgs>
    Loads?: boolean | Customers$LoadsArgs<ExtArgs>
    Weeklies?: boolean | Customers$WeekliesArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>



  export type CustomersSelectScalar = {
    ID?: boolean
    Name?: boolean
    Street?: boolean
    City?: boolean
    State?: boolean
    ZIP?: boolean
    Phone?: boolean
    Email?: boolean
    Notes?: boolean
    MainContact?: boolean
    Deleted?: boolean
  }

  export type CustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Name" | "Street" | "City" | "State" | "ZIP" | "Phone" | "Email" | "Notes" | "MainContact" | "Deleted", ExtArgs["result"]["customers"]>
  export type CustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    States?: boolean | StatesDefaultArgs<ExtArgs>
    CustomerDeliveryLocations?: boolean | Customers$CustomerDeliveryLocationsArgs<ExtArgs>
    CustomerLoadTypes?: boolean | Customers$CustomerLoadTypesArgs<ExtArgs>
    DeliveryLocations?: boolean | Customers$DeliveryLocationsArgs<ExtArgs>
    Invoices?: boolean | Customers$InvoicesArgs<ExtArgs>
    Jobs?: boolean | Customers$JobsArgs<ExtArgs>
    Loads?: boolean | Customers$LoadsArgs<ExtArgs>
    Weeklies?: boolean | Customers$WeekliesArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customers"
    objects: {
      States: Prisma.$StatesPayload<ExtArgs>
      CustomerDeliveryLocations: Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>[]
      CustomerLoadTypes: Prisma.$CustomerLoadTypesPayload<ExtArgs>[]
      DeliveryLocations: Prisma.$DeliveryLocationsPayload<ExtArgs>[]
      Invoices: Prisma.$InvoicesPayload<ExtArgs>[]
      Jobs: Prisma.$JobsPayload<ExtArgs>[]
      Loads: Prisma.$LoadsPayload<ExtArgs>[]
      Weeklies: Prisma.$WeekliesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      /**
       * @zod.min(1)
       */
      Name: string
      /**
       * @zod.min(1)
       */
      Street: string
      /**
       * @zod.min(1)
       */
      City: string
      /**
       * @zod.min(1)
       */
      State: number
      /**
       * @zod.min(1)
       */
      ZIP: string
      Phone: string | null
      Email: string | null
      Notes: string | null
      MainContact: string | null
      Deleted: boolean | null
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type CustomersGetPayload<S extends boolean | null | undefined | CustomersDefaultArgs> = $Result.GetResult<Prisma.$CustomersPayload, S>

  type CustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customers'], meta: { name: 'Customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomersFindUniqueArgs>(args: SelectSubset<T, CustomersFindUniqueArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomersFindFirstArgs>(args?: SelectSubset<T, CustomersFindFirstArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const customersWithIDOnly = await prisma.customers.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends CustomersFindManyArgs>(args?: SelectSubset<T, CustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends CustomersCreateArgs>(args: SelectSubset<T, CustomersCreateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomersCreateManyArgs>(args?: SelectSubset<T, CustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends CustomersDeleteArgs>(args: SelectSubset<T, CustomersDeleteArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomersUpdateArgs>(args: SelectSubset<T, CustomersUpdateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomersDeleteManyArgs>(args?: SelectSubset<T, CustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomersUpdateManyArgs>(args: SelectSubset<T, CustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends CustomersUpsertArgs>(args: SelectSubset<T, CustomersUpsertArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customers model
   */
  readonly fields: CustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    States<T extends StatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StatesDefaultArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CustomerDeliveryLocations<T extends Customers$CustomerDeliveryLocationsArgs<ExtArgs> = {}>(args?: Subset<T, Customers$CustomerDeliveryLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CustomerLoadTypes<T extends Customers$CustomerLoadTypesArgs<ExtArgs> = {}>(args?: Subset<T, Customers$CustomerLoadTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeliveryLocations<T extends Customers$DeliveryLocationsArgs<ExtArgs> = {}>(args?: Subset<T, Customers$DeliveryLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Invoices<T extends Customers$InvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customers$InvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Jobs<T extends Customers$JobsArgs<ExtArgs> = {}>(args?: Subset<T, Customers$JobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Loads<T extends Customers$LoadsArgs<ExtArgs> = {}>(args?: Subset<T, Customers$LoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Weeklies<T extends Customers$WeekliesArgs<ExtArgs> = {}>(args?: Subset<T, Customers$WeekliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customers model
   */
  interface CustomersFieldRefs {
    readonly ID: FieldRef<"Customers", 'Int'>
    readonly Name: FieldRef<"Customers", 'String'>
    readonly Street: FieldRef<"Customers", 'String'>
    readonly City: FieldRef<"Customers", 'String'>
    readonly State: FieldRef<"Customers", 'Int'>
    readonly ZIP: FieldRef<"Customers", 'String'>
    readonly Phone: FieldRef<"Customers", 'String'>
    readonly Email: FieldRef<"Customers", 'String'>
    readonly Notes: FieldRef<"Customers", 'String'>
    readonly MainContact: FieldRef<"Customers", 'String'>
    readonly Deleted: FieldRef<"Customers", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers create
   */
  export type CustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }

  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customers update
   */
  export type CustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }

  /**
   * Customers delete
   */
  export type CustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customers.CustomerDeliveryLocations
   */
  export type Customers$CustomerDeliveryLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    where?: CustomerDeliveryLocationsWhereInput
    orderBy?: CustomerDeliveryLocationsOrderByWithRelationInput | CustomerDeliveryLocationsOrderByWithRelationInput[]
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDeliveryLocationsScalarFieldEnum | CustomerDeliveryLocationsScalarFieldEnum[]
  }

  /**
   * Customers.CustomerLoadTypes
   */
  export type Customers$CustomerLoadTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    where?: CustomerLoadTypesWhereInput
    orderBy?: CustomerLoadTypesOrderByWithRelationInput | CustomerLoadTypesOrderByWithRelationInput[]
    cursor?: CustomerLoadTypesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerLoadTypesScalarFieldEnum | CustomerLoadTypesScalarFieldEnum[]
  }

  /**
   * Customers.DeliveryLocations
   */
  export type Customers$DeliveryLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    where?: DeliveryLocationsWhereInput
    orderBy?: DeliveryLocationsOrderByWithRelationInput | DeliveryLocationsOrderByWithRelationInput[]
    cursor?: DeliveryLocationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryLocationsScalarFieldEnum | DeliveryLocationsScalarFieldEnum[]
  }

  /**
   * Customers.Invoices
   */
  export type Customers$InvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    where?: InvoicesWhereInput
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    cursor?: InvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Customers.Jobs
   */
  export type Customers$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Customers.Loads
   */
  export type Customers$LoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    cursor?: LoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Customers.Weeklies
   */
  export type Customers$WeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    where?: WeekliesWhereInput
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    cursor?: WeekliesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekliesScalarFieldEnum | WeekliesScalarFieldEnum[]
  }

  /**
   * Customers without action
   */
  export type CustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryLocations
   */

  export type AggregateDeliveryLocations = {
    _count: DeliveryLocationsCountAggregateOutputType | null
    _avg: DeliveryLocationsAvgAggregateOutputType | null
    _sum: DeliveryLocationsSumAggregateOutputType | null
    _min: DeliveryLocationsMinAggregateOutputType | null
    _max: DeliveryLocationsMaxAggregateOutputType | null
  }

  export type DeliveryLocationsAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
  }

  export type DeliveryLocationsSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
  }

  export type DeliveryLocationsMinAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    CustomerID: number | null
  }

  export type DeliveryLocationsMaxAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    CustomerID: number | null
  }

  export type DeliveryLocationsCountAggregateOutputType = {
    ID: number
    Description: number
    Deleted: number
    CustomerID: number
    _all: number
  }


  export type DeliveryLocationsAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
  }

  export type DeliveryLocationsSumAggregateInputType = {
    ID?: true
    CustomerID?: true
  }

  export type DeliveryLocationsMinAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    CustomerID?: true
  }

  export type DeliveryLocationsMaxAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    CustomerID?: true
  }

  export type DeliveryLocationsCountAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    CustomerID?: true
    _all?: true
  }

  export type DeliveryLocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLocations to aggregate.
     */
    where?: DeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLocations to fetch.
     */
    orderBy?: DeliveryLocationsOrderByWithRelationInput | DeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryLocations
    **/
    _count?: true | DeliveryLocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryLocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryLocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryLocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryLocationsMaxAggregateInputType
  }

  export type GetDeliveryLocationsAggregateType<T extends DeliveryLocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryLocations[P]>
      : GetScalarType<T[P], AggregateDeliveryLocations[P]>
  }




  export type DeliveryLocationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLocationsWhereInput
    orderBy?: DeliveryLocationsOrderByWithAggregationInput | DeliveryLocationsOrderByWithAggregationInput[]
    by: DeliveryLocationsScalarFieldEnum[] | DeliveryLocationsScalarFieldEnum
    having?: DeliveryLocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryLocationsCountAggregateInputType | true
    _avg?: DeliveryLocationsAvgAggregateInputType
    _sum?: DeliveryLocationsSumAggregateInputType
    _min?: DeliveryLocationsMinAggregateInputType
    _max?: DeliveryLocationsMaxAggregateInputType
  }

  export type DeliveryLocationsGroupByOutputType = {
    ID: number
    Description: string
    Deleted: boolean | null
    CustomerID: number | null
    _count: DeliveryLocationsCountAggregateOutputType | null
    _avg: DeliveryLocationsAvgAggregateOutputType | null
    _sum: DeliveryLocationsSumAggregateOutputType | null
    _min: DeliveryLocationsMinAggregateOutputType | null
    _max: DeliveryLocationsMaxAggregateOutputType | null
  }

  type GetDeliveryLocationsGroupByPayload<T extends DeliveryLocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryLocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryLocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryLocationsGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryLocationsGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryLocationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Description?: boolean
    Deleted?: boolean
    CustomerID?: boolean
    Customers?: boolean | DeliveryLocations$CustomersArgs<ExtArgs>
    CustomerDeliveryLocations?: boolean | DeliveryLocations$CustomerDeliveryLocationsArgs<ExtArgs>
    Jobs?: boolean | DeliveryLocations$JobsArgs<ExtArgs>
    Loads?: boolean | DeliveryLocations$LoadsArgs<ExtArgs>
    Weeklies?: boolean | DeliveryLocations$WeekliesArgs<ExtArgs>
    _count?: boolean | DeliveryLocationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLocations"]>



  export type DeliveryLocationsSelectScalar = {
    ID?: boolean
    Description?: boolean
    Deleted?: boolean
    CustomerID?: boolean
  }

  export type DeliveryLocationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Description" | "Deleted" | "CustomerID", ExtArgs["result"]["deliveryLocations"]>
  export type DeliveryLocationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | DeliveryLocations$CustomersArgs<ExtArgs>
    CustomerDeliveryLocations?: boolean | DeliveryLocations$CustomerDeliveryLocationsArgs<ExtArgs>
    Jobs?: boolean | DeliveryLocations$JobsArgs<ExtArgs>
    Loads?: boolean | DeliveryLocations$LoadsArgs<ExtArgs>
    Weeklies?: boolean | DeliveryLocations$WeekliesArgs<ExtArgs>
    _count?: boolean | DeliveryLocationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DeliveryLocationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryLocations"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs> | null
      CustomerDeliveryLocations: Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>[]
      Jobs: Prisma.$JobsPayload<ExtArgs>[]
      Loads: Prisma.$LoadsPayload<ExtArgs>[]
      Weeklies: Prisma.$WeekliesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Description: string
      Deleted: boolean | null
      CustomerID: number | null
    }, ExtArgs["result"]["deliveryLocations"]>
    composites: {}
  }

  type DeliveryLocationsGetPayload<S extends boolean | null | undefined | DeliveryLocationsDefaultArgs> = $Result.GetResult<Prisma.$DeliveryLocationsPayload, S>

  type DeliveryLocationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryLocationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryLocationsCountAggregateInputType | true
    }

  export interface DeliveryLocationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryLocations'], meta: { name: 'DeliveryLocations' } }
    /**
     * Find zero or one DeliveryLocations that matches the filter.
     * @param {DeliveryLocationsFindUniqueArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryLocationsFindUniqueArgs>(args: SelectSubset<T, DeliveryLocationsFindUniqueArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryLocations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryLocationsFindUniqueOrThrowArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryLocationsFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryLocationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsFindFirstArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryLocationsFindFirstArgs>(args?: SelectSubset<T, DeliveryLocationsFindFirstArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLocations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsFindFirstOrThrowArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryLocationsFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryLocationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findMany()
     * 
     * // Get first 10 DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const deliveryLocationsWithIDOnly = await prisma.deliveryLocations.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends DeliveryLocationsFindManyArgs>(args?: SelectSubset<T, DeliveryLocationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryLocations.
     * @param {DeliveryLocationsCreateArgs} args - Arguments to create a DeliveryLocations.
     * @example
     * // Create one DeliveryLocations
     * const DeliveryLocations = await prisma.deliveryLocations.create({
     *   data: {
     *     // ... data to create a DeliveryLocations
     *   }
     * })
     * 
     */
    create<T extends DeliveryLocationsCreateArgs>(args: SelectSubset<T, DeliveryLocationsCreateArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryLocations.
     * @param {DeliveryLocationsCreateManyArgs} args - Arguments to create many DeliveryLocations.
     * @example
     * // Create many DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryLocationsCreateManyArgs>(args?: SelectSubset<T, DeliveryLocationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeliveryLocations.
     * @param {DeliveryLocationsDeleteArgs} args - Arguments to delete one DeliveryLocations.
     * @example
     * // Delete one DeliveryLocations
     * const DeliveryLocations = await prisma.deliveryLocations.delete({
     *   where: {
     *     // ... filter to delete one DeliveryLocations
     *   }
     * })
     * 
     */
    delete<T extends DeliveryLocationsDeleteArgs>(args: SelectSubset<T, DeliveryLocationsDeleteArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryLocations.
     * @param {DeliveryLocationsUpdateArgs} args - Arguments to update one DeliveryLocations.
     * @example
     * // Update one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryLocationsUpdateArgs>(args: SelectSubset<T, DeliveryLocationsUpdateArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryLocations.
     * @param {DeliveryLocationsDeleteManyArgs} args - Arguments to filter DeliveryLocations to delete.
     * @example
     * // Delete a few DeliveryLocations
     * const { count } = await prisma.deliveryLocations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryLocationsDeleteManyArgs>(args?: SelectSubset<T, DeliveryLocationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryLocationsUpdateManyArgs>(args: SelectSubset<T, DeliveryLocationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryLocations.
     * @param {DeliveryLocationsUpsertArgs} args - Arguments to update or create a DeliveryLocations.
     * @example
     * // Update or create a DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.upsert({
     *   create: {
     *     // ... data to create a DeliveryLocations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryLocations we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryLocationsUpsertArgs>(args: SelectSubset<T, DeliveryLocationsUpsertArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsCountArgs} args - Arguments to filter DeliveryLocations to count.
     * @example
     * // Count the number of DeliveryLocations
     * const count = await prisma.deliveryLocations.count({
     *   where: {
     *     // ... the filter for the DeliveryLocations we want to count
     *   }
     * })
    **/
    count<T extends DeliveryLocationsCountArgs>(
      args?: Subset<T, DeliveryLocationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryLocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryLocationsAggregateArgs>(args: Subset<T, DeliveryLocationsAggregateArgs>): Prisma.PrismaPromise<GetDeliveryLocationsAggregateType<T>>

    /**
     * Group by DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryLocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryLocationsGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryLocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryLocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryLocations model
   */
  readonly fields: DeliveryLocationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryLocations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryLocationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends DeliveryLocations$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocations$CustomersArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CustomerDeliveryLocations<T extends DeliveryLocations$CustomerDeliveryLocationsArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocations$CustomerDeliveryLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Jobs<T extends DeliveryLocations$JobsArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocations$JobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Loads<T extends DeliveryLocations$LoadsArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocations$LoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Weeklies<T extends DeliveryLocations$WeekliesArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocations$WeekliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryLocations model
   */
  interface DeliveryLocationsFieldRefs {
    readonly ID: FieldRef<"DeliveryLocations", 'Int'>
    readonly Description: FieldRef<"DeliveryLocations", 'String'>
    readonly Deleted: FieldRef<"DeliveryLocations", 'Boolean'>
    readonly CustomerID: FieldRef<"DeliveryLocations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryLocations findUnique
   */
  export type DeliveryLocationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLocations to fetch.
     */
    where: DeliveryLocationsWhereUniqueInput
  }

  /**
   * DeliveryLocations findUniqueOrThrow
   */
  export type DeliveryLocationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLocations to fetch.
     */
    where: DeliveryLocationsWhereUniqueInput
  }

  /**
   * DeliveryLocations findFirst
   */
  export type DeliveryLocationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLocations to fetch.
     */
    where?: DeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLocations to fetch.
     */
    orderBy?: DeliveryLocationsOrderByWithRelationInput | DeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLocations.
     */
    cursor?: DeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLocations.
     */
    distinct?: DeliveryLocationsScalarFieldEnum | DeliveryLocationsScalarFieldEnum[]
  }

  /**
   * DeliveryLocations findFirstOrThrow
   */
  export type DeliveryLocationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLocations to fetch.
     */
    where?: DeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLocations to fetch.
     */
    orderBy?: DeliveryLocationsOrderByWithRelationInput | DeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLocations.
     */
    cursor?: DeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLocations.
     */
    distinct?: DeliveryLocationsScalarFieldEnum | DeliveryLocationsScalarFieldEnum[]
  }

  /**
   * DeliveryLocations findMany
   */
  export type DeliveryLocationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLocations to fetch.
     */
    where?: DeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLocations to fetch.
     */
    orderBy?: DeliveryLocationsOrderByWithRelationInput | DeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryLocations.
     */
    cursor?: DeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLocations.
     */
    skip?: number
    distinct?: DeliveryLocationsScalarFieldEnum | DeliveryLocationsScalarFieldEnum[]
  }

  /**
   * DeliveryLocations create
   */
  export type DeliveryLocationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryLocations.
     */
    data: XOR<DeliveryLocationsCreateInput, DeliveryLocationsUncheckedCreateInput>
  }

  /**
   * DeliveryLocations createMany
   */
  export type DeliveryLocationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryLocations.
     */
    data: DeliveryLocationsCreateManyInput | DeliveryLocationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryLocations update
   */
  export type DeliveryLocationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryLocations.
     */
    data: XOR<DeliveryLocationsUpdateInput, DeliveryLocationsUncheckedUpdateInput>
    /**
     * Choose, which DeliveryLocations to update.
     */
    where: DeliveryLocationsWhereUniqueInput
  }

  /**
   * DeliveryLocations updateMany
   */
  export type DeliveryLocationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryLocations.
     */
    data: XOR<DeliveryLocationsUpdateManyMutationInput, DeliveryLocationsUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLocations to update
     */
    where?: DeliveryLocationsWhereInput
    /**
     * Limit how many DeliveryLocations to update.
     */
    limit?: number
  }

  /**
   * DeliveryLocations upsert
   */
  export type DeliveryLocationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryLocations to update in case it exists.
     */
    where: DeliveryLocationsWhereUniqueInput
    /**
     * In case the DeliveryLocations found by the `where` argument doesn't exist, create a new DeliveryLocations with this data.
     */
    create: XOR<DeliveryLocationsCreateInput, DeliveryLocationsUncheckedCreateInput>
    /**
     * In case the DeliveryLocations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryLocationsUpdateInput, DeliveryLocationsUncheckedUpdateInput>
  }

  /**
   * DeliveryLocations delete
   */
  export type DeliveryLocationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter which DeliveryLocations to delete.
     */
    where: DeliveryLocationsWhereUniqueInput
  }

  /**
   * DeliveryLocations deleteMany
   */
  export type DeliveryLocationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLocations to delete
     */
    where?: DeliveryLocationsWhereInput
    /**
     * Limit how many DeliveryLocations to delete.
     */
    limit?: number
  }

  /**
   * DeliveryLocations.Customers
   */
  export type DeliveryLocations$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
  }

  /**
   * DeliveryLocations.CustomerDeliveryLocations
   */
  export type DeliveryLocations$CustomerDeliveryLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    where?: CustomerDeliveryLocationsWhereInput
    orderBy?: CustomerDeliveryLocationsOrderByWithRelationInput | CustomerDeliveryLocationsOrderByWithRelationInput[]
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDeliveryLocationsScalarFieldEnum | CustomerDeliveryLocationsScalarFieldEnum[]
  }

  /**
   * DeliveryLocations.Jobs
   */
  export type DeliveryLocations$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * DeliveryLocations.Loads
   */
  export type DeliveryLocations$LoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    cursor?: LoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * DeliveryLocations.Weeklies
   */
  export type DeliveryLocations$WeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    where?: WeekliesWhereInput
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    cursor?: WeekliesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekliesScalarFieldEnum | WeekliesScalarFieldEnum[]
  }

  /**
   * DeliveryLocations without action
   */
  export type DeliveryLocationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
  }


  /**
   * Model Drivers
   */

  export type AggregateDrivers = {
    _count: DriversCountAggregateOutputType | null
    _avg: DriversAvgAggregateOutputType | null
    _sum: DriversSumAggregateOutputType | null
    _min: DriversMinAggregateOutputType | null
    _max: DriversMaxAggregateOutputType | null
  }

  export type DriversAvgAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type DriversSumAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type DriversMinAggregateOutputType = {
    ID: number | null
    FirstName: string | null
    MiddleName: string | null
    LastName: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    DOB: Date | null
    License: string | null
    Email: string | null
    Phone: string | null
    Notes: string | null
    Deleted: boolean | null
    HireDate: string | null
    OwnerOperator: boolean | null
  }

  export type DriversMaxAggregateOutputType = {
    ID: number | null
    FirstName: string | null
    MiddleName: string | null
    LastName: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    DOB: Date | null
    License: string | null
    Email: string | null
    Phone: string | null
    Notes: string | null
    Deleted: boolean | null
    HireDate: string | null
    OwnerOperator: boolean | null
  }

  export type DriversCountAggregateOutputType = {
    ID: number
    FirstName: number
    MiddleName: number
    LastName: number
    Street: number
    City: number
    State: number
    ZIP: number
    DOB: number
    License: number
    Email: number
    Phone: number
    Notes: number
    Deleted: number
    HireDate: number
    OwnerOperator: number
    _all: number
  }


  export type DriversAvgAggregateInputType = {
    ID?: true
    State?: true
  }

  export type DriversSumAggregateInputType = {
    ID?: true
    State?: true
  }

  export type DriversMinAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    DOB?: true
    License?: true
    Email?: true
    Phone?: true
    Notes?: true
    Deleted?: true
    HireDate?: true
    OwnerOperator?: true
  }

  export type DriversMaxAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    DOB?: true
    License?: true
    Email?: true
    Phone?: true
    Notes?: true
    Deleted?: true
    HireDate?: true
    OwnerOperator?: true
  }

  export type DriversCountAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    DOB?: true
    License?: true
    Email?: true
    Phone?: true
    Notes?: true
    Deleted?: true
    HireDate?: true
    OwnerOperator?: true
    _all?: true
  }

  export type DriversAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to aggregate.
     */
    where?: DriversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriversOrderByWithRelationInput | DriversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriversMaxAggregateInputType
  }

  export type GetDriversAggregateType<T extends DriversAggregateArgs> = {
        [P in keyof T & keyof AggregateDrivers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrivers[P]>
      : GetScalarType<T[P], AggregateDrivers[P]>
  }




  export type DriversGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriversWhereInput
    orderBy?: DriversOrderByWithAggregationInput | DriversOrderByWithAggregationInput[]
    by: DriversScalarFieldEnum[] | DriversScalarFieldEnum
    having?: DriversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriversCountAggregateInputType | true
    _avg?: DriversAvgAggregateInputType
    _sum?: DriversSumAggregateInputType
    _min?: DriversMinAggregateInputType
    _max?: DriversMaxAggregateInputType
  }

  export type DriversGroupByOutputType = {
    ID: number
    FirstName: string
    MiddleName: string | null
    LastName: string
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    DOB: Date | null
    License: string | null
    Email: string | null
    Phone: string | null
    Notes: string | null
    Deleted: boolean | null
    HireDate: string | null
    OwnerOperator: boolean
    _count: DriversCountAggregateOutputType | null
    _avg: DriversAvgAggregateOutputType | null
    _sum: DriversSumAggregateOutputType | null
    _min: DriversMinAggregateOutputType | null
    _max: DriversMaxAggregateOutputType | null
  }

  type GetDriversGroupByPayload<T extends DriversGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriversGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriversGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriversGroupByOutputType[P]>
            : GetScalarType<T[P], DriversGroupByOutputType[P]>
        }
      >
    >


  export type DriversSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    FirstName?: boolean
    MiddleName?: boolean
    LastName?: boolean
    Street?: boolean
    City?: boolean
    State?: boolean
    ZIP?: boolean
    DOB?: boolean
    License?: boolean
    Email?: boolean
    Phone?: boolean
    Notes?: boolean
    Deleted?: boolean
    HireDate?: boolean
    OwnerOperator?: boolean
    States?: boolean | Drivers$StatesArgs<ExtArgs>
    Dailies?: boolean | Drivers$DailiesArgs<ExtArgs>
    Jobs?: boolean | Drivers$JobsArgs<ExtArgs>
    Loads?: boolean | Drivers$LoadsArgs<ExtArgs>
    PayStubs?: boolean | Drivers$PayStubsArgs<ExtArgs>
    TrucksDriven?: boolean | Drivers$TrucksDrivenArgs<ExtArgs>
    _count?: boolean | DriversCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drivers"]>



  export type DriversSelectScalar = {
    ID?: boolean
    FirstName?: boolean
    MiddleName?: boolean
    LastName?: boolean
    Street?: boolean
    City?: boolean
    State?: boolean
    ZIP?: boolean
    DOB?: boolean
    License?: boolean
    Email?: boolean
    Phone?: boolean
    Notes?: boolean
    Deleted?: boolean
    HireDate?: boolean
    OwnerOperator?: boolean
  }

  export type DriversOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "FirstName" | "MiddleName" | "LastName" | "Street" | "City" | "State" | "ZIP" | "DOB" | "License" | "Email" | "Phone" | "Notes" | "Deleted" | "HireDate" | "OwnerOperator", ExtArgs["result"]["drivers"]>
  export type DriversInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    States?: boolean | Drivers$StatesArgs<ExtArgs>
    Dailies?: boolean | Drivers$DailiesArgs<ExtArgs>
    Jobs?: boolean | Drivers$JobsArgs<ExtArgs>
    Loads?: boolean | Drivers$LoadsArgs<ExtArgs>
    PayStubs?: boolean | Drivers$PayStubsArgs<ExtArgs>
    TrucksDriven?: boolean | Drivers$TrucksDrivenArgs<ExtArgs>
    _count?: boolean | DriversCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DriversPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Drivers"
    objects: {
      States: Prisma.$StatesPayload<ExtArgs> | null
      Dailies: Prisma.$DailiesPayload<ExtArgs>[]
      Jobs: Prisma.$JobsPayload<ExtArgs>[]
      Loads: Prisma.$LoadsPayload<ExtArgs>[]
      PayStubs: Prisma.$PayStubsPayload<ExtArgs>[]
      TrucksDriven: Prisma.$TrucksDrivenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      /**
       * @zod.min(1)
       */
      FirstName: string
      MiddleName: string | null
      /**
       * @zod.min(1)
       */
      LastName: string
      Street: string | null
      City: string | null
      State: number | null
      ZIP: string | null
      DOB: Date | null
      License: string | null
      Email: string | null
      Phone: string | null
      Notes: string | null
      Deleted: boolean | null
      HireDate: string | null
      OwnerOperator: boolean
    }, ExtArgs["result"]["drivers"]>
    composites: {}
  }

  type DriversGetPayload<S extends boolean | null | undefined | DriversDefaultArgs> = $Result.GetResult<Prisma.$DriversPayload, S>

  type DriversCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriversFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriversCountAggregateInputType | true
    }

  export interface DriversDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Drivers'], meta: { name: 'Drivers' } }
    /**
     * Find zero or one Drivers that matches the filter.
     * @param {DriversFindUniqueArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriversFindUniqueArgs>(args: SelectSubset<T, DriversFindUniqueArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Drivers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriversFindUniqueOrThrowArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriversFindUniqueOrThrowArgs>(args: SelectSubset<T, DriversFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversFindFirstArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriversFindFirstArgs>(args?: SelectSubset<T, DriversFindFirstArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Drivers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversFindFirstOrThrowArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriversFindFirstOrThrowArgs>(args?: SelectSubset<T, DriversFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.drivers.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.drivers.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const driversWithIDOnly = await prisma.drivers.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends DriversFindManyArgs>(args?: SelectSubset<T, DriversFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Drivers.
     * @param {DriversCreateArgs} args - Arguments to create a Drivers.
     * @example
     * // Create one Drivers
     * const Drivers = await prisma.drivers.create({
     *   data: {
     *     // ... data to create a Drivers
     *   }
     * })
     * 
     */
    create<T extends DriversCreateArgs>(args: SelectSubset<T, DriversCreateArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drivers.
     * @param {DriversCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const drivers = await prisma.drivers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriversCreateManyArgs>(args?: SelectSubset<T, DriversCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Drivers.
     * @param {DriversDeleteArgs} args - Arguments to delete one Drivers.
     * @example
     * // Delete one Drivers
     * const Drivers = await prisma.drivers.delete({
     *   where: {
     *     // ... filter to delete one Drivers
     *   }
     * })
     * 
     */
    delete<T extends DriversDeleteArgs>(args: SelectSubset<T, DriversDeleteArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Drivers.
     * @param {DriversUpdateArgs} args - Arguments to update one Drivers.
     * @example
     * // Update one Drivers
     * const drivers = await prisma.drivers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriversUpdateArgs>(args: SelectSubset<T, DriversUpdateArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drivers.
     * @param {DriversDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.drivers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriversDeleteManyArgs>(args?: SelectSubset<T, DriversDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const drivers = await prisma.drivers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriversUpdateManyArgs>(args: SelectSubset<T, DriversUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drivers.
     * @param {DriversUpsertArgs} args - Arguments to update or create a Drivers.
     * @example
     * // Update or create a Drivers
     * const drivers = await prisma.drivers.upsert({
     *   create: {
     *     // ... data to create a Drivers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drivers we want to update
     *   }
     * })
     */
    upsert<T extends DriversUpsertArgs>(args: SelectSubset<T, DriversUpsertArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.drivers.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriversCountArgs>(
      args?: Subset<T, DriversCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriversAggregateArgs>(args: Subset<T, DriversAggregateArgs>): Prisma.PrismaPromise<GetDriversAggregateType<T>>

    /**
     * Group by Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriversGroupByArgs['orderBy'] }
        : { orderBy?: DriversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriversGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Drivers model
   */
  readonly fields: DriversFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Drivers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriversClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    States<T extends Drivers$StatesArgs<ExtArgs> = {}>(args?: Subset<T, Drivers$StatesArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Dailies<T extends Drivers$DailiesArgs<ExtArgs> = {}>(args?: Subset<T, Drivers$DailiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Jobs<T extends Drivers$JobsArgs<ExtArgs> = {}>(args?: Subset<T, Drivers$JobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Loads<T extends Drivers$LoadsArgs<ExtArgs> = {}>(args?: Subset<T, Drivers$LoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PayStubs<T extends Drivers$PayStubsArgs<ExtArgs> = {}>(args?: Subset<T, Drivers$PayStubsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TrucksDriven<T extends Drivers$TrucksDrivenArgs<ExtArgs> = {}>(args?: Subset<T, Drivers$TrucksDrivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Drivers model
   */
  interface DriversFieldRefs {
    readonly ID: FieldRef<"Drivers", 'Int'>
    readonly FirstName: FieldRef<"Drivers", 'String'>
    readonly MiddleName: FieldRef<"Drivers", 'String'>
    readonly LastName: FieldRef<"Drivers", 'String'>
    readonly Street: FieldRef<"Drivers", 'String'>
    readonly City: FieldRef<"Drivers", 'String'>
    readonly State: FieldRef<"Drivers", 'Int'>
    readonly ZIP: FieldRef<"Drivers", 'String'>
    readonly DOB: FieldRef<"Drivers", 'DateTime'>
    readonly License: FieldRef<"Drivers", 'String'>
    readonly Email: FieldRef<"Drivers", 'String'>
    readonly Phone: FieldRef<"Drivers", 'String'>
    readonly Notes: FieldRef<"Drivers", 'String'>
    readonly Deleted: FieldRef<"Drivers", 'Boolean'>
    readonly HireDate: FieldRef<"Drivers", 'String'>
    readonly OwnerOperator: FieldRef<"Drivers", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Drivers findUnique
   */
  export type DriversFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where: DriversWhereUniqueInput
  }

  /**
   * Drivers findUniqueOrThrow
   */
  export type DriversFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where: DriversWhereUniqueInput
  }

  /**
   * Drivers findFirst
   */
  export type DriversFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriversOrderByWithRelationInput | DriversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriversScalarFieldEnum | DriversScalarFieldEnum[]
  }

  /**
   * Drivers findFirstOrThrow
   */
  export type DriversFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriversOrderByWithRelationInput | DriversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriversScalarFieldEnum | DriversScalarFieldEnum[]
  }

  /**
   * Drivers findMany
   */
  export type DriversFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriversOrderByWithRelationInput | DriversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriversScalarFieldEnum | DriversScalarFieldEnum[]
  }

  /**
   * Drivers create
   */
  export type DriversCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * The data needed to create a Drivers.
     */
    data: XOR<DriversCreateInput, DriversUncheckedCreateInput>
  }

  /**
   * Drivers createMany
   */
  export type DriversCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriversCreateManyInput | DriversCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Drivers update
   */
  export type DriversUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * The data needed to update a Drivers.
     */
    data: XOR<DriversUpdateInput, DriversUncheckedUpdateInput>
    /**
     * Choose, which Drivers to update.
     */
    where: DriversWhereUniqueInput
  }

  /**
   * Drivers updateMany
   */
  export type DriversUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriversUpdateManyMutationInput, DriversUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriversWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Drivers upsert
   */
  export type DriversUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * The filter to search for the Drivers to update in case it exists.
     */
    where: DriversWhereUniqueInput
    /**
     * In case the Drivers found by the `where` argument doesn't exist, create a new Drivers with this data.
     */
    create: XOR<DriversCreateInput, DriversUncheckedCreateInput>
    /**
     * In case the Drivers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriversUpdateInput, DriversUncheckedUpdateInput>
  }

  /**
   * Drivers delete
   */
  export type DriversDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    /**
     * Filter which Drivers to delete.
     */
    where: DriversWhereUniqueInput
  }

  /**
   * Drivers deleteMany
   */
  export type DriversDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriversWhereInput
    /**
     * Limit how many Drivers to delete.
     */
    limit?: number
  }

  /**
   * Drivers.States
   */
  export type Drivers$StatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    where?: StatesWhereInput
  }

  /**
   * Drivers.Dailies
   */
  export type Drivers$DailiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    where?: DailiesWhereInput
    orderBy?: DailiesOrderByWithRelationInput | DailiesOrderByWithRelationInput[]
    cursor?: DailiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailiesScalarFieldEnum | DailiesScalarFieldEnum[]
  }

  /**
   * Drivers.Jobs
   */
  export type Drivers$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Drivers.Loads
   */
  export type Drivers$LoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    cursor?: LoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Drivers.PayStubs
   */
  export type Drivers$PayStubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    where?: PayStubsWhereInput
    orderBy?: PayStubsOrderByWithRelationInput | PayStubsOrderByWithRelationInput[]
    cursor?: PayStubsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayStubsScalarFieldEnum | PayStubsScalarFieldEnum[]
  }

  /**
   * Drivers.TrucksDriven
   */
  export type Drivers$TrucksDrivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    where?: TrucksDrivenWhereInput
    orderBy?: TrucksDrivenOrderByWithRelationInput | TrucksDrivenOrderByWithRelationInput[]
    cursor?: TrucksDrivenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrucksDrivenScalarFieldEnum | TrucksDrivenScalarFieldEnum[]
  }

  /**
   * Drivers without action
   */
  export type DriversDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
  }


  /**
   * Model Invoices
   */

  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  export type InvoicesAvgAggregateOutputType = {
    ID: number | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    ConsolidatedID: number | null
  }

  export type InvoicesSumAggregateOutputType = {
    ID: number | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    ConsolidatedID: number | null
  }

  export type InvoicesMinAggregateOutputType = {
    ID: number | null
    InvoiceDate: Date | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    PaidDate: Date | null
    CheckNumber: string | null
    Paid: boolean | null
    Printed: boolean | null
    Deleted: boolean | null
    PaymentType: string | null
    Consolidated: boolean | null
    ConsolidatedID: number | null
  }

  export type InvoicesMaxAggregateOutputType = {
    ID: number | null
    InvoiceDate: Date | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    PaidDate: Date | null
    CheckNumber: string | null
    Paid: boolean | null
    Printed: boolean | null
    Deleted: boolean | null
    PaymentType: string | null
    Consolidated: boolean | null
    ConsolidatedID: number | null
  }

  export type InvoicesCountAggregateOutputType = {
    ID: number
    InvoiceDate: number
    Number: number
    CustomerID: number
    TotalAmount: number
    PaidDate: number
    CheckNumber: number
    Paid: number
    Printed: number
    Deleted: number
    PaymentType: number
    Consolidated: number
    ConsolidatedID: number
    _all: number
  }


  export type InvoicesAvgAggregateInputType = {
    ID?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    ConsolidatedID?: true
  }

  export type InvoicesSumAggregateInputType = {
    ID?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    ConsolidatedID?: true
  }

  export type InvoicesMinAggregateInputType = {
    ID?: true
    InvoiceDate?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    PaidDate?: true
    CheckNumber?: true
    Paid?: true
    Printed?: true
    Deleted?: true
    PaymentType?: true
    Consolidated?: true
    ConsolidatedID?: true
  }

  export type InvoicesMaxAggregateInputType = {
    ID?: true
    InvoiceDate?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    PaidDate?: true
    CheckNumber?: true
    Paid?: true
    Printed?: true
    Deleted?: true
    PaymentType?: true
    Consolidated?: true
    ConsolidatedID?: true
  }

  export type InvoicesCountAggregateInputType = {
    ID?: true
    InvoiceDate?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    PaidDate?: true
    CheckNumber?: true
    Paid?: true
    Printed?: true
    Deleted?: true
    PaymentType?: true
    Consolidated?: true
    ConsolidatedID?: true
    _all?: true
  }

  export type InvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to aggregate.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicesMaxAggregateInputType
  }

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>
  }




  export type InvoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicesWhereInput
    orderBy?: InvoicesOrderByWithAggregationInput | InvoicesOrderByWithAggregationInput[]
    by: InvoicesScalarFieldEnum[] | InvoicesScalarFieldEnum
    having?: InvoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicesCountAggregateInputType | true
    _avg?: InvoicesAvgAggregateInputType
    _sum?: InvoicesSumAggregateInputType
    _min?: InvoicesMinAggregateInputType
    _max?: InvoicesMaxAggregateInputType
  }

  export type InvoicesGroupByOutputType = {
    ID: number
    InvoiceDate: Date
    Number: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate: Date | null
    CheckNumber: string | null
    Paid: boolean | null
    Printed: boolean | null
    Deleted: boolean | null
    PaymentType: string | null
    Consolidated: boolean | null
    ConsolidatedID: number | null
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  type GetInvoicesGroupByPayload<T extends InvoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
        }
      >
    >


  export type InvoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    InvoiceDate?: boolean
    Number?: boolean
    CustomerID?: boolean
    TotalAmount?: boolean
    PaidDate?: boolean
    CheckNumber?: boolean
    Paid?: boolean
    Printed?: boolean
    Deleted?: boolean
    PaymentType?: boolean
    Consolidated?: boolean
    ConsolidatedID?: boolean
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    Loads?: boolean | Invoices$LoadsArgs<ExtArgs>
    Weeklies?: boolean | Invoices$WeekliesArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>



  export type InvoicesSelectScalar = {
    ID?: boolean
    InvoiceDate?: boolean
    Number?: boolean
    CustomerID?: boolean
    TotalAmount?: boolean
    PaidDate?: boolean
    CheckNumber?: boolean
    Paid?: boolean
    Printed?: boolean
    Deleted?: boolean
    PaymentType?: boolean
    Consolidated?: boolean
    ConsolidatedID?: boolean
  }

  export type InvoicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "InvoiceDate" | "Number" | "CustomerID" | "TotalAmount" | "PaidDate" | "CheckNumber" | "Paid" | "Printed" | "Deleted" | "PaymentType" | "Consolidated" | "ConsolidatedID", ExtArgs["result"]["invoices"]>
  export type InvoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    Loads?: boolean | Invoices$LoadsArgs<ExtArgs>
    Weeklies?: boolean | Invoices$WeekliesArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InvoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoices"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>
      Loads: Prisma.$LoadsPayload<ExtArgs>[]
      Weeklies: Prisma.$WeekliesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      /**
       * @zod.custom(z.coerce.date())
       */
      InvoiceDate: Date
      Number: number | null
      /**
       * @zod.min(1)
       */
      CustomerID: number
      /**
       * @zod.min(1)
       */
      TotalAmount: number
      /**
       * @zod.custom(z.coerce.date())
       */
      PaidDate: Date | null
      CheckNumber: string | null
      Paid: boolean | null
      Printed: boolean | null
      Deleted: boolean | null
      PaymentType: string | null
      Consolidated: boolean | null
      ConsolidatedID: number | null
    }, ExtArgs["result"]["invoices"]>
    composites: {}
  }

  type InvoicesGetPayload<S extends boolean | null | undefined | InvoicesDefaultArgs> = $Result.GetResult<Prisma.$InvoicesPayload, S>

  type InvoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicesCountAggregateInputType | true
    }

  export interface InvoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoices'], meta: { name: 'Invoices' } }
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {InvoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoicesFindUniqueArgs>(args: SelectSubset<T, InvoicesFindUniqueArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoicesFindFirstArgs>(args?: SelectSubset<T, InvoicesFindFirstArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const invoicesWithIDOnly = await prisma.invoices.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends InvoicesFindManyArgs>(args?: SelectSubset<T, InvoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoices.
     * @param {InvoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     * 
     */
    create<T extends InvoicesCreateArgs>(args: SelectSubset<T, InvoicesCreateArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoicesCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoicesCreateManyArgs>(args?: SelectSubset<T, InvoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoices.
     * @param {InvoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     * 
     */
    delete<T extends InvoicesDeleteArgs>(args: SelectSubset<T, InvoicesDeleteArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoices.
     * @param {InvoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoicesUpdateArgs>(args: SelectSubset<T, InvoicesUpdateArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoicesDeleteManyArgs>(args?: SelectSubset<T, InvoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoicesUpdateManyArgs>(args: SelectSubset<T, InvoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoices.
     * @param {InvoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
     */
    upsert<T extends InvoicesUpsertArgs>(args: SelectSubset<T, InvoicesUpsertArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoicesCountArgs>(
      args?: Subset<T, InvoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicesAggregateArgs>(args: Subset<T, InvoicesAggregateArgs>): Prisma.PrismaPromise<GetInvoicesAggregateType<T>>

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicesGroupByArgs['orderBy'] }
        : { orderBy?: InvoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoices model
   */
  readonly fields: InvoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Loads<T extends Invoices$LoadsArgs<ExtArgs> = {}>(args?: Subset<T, Invoices$LoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Weeklies<T extends Invoices$WeekliesArgs<ExtArgs> = {}>(args?: Subset<T, Invoices$WeekliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoices model
   */
  interface InvoicesFieldRefs {
    readonly ID: FieldRef<"Invoices", 'Int'>
    readonly InvoiceDate: FieldRef<"Invoices", 'DateTime'>
    readonly Number: FieldRef<"Invoices", 'Int'>
    readonly CustomerID: FieldRef<"Invoices", 'Int'>
    readonly TotalAmount: FieldRef<"Invoices", 'Float'>
    readonly PaidDate: FieldRef<"Invoices", 'DateTime'>
    readonly CheckNumber: FieldRef<"Invoices", 'String'>
    readonly Paid: FieldRef<"Invoices", 'Boolean'>
    readonly Printed: FieldRef<"Invoices", 'Boolean'>
    readonly Deleted: FieldRef<"Invoices", 'Boolean'>
    readonly PaymentType: FieldRef<"Invoices", 'String'>
    readonly Consolidated: FieldRef<"Invoices", 'Boolean'>
    readonly ConsolidatedID: FieldRef<"Invoices", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Invoices findUnique
   */
  export type InvoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices findUniqueOrThrow
   */
  export type InvoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices findFirst
   */
  export type InvoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Invoices findFirstOrThrow
   */
  export type InvoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Invoices findMany
   */
  export type InvoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Invoices create
   */
  export type InvoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoices.
     */
    data: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
  }

  /**
   * Invoices createMany
   */
  export type InvoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoicesCreateManyInput | InvoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoices update
   */
  export type InvoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoices.
     */
    data: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
    /**
     * Choose, which Invoices to update.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices updateMany
   */
  export type InvoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoicesWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoices upsert
   */
  export type InvoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoices to update in case it exists.
     */
    where: InvoicesWhereUniqueInput
    /**
     * In case the Invoices found by the `where` argument doesn't exist, create a new Invoices with this data.
     */
    create: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
    /**
     * In case the Invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
  }

  /**
   * Invoices delete
   */
  export type InvoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter which Invoices to delete.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices deleteMany
   */
  export type InvoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoicesWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoices.Loads
   */
  export type Invoices$LoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    cursor?: LoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Invoices.Weeklies
   */
  export type Invoices$WeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    where?: WeekliesWhereInput
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    cursor?: WeekliesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekliesScalarFieldEnum | WeekliesScalarFieldEnum[]
  }

  /**
   * Invoices without action
   */
  export type InvoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
  }


  /**
   * Model LoadTypes
   */

  export type AggregateLoadTypes = {
    _count: LoadTypesCountAggregateOutputType | null
    _avg: LoadTypesAvgAggregateOutputType | null
    _sum: LoadTypesSumAggregateOutputType | null
    _min: LoadTypesMinAggregateOutputType | null
    _max: LoadTypesMaxAggregateOutputType | null
  }

  export type LoadTypesAvgAggregateOutputType = {
    ID: number | null
    SourceID: number | null
  }

  export type LoadTypesSumAggregateOutputType = {
    ID: number | null
    SourceID: number | null
  }

  export type LoadTypesMinAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    SourceID: number | null
    Notes: string | null
  }

  export type LoadTypesMaxAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    SourceID: number | null
    Notes: string | null
  }

  export type LoadTypesCountAggregateOutputType = {
    ID: number
    Description: number
    Deleted: number
    SourceID: number
    Notes: number
    _all: number
  }


  export type LoadTypesAvgAggregateInputType = {
    ID?: true
    SourceID?: true
  }

  export type LoadTypesSumAggregateInputType = {
    ID?: true
    SourceID?: true
  }

  export type LoadTypesMinAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    SourceID?: true
    Notes?: true
  }

  export type LoadTypesMaxAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    SourceID?: true
    Notes?: true
  }

  export type LoadTypesCountAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    SourceID?: true
    Notes?: true
    _all?: true
  }

  export type LoadTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoadTypes to aggregate.
     */
    where?: LoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoadTypes to fetch.
     */
    orderBy?: LoadTypesOrderByWithRelationInput | LoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoadTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoadTypes
    **/
    _count?: true | LoadTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoadTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoadTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoadTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoadTypesMaxAggregateInputType
  }

  export type GetLoadTypesAggregateType<T extends LoadTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateLoadTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoadTypes[P]>
      : GetScalarType<T[P], AggregateLoadTypes[P]>
  }




  export type LoadTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadTypesWhereInput
    orderBy?: LoadTypesOrderByWithAggregationInput | LoadTypesOrderByWithAggregationInput[]
    by: LoadTypesScalarFieldEnum[] | LoadTypesScalarFieldEnum
    having?: LoadTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoadTypesCountAggregateInputType | true
    _avg?: LoadTypesAvgAggregateInputType
    _sum?: LoadTypesSumAggregateInputType
    _min?: LoadTypesMinAggregateInputType
    _max?: LoadTypesMaxAggregateInputType
  }

  export type LoadTypesGroupByOutputType = {
    ID: number
    Description: string
    Deleted: boolean | null
    SourceID: number | null
    Notes: string | null
    _count: LoadTypesCountAggregateOutputType | null
    _avg: LoadTypesAvgAggregateOutputType | null
    _sum: LoadTypesSumAggregateOutputType | null
    _min: LoadTypesMinAggregateOutputType | null
    _max: LoadTypesMaxAggregateOutputType | null
  }

  type GetLoadTypesGroupByPayload<T extends LoadTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoadTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoadTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoadTypesGroupByOutputType[P]>
            : GetScalarType<T[P], LoadTypesGroupByOutputType[P]>
        }
      >
    >


  export type LoadTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Description?: boolean
    Deleted?: boolean
    SourceID?: boolean
    Notes?: boolean
    CustomerLoadTypes?: boolean | LoadTypes$CustomerLoadTypesArgs<ExtArgs>
    Jobs?: boolean | LoadTypes$JobsArgs<ExtArgs>
    Loads?: boolean | LoadTypes$LoadsArgs<ExtArgs>
    Weeklies?: boolean | LoadTypes$WeekliesArgs<ExtArgs>
    _count?: boolean | LoadTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loadTypes"]>



  export type LoadTypesSelectScalar = {
    ID?: boolean
    Description?: boolean
    Deleted?: boolean
    SourceID?: boolean
    Notes?: boolean
  }

  export type LoadTypesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Description" | "Deleted" | "SourceID" | "Notes", ExtArgs["result"]["loadTypes"]>
  export type LoadTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerLoadTypes?: boolean | LoadTypes$CustomerLoadTypesArgs<ExtArgs>
    Jobs?: boolean | LoadTypes$JobsArgs<ExtArgs>
    Loads?: boolean | LoadTypes$LoadsArgs<ExtArgs>
    Weeklies?: boolean | LoadTypes$WeekliesArgs<ExtArgs>
    _count?: boolean | LoadTypesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LoadTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoadTypes"
    objects: {
      CustomerLoadTypes: Prisma.$CustomerLoadTypesPayload<ExtArgs>[]
      Jobs: Prisma.$JobsPayload<ExtArgs>[]
      Loads: Prisma.$LoadsPayload<ExtArgs>[]
      Weeklies: Prisma.$WeekliesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      /**
       * @zod.min(1)
       */
      Description: string
      Deleted: boolean | null
      SourceID: number | null
      Notes: string | null
    }, ExtArgs["result"]["loadTypes"]>
    composites: {}
  }

  type LoadTypesGetPayload<S extends boolean | null | undefined | LoadTypesDefaultArgs> = $Result.GetResult<Prisma.$LoadTypesPayload, S>

  type LoadTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoadTypesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoadTypesCountAggregateInputType | true
    }

  export interface LoadTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoadTypes'], meta: { name: 'LoadTypes' } }
    /**
     * Find zero or one LoadTypes that matches the filter.
     * @param {LoadTypesFindUniqueArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoadTypesFindUniqueArgs>(args: SelectSubset<T, LoadTypesFindUniqueArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoadTypes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoadTypesFindUniqueOrThrowArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoadTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, LoadTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesFindFirstArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoadTypesFindFirstArgs>(args?: SelectSubset<T, LoadTypesFindFirstArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoadTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesFindFirstOrThrowArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoadTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, LoadTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoadTypes
     * const loadTypes = await prisma.loadTypes.findMany()
     * 
     * // Get first 10 LoadTypes
     * const loadTypes = await prisma.loadTypes.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const loadTypesWithIDOnly = await prisma.loadTypes.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends LoadTypesFindManyArgs>(args?: SelectSubset<T, LoadTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoadTypes.
     * @param {LoadTypesCreateArgs} args - Arguments to create a LoadTypes.
     * @example
     * // Create one LoadTypes
     * const LoadTypes = await prisma.loadTypes.create({
     *   data: {
     *     // ... data to create a LoadTypes
     *   }
     * })
     * 
     */
    create<T extends LoadTypesCreateArgs>(args: SelectSubset<T, LoadTypesCreateArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoadTypes.
     * @param {LoadTypesCreateManyArgs} args - Arguments to create many LoadTypes.
     * @example
     * // Create many LoadTypes
     * const loadTypes = await prisma.loadTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoadTypesCreateManyArgs>(args?: SelectSubset<T, LoadTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LoadTypes.
     * @param {LoadTypesDeleteArgs} args - Arguments to delete one LoadTypes.
     * @example
     * // Delete one LoadTypes
     * const LoadTypes = await prisma.loadTypes.delete({
     *   where: {
     *     // ... filter to delete one LoadTypes
     *   }
     * })
     * 
     */
    delete<T extends LoadTypesDeleteArgs>(args: SelectSubset<T, LoadTypesDeleteArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoadTypes.
     * @param {LoadTypesUpdateArgs} args - Arguments to update one LoadTypes.
     * @example
     * // Update one LoadTypes
     * const loadTypes = await prisma.loadTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoadTypesUpdateArgs>(args: SelectSubset<T, LoadTypesUpdateArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoadTypes.
     * @param {LoadTypesDeleteManyArgs} args - Arguments to filter LoadTypes to delete.
     * @example
     * // Delete a few LoadTypes
     * const { count } = await prisma.loadTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoadTypesDeleteManyArgs>(args?: SelectSubset<T, LoadTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoadTypes
     * const loadTypes = await prisma.loadTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoadTypesUpdateManyArgs>(args: SelectSubset<T, LoadTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoadTypes.
     * @param {LoadTypesUpsertArgs} args - Arguments to update or create a LoadTypes.
     * @example
     * // Update or create a LoadTypes
     * const loadTypes = await prisma.loadTypes.upsert({
     *   create: {
     *     // ... data to create a LoadTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoadTypes we want to update
     *   }
     * })
     */
    upsert<T extends LoadTypesUpsertArgs>(args: SelectSubset<T, LoadTypesUpsertArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesCountArgs} args - Arguments to filter LoadTypes to count.
     * @example
     * // Count the number of LoadTypes
     * const count = await prisma.loadTypes.count({
     *   where: {
     *     // ... the filter for the LoadTypes we want to count
     *   }
     * })
    **/
    count<T extends LoadTypesCountArgs>(
      args?: Subset<T, LoadTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoadTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoadTypesAggregateArgs>(args: Subset<T, LoadTypesAggregateArgs>): Prisma.PrismaPromise<GetLoadTypesAggregateType<T>>

    /**
     * Group by LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoadTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoadTypesGroupByArgs['orderBy'] }
        : { orderBy?: LoadTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoadTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoadTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoadTypes model
   */
  readonly fields: LoadTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoadTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoadTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CustomerLoadTypes<T extends LoadTypes$CustomerLoadTypesArgs<ExtArgs> = {}>(args?: Subset<T, LoadTypes$CustomerLoadTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerLoadTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Jobs<T extends LoadTypes$JobsArgs<ExtArgs> = {}>(args?: Subset<T, LoadTypes$JobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Loads<T extends LoadTypes$LoadsArgs<ExtArgs> = {}>(args?: Subset<T, LoadTypes$LoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Weeklies<T extends LoadTypes$WeekliesArgs<ExtArgs> = {}>(args?: Subset<T, LoadTypes$WeekliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoadTypes model
   */
  interface LoadTypesFieldRefs {
    readonly ID: FieldRef<"LoadTypes", 'Int'>
    readonly Description: FieldRef<"LoadTypes", 'String'>
    readonly Deleted: FieldRef<"LoadTypes", 'Boolean'>
    readonly SourceID: FieldRef<"LoadTypes", 'Int'>
    readonly Notes: FieldRef<"LoadTypes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LoadTypes findUnique
   */
  export type LoadTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which LoadTypes to fetch.
     */
    where: LoadTypesWhereUniqueInput
  }

  /**
   * LoadTypes findUniqueOrThrow
   */
  export type LoadTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which LoadTypes to fetch.
     */
    where: LoadTypesWhereUniqueInput
  }

  /**
   * LoadTypes findFirst
   */
  export type LoadTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which LoadTypes to fetch.
     */
    where?: LoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoadTypes to fetch.
     */
    orderBy?: LoadTypesOrderByWithRelationInput | LoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoadTypes.
     */
    cursor?: LoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoadTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoadTypes.
     */
    distinct?: LoadTypesScalarFieldEnum | LoadTypesScalarFieldEnum[]
  }

  /**
   * LoadTypes findFirstOrThrow
   */
  export type LoadTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which LoadTypes to fetch.
     */
    where?: LoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoadTypes to fetch.
     */
    orderBy?: LoadTypesOrderByWithRelationInput | LoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoadTypes.
     */
    cursor?: LoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoadTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoadTypes.
     */
    distinct?: LoadTypesScalarFieldEnum | LoadTypesScalarFieldEnum[]
  }

  /**
   * LoadTypes findMany
   */
  export type LoadTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * Filter, which LoadTypes to fetch.
     */
    where?: LoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoadTypes to fetch.
     */
    orderBy?: LoadTypesOrderByWithRelationInput | LoadTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoadTypes.
     */
    cursor?: LoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoadTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoadTypes.
     */
    skip?: number
    distinct?: LoadTypesScalarFieldEnum | LoadTypesScalarFieldEnum[]
  }

  /**
   * LoadTypes create
   */
  export type LoadTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a LoadTypes.
     */
    data: XOR<LoadTypesCreateInput, LoadTypesUncheckedCreateInput>
  }

  /**
   * LoadTypes createMany
   */
  export type LoadTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoadTypes.
     */
    data: LoadTypesCreateManyInput | LoadTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoadTypes update
   */
  export type LoadTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a LoadTypes.
     */
    data: XOR<LoadTypesUpdateInput, LoadTypesUncheckedUpdateInput>
    /**
     * Choose, which LoadTypes to update.
     */
    where: LoadTypesWhereUniqueInput
  }

  /**
   * LoadTypes updateMany
   */
  export type LoadTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoadTypes.
     */
    data: XOR<LoadTypesUpdateManyMutationInput, LoadTypesUncheckedUpdateManyInput>
    /**
     * Filter which LoadTypes to update
     */
    where?: LoadTypesWhereInput
    /**
     * Limit how many LoadTypes to update.
     */
    limit?: number
  }

  /**
   * LoadTypes upsert
   */
  export type LoadTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the LoadTypes to update in case it exists.
     */
    where: LoadTypesWhereUniqueInput
    /**
     * In case the LoadTypes found by the `where` argument doesn't exist, create a new LoadTypes with this data.
     */
    create: XOR<LoadTypesCreateInput, LoadTypesUncheckedCreateInput>
    /**
     * In case the LoadTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoadTypesUpdateInput, LoadTypesUncheckedUpdateInput>
  }

  /**
   * LoadTypes delete
   */
  export type LoadTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    /**
     * Filter which LoadTypes to delete.
     */
    where: LoadTypesWhereUniqueInput
  }

  /**
   * LoadTypes deleteMany
   */
  export type LoadTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoadTypes to delete
     */
    where?: LoadTypesWhereInput
    /**
     * Limit how many LoadTypes to delete.
     */
    limit?: number
  }

  /**
   * LoadTypes.CustomerLoadTypes
   */
  export type LoadTypes$CustomerLoadTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     */
    select?: CustomerLoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLoadTypes
     */
    omit?: CustomerLoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLoadTypesInclude<ExtArgs> | null
    where?: CustomerLoadTypesWhereInput
    orderBy?: CustomerLoadTypesOrderByWithRelationInput | CustomerLoadTypesOrderByWithRelationInput[]
    cursor?: CustomerLoadTypesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerLoadTypesScalarFieldEnum | CustomerLoadTypesScalarFieldEnum[]
  }

  /**
   * LoadTypes.Jobs
   */
  export type LoadTypes$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * LoadTypes.Loads
   */
  export type LoadTypes$LoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    cursor?: LoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * LoadTypes.Weeklies
   */
  export type LoadTypes$WeekliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    where?: WeekliesWhereInput
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    cursor?: WeekliesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeekliesScalarFieldEnum | WeekliesScalarFieldEnum[]
  }

  /**
   * LoadTypes without action
   */
  export type LoadTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
  }


  /**
   * Model States
   */

  export type AggregateStates = {
    _count: StatesCountAggregateOutputType | null
    _avg: StatesAvgAggregateOutputType | null
    _sum: StatesSumAggregateOutputType | null
    _min: StatesMinAggregateOutputType | null
    _max: StatesMaxAggregateOutputType | null
  }

  export type StatesAvgAggregateOutputType = {
    ID: number | null
  }

  export type StatesSumAggregateOutputType = {
    ID: number | null
  }

  export type StatesMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    Abbreviation: string | null
  }

  export type StatesMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    Abbreviation: string | null
  }

  export type StatesCountAggregateOutputType = {
    ID: number
    Name: number
    Abbreviation: number
    _all: number
  }


  export type StatesAvgAggregateInputType = {
    ID?: true
  }

  export type StatesSumAggregateInputType = {
    ID?: true
  }

  export type StatesMinAggregateInputType = {
    ID?: true
    Name?: true
    Abbreviation?: true
  }

  export type StatesMaxAggregateInputType = {
    ID?: true
    Name?: true
    Abbreviation?: true
  }

  export type StatesCountAggregateInputType = {
    ID?: true
    Name?: true
    Abbreviation?: true
    _all?: true
  }

  export type StatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which States to aggregate.
     */
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StatesOrderByWithRelationInput | StatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatesMaxAggregateInputType
  }

  export type GetStatesAggregateType<T extends StatesAggregateArgs> = {
        [P in keyof T & keyof AggregateStates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStates[P]>
      : GetScalarType<T[P], AggregateStates[P]>
  }




  export type StatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatesWhereInput
    orderBy?: StatesOrderByWithAggregationInput | StatesOrderByWithAggregationInput[]
    by: StatesScalarFieldEnum[] | StatesScalarFieldEnum
    having?: StatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatesCountAggregateInputType | true
    _avg?: StatesAvgAggregateInputType
    _sum?: StatesSumAggregateInputType
    _min?: StatesMinAggregateInputType
    _max?: StatesMaxAggregateInputType
  }

  export type StatesGroupByOutputType = {
    ID: number
    Name: string
    Abbreviation: string
    _count: StatesCountAggregateOutputType | null
    _avg: StatesAvgAggregateOutputType | null
    _sum: StatesSumAggregateOutputType | null
    _min: StatesMinAggregateOutputType | null
    _max: StatesMaxAggregateOutputType | null
  }

  type GetStatesGroupByPayload<T extends StatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatesGroupByOutputType[P]>
            : GetScalarType<T[P], StatesGroupByOutputType[P]>
        }
      >
    >


  export type StatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    Abbreviation?: boolean
    Customers?: boolean | States$CustomersArgs<ExtArgs>
    Drivers?: boolean | States$DriversArgs<ExtArgs>
    _count?: boolean | StatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["states"]>



  export type StatesSelectScalar = {
    ID?: boolean
    Name?: boolean
    Abbreviation?: boolean
  }

  export type StatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Name" | "Abbreviation", ExtArgs["result"]["states"]>
  export type StatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | States$CustomersArgs<ExtArgs>
    Drivers?: boolean | States$DriversArgs<ExtArgs>
    _count?: boolean | StatesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "States"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>[]
      Drivers: Prisma.$DriversPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string
      Abbreviation: string
    }, ExtArgs["result"]["states"]>
    composites: {}
  }

  type StatesGetPayload<S extends boolean | null | undefined | StatesDefaultArgs> = $Result.GetResult<Prisma.$StatesPayload, S>

  type StatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatesCountAggregateInputType | true
    }

  export interface StatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['States'], meta: { name: 'States' } }
    /**
     * Find zero or one States that matches the filter.
     * @param {StatesFindUniqueArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatesFindUniqueArgs>(args: SelectSubset<T, StatesFindUniqueArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one States that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatesFindUniqueOrThrowArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatesFindUniqueOrThrowArgs>(args: SelectSubset<T, StatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindFirstArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatesFindFirstArgs>(args?: SelectSubset<T, StatesFindFirstArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first States that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindFirstOrThrowArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatesFindFirstOrThrowArgs>(args?: SelectSubset<T, StatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.states.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.states.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const statesWithIDOnly = await prisma.states.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends StatesFindManyArgs>(args?: SelectSubset<T, StatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a States.
     * @param {StatesCreateArgs} args - Arguments to create a States.
     * @example
     * // Create one States
     * const States = await prisma.states.create({
     *   data: {
     *     // ... data to create a States
     *   }
     * })
     * 
     */
    create<T extends StatesCreateArgs>(args: SelectSubset<T, StatesCreateArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many States.
     * @param {StatesCreateManyArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const states = await prisma.states.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatesCreateManyArgs>(args?: SelectSubset<T, StatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a States.
     * @param {StatesDeleteArgs} args - Arguments to delete one States.
     * @example
     * // Delete one States
     * const States = await prisma.states.delete({
     *   where: {
     *     // ... filter to delete one States
     *   }
     * })
     * 
     */
    delete<T extends StatesDeleteArgs>(args: SelectSubset<T, StatesDeleteArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one States.
     * @param {StatesUpdateArgs} args - Arguments to update one States.
     * @example
     * // Update one States
     * const states = await prisma.states.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatesUpdateArgs>(args: SelectSubset<T, StatesUpdateArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more States.
     * @param {StatesDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.states.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatesDeleteManyArgs>(args?: SelectSubset<T, StatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const states = await prisma.states.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatesUpdateManyArgs>(args: SelectSubset<T, StatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one States.
     * @param {StatesUpsertArgs} args - Arguments to update or create a States.
     * @example
     * // Update or create a States
     * const states = await prisma.states.upsert({
     *   create: {
     *     // ... data to create a States
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the States we want to update
     *   }
     * })
     */
    upsert<T extends StatesUpsertArgs>(args: SelectSubset<T, StatesUpsertArgs<ExtArgs>>): Prisma__StatesClient<$Result.GetResult<Prisma.$StatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.states.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StatesCountArgs>(
      args?: Subset<T, StatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatesAggregateArgs>(args: Subset<T, StatesAggregateArgs>): Prisma.PrismaPromise<GetStatesAggregateType<T>>

    /**
     * Group by States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatesGroupByArgs['orderBy'] }
        : { orderBy?: StatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the States model
   */
  readonly fields: StatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for States.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends States$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, States$CustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Drivers<T extends States$DriversArgs<ExtArgs> = {}>(args?: Subset<T, States$DriversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the States model
   */
  interface StatesFieldRefs {
    readonly ID: FieldRef<"States", 'Int'>
    readonly Name: FieldRef<"States", 'String'>
    readonly Abbreviation: FieldRef<"States", 'String'>
  }
    

  // Custom InputTypes
  /**
   * States findUnique
   */
  export type StatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where: StatesWhereUniqueInput
  }

  /**
   * States findUniqueOrThrow
   */
  export type StatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where: StatesWhereUniqueInput
  }

  /**
   * States findFirst
   */
  export type StatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StatesOrderByWithRelationInput | StatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: StatesScalarFieldEnum | StatesScalarFieldEnum[]
  }

  /**
   * States findFirstOrThrow
   */
  export type StatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StatesOrderByWithRelationInput | StatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: StatesScalarFieldEnum | StatesScalarFieldEnum[]
  }

  /**
   * States findMany
   */
  export type StatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: StatesOrderByWithRelationInput | StatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     */
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    distinct?: StatesScalarFieldEnum | StatesScalarFieldEnum[]
  }

  /**
   * States create
   */
  export type StatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * The data needed to create a States.
     */
    data: XOR<StatesCreateInput, StatesUncheckedCreateInput>
  }

  /**
   * States createMany
   */
  export type StatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many States.
     */
    data: StatesCreateManyInput | StatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * States update
   */
  export type StatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * The data needed to update a States.
     */
    data: XOR<StatesUpdateInput, StatesUncheckedUpdateInput>
    /**
     * Choose, which States to update.
     */
    where: StatesWhereUniqueInput
  }

  /**
   * States updateMany
   */
  export type StatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update States.
     */
    data: XOR<StatesUpdateManyMutationInput, StatesUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     */
    where?: StatesWhereInput
    /**
     * Limit how many States to update.
     */
    limit?: number
  }

  /**
   * States upsert
   */
  export type StatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * The filter to search for the States to update in case it exists.
     */
    where: StatesWhereUniqueInput
    /**
     * In case the States found by the `where` argument doesn't exist, create a new States with this data.
     */
    create: XOR<StatesCreateInput, StatesUncheckedCreateInput>
    /**
     * In case the States was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatesUpdateInput, StatesUncheckedUpdateInput>
  }

  /**
   * States delete
   */
  export type StatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
    /**
     * Filter which States to delete.
     */
    where: StatesWhereUniqueInput
  }

  /**
   * States deleteMany
   */
  export type StatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which States to delete
     */
    where?: StatesWhereInput
    /**
     * Limit how many States to delete.
     */
    limit?: number
  }

  /**
   * States.Customers
   */
  export type States$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    cursor?: CustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * States.Drivers
   */
  export type States$DriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    where?: DriversWhereInput
    orderBy?: DriversOrderByWithRelationInput | DriversOrderByWithRelationInput[]
    cursor?: DriversWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriversScalarFieldEnum | DriversScalarFieldEnum[]
  }

  /**
   * States without action
   */
  export type StatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the States
     */
    select?: StatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the States
     */
    omit?: StatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatesInclude<ExtArgs> | null
  }


  /**
   * Model Trucks
   */

  export type AggregateTrucks = {
    _count: TrucksCountAggregateOutputType | null
    _avg: TrucksAvgAggregateOutputType | null
    _sum: TrucksSumAggregateOutputType | null
    _min: TrucksMinAggregateOutputType | null
    _max: TrucksMaxAggregateOutputType | null
  }

  export type TrucksAvgAggregateOutputType = {
    ID: number | null
  }

  export type TrucksSumAggregateOutputType = {
    ID: number | null
  }

  export type TrucksMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    VIN: string | null
    Deleted: boolean | null
    Notes: string | null
  }

  export type TrucksMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    VIN: string | null
    Deleted: boolean | null
    Notes: string | null
  }

  export type TrucksCountAggregateOutputType = {
    ID: number
    Name: number
    VIN: number
    Deleted: number
    Notes: number
    _all: number
  }


  export type TrucksAvgAggregateInputType = {
    ID?: true
  }

  export type TrucksSumAggregateInputType = {
    ID?: true
  }

  export type TrucksMinAggregateInputType = {
    ID?: true
    Name?: true
    VIN?: true
    Deleted?: true
    Notes?: true
  }

  export type TrucksMaxAggregateInputType = {
    ID?: true
    Name?: true
    VIN?: true
    Deleted?: true
    Notes?: true
  }

  export type TrucksCountAggregateInputType = {
    ID?: true
    Name?: true
    VIN?: true
    Deleted?: true
    Notes?: true
    _all?: true
  }

  export type TrucksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trucks to aggregate.
     */
    where?: TrucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TrucksOrderByWithRelationInput | TrucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trucks
    **/
    _count?: true | TrucksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrucksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrucksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrucksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrucksMaxAggregateInputType
  }

  export type GetTrucksAggregateType<T extends TrucksAggregateArgs> = {
        [P in keyof T & keyof AggregateTrucks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrucks[P]>
      : GetScalarType<T[P], AggregateTrucks[P]>
  }




  export type TrucksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrucksWhereInput
    orderBy?: TrucksOrderByWithAggregationInput | TrucksOrderByWithAggregationInput[]
    by: TrucksScalarFieldEnum[] | TrucksScalarFieldEnum
    having?: TrucksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrucksCountAggregateInputType | true
    _avg?: TrucksAvgAggregateInputType
    _sum?: TrucksSumAggregateInputType
    _min?: TrucksMinAggregateInputType
    _max?: TrucksMaxAggregateInputType
  }

  export type TrucksGroupByOutputType = {
    ID: number
    Name: string
    VIN: string | null
    Deleted: boolean | null
    Notes: string | null
    _count: TrucksCountAggregateOutputType | null
    _avg: TrucksAvgAggregateOutputType | null
    _sum: TrucksSumAggregateOutputType | null
    _min: TrucksMinAggregateOutputType | null
    _max: TrucksMaxAggregateOutputType | null
  }

  type GetTrucksGroupByPayload<T extends TrucksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrucksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrucksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrucksGroupByOutputType[P]>
            : GetScalarType<T[P], TrucksGroupByOutputType[P]>
        }
      >
    >


  export type TrucksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    VIN?: boolean
    Deleted?: boolean
    Notes?: boolean
    Loads?: boolean | Trucks$LoadsArgs<ExtArgs>
    TrucksDriven?: boolean | Trucks$TrucksDrivenArgs<ExtArgs>
    _count?: boolean | TrucksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trucks"]>



  export type TrucksSelectScalar = {
    ID?: boolean
    Name?: boolean
    VIN?: boolean
    Deleted?: boolean
    Notes?: boolean
  }

  export type TrucksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Name" | "VIN" | "Deleted" | "Notes", ExtArgs["result"]["trucks"]>
  export type TrucksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loads?: boolean | Trucks$LoadsArgs<ExtArgs>
    TrucksDriven?: boolean | Trucks$TrucksDrivenArgs<ExtArgs>
    _count?: boolean | TrucksCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TrucksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trucks"
    objects: {
      Loads: Prisma.$LoadsPayload<ExtArgs>[]
      TrucksDriven: Prisma.$TrucksDrivenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      /**
       * @zod.min(1)
       */
      Name: string
      VIN: string | null
      Deleted: boolean | null
      Notes: string | null
    }, ExtArgs["result"]["trucks"]>
    composites: {}
  }

  type TrucksGetPayload<S extends boolean | null | undefined | TrucksDefaultArgs> = $Result.GetResult<Prisma.$TrucksPayload, S>

  type TrucksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrucksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrucksCountAggregateInputType | true
    }

  export interface TrucksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trucks'], meta: { name: 'Trucks' } }
    /**
     * Find zero or one Trucks that matches the filter.
     * @param {TrucksFindUniqueArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrucksFindUniqueArgs>(args: SelectSubset<T, TrucksFindUniqueArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trucks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrucksFindUniqueOrThrowArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrucksFindUniqueOrThrowArgs>(args: SelectSubset<T, TrucksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksFindFirstArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrucksFindFirstArgs>(args?: SelectSubset<T, TrucksFindFirstArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trucks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksFindFirstOrThrowArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrucksFindFirstOrThrowArgs>(args?: SelectSubset<T, TrucksFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trucks
     * const trucks = await prisma.trucks.findMany()
     * 
     * // Get first 10 Trucks
     * const trucks = await prisma.trucks.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const trucksWithIDOnly = await prisma.trucks.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends TrucksFindManyArgs>(args?: SelectSubset<T, TrucksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trucks.
     * @param {TrucksCreateArgs} args - Arguments to create a Trucks.
     * @example
     * // Create one Trucks
     * const Trucks = await prisma.trucks.create({
     *   data: {
     *     // ... data to create a Trucks
     *   }
     * })
     * 
     */
    create<T extends TrucksCreateArgs>(args: SelectSubset<T, TrucksCreateArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trucks.
     * @param {TrucksCreateManyArgs} args - Arguments to create many Trucks.
     * @example
     * // Create many Trucks
     * const trucks = await prisma.trucks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrucksCreateManyArgs>(args?: SelectSubset<T, TrucksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trucks.
     * @param {TrucksDeleteArgs} args - Arguments to delete one Trucks.
     * @example
     * // Delete one Trucks
     * const Trucks = await prisma.trucks.delete({
     *   where: {
     *     // ... filter to delete one Trucks
     *   }
     * })
     * 
     */
    delete<T extends TrucksDeleteArgs>(args: SelectSubset<T, TrucksDeleteArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trucks.
     * @param {TrucksUpdateArgs} args - Arguments to update one Trucks.
     * @example
     * // Update one Trucks
     * const trucks = await prisma.trucks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrucksUpdateArgs>(args: SelectSubset<T, TrucksUpdateArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trucks.
     * @param {TrucksDeleteManyArgs} args - Arguments to filter Trucks to delete.
     * @example
     * // Delete a few Trucks
     * const { count } = await prisma.trucks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrucksDeleteManyArgs>(args?: SelectSubset<T, TrucksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trucks
     * const trucks = await prisma.trucks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrucksUpdateManyArgs>(args: SelectSubset<T, TrucksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trucks.
     * @param {TrucksUpsertArgs} args - Arguments to update or create a Trucks.
     * @example
     * // Update or create a Trucks
     * const trucks = await prisma.trucks.upsert({
     *   create: {
     *     // ... data to create a Trucks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trucks we want to update
     *   }
     * })
     */
    upsert<T extends TrucksUpsertArgs>(args: SelectSubset<T, TrucksUpsertArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksCountArgs} args - Arguments to filter Trucks to count.
     * @example
     * // Count the number of Trucks
     * const count = await prisma.trucks.count({
     *   where: {
     *     // ... the filter for the Trucks we want to count
     *   }
     * })
    **/
    count<T extends TrucksCountArgs>(
      args?: Subset<T, TrucksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrucksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrucksAggregateArgs>(args: Subset<T, TrucksAggregateArgs>): Prisma.PrismaPromise<GetTrucksAggregateType<T>>

    /**
     * Group by Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrucksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrucksGroupByArgs['orderBy'] }
        : { orderBy?: TrucksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrucksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrucksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trucks model
   */
  readonly fields: TrucksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trucks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrucksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Loads<T extends Trucks$LoadsArgs<ExtArgs> = {}>(args?: Subset<T, Trucks$LoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TrucksDriven<T extends Trucks$TrucksDrivenArgs<ExtArgs> = {}>(args?: Subset<T, Trucks$TrucksDrivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trucks model
   */
  interface TrucksFieldRefs {
    readonly ID: FieldRef<"Trucks", 'Int'>
    readonly Name: FieldRef<"Trucks", 'String'>
    readonly VIN: FieldRef<"Trucks", 'String'>
    readonly Deleted: FieldRef<"Trucks", 'Boolean'>
    readonly Notes: FieldRef<"Trucks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trucks findUnique
   */
  export type TrucksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * Filter, which Trucks to fetch.
     */
    where: TrucksWhereUniqueInput
  }

  /**
   * Trucks findUniqueOrThrow
   */
  export type TrucksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * Filter, which Trucks to fetch.
     */
    where: TrucksWhereUniqueInput
  }

  /**
   * Trucks findFirst
   */
  export type TrucksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * Filter, which Trucks to fetch.
     */
    where?: TrucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TrucksOrderByWithRelationInput | TrucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trucks.
     */
    cursor?: TrucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trucks.
     */
    distinct?: TrucksScalarFieldEnum | TrucksScalarFieldEnum[]
  }

  /**
   * Trucks findFirstOrThrow
   */
  export type TrucksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * Filter, which Trucks to fetch.
     */
    where?: TrucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TrucksOrderByWithRelationInput | TrucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trucks.
     */
    cursor?: TrucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trucks.
     */
    distinct?: TrucksScalarFieldEnum | TrucksScalarFieldEnum[]
  }

  /**
   * Trucks findMany
   */
  export type TrucksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * Filter, which Trucks to fetch.
     */
    where?: TrucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     */
    orderBy?: TrucksOrderByWithRelationInput | TrucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trucks.
     */
    cursor?: TrucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     */
    skip?: number
    distinct?: TrucksScalarFieldEnum | TrucksScalarFieldEnum[]
  }

  /**
   * Trucks create
   */
  export type TrucksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * The data needed to create a Trucks.
     */
    data: XOR<TrucksCreateInput, TrucksUncheckedCreateInput>
  }

  /**
   * Trucks createMany
   */
  export type TrucksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trucks.
     */
    data: TrucksCreateManyInput | TrucksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trucks update
   */
  export type TrucksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * The data needed to update a Trucks.
     */
    data: XOR<TrucksUpdateInput, TrucksUncheckedUpdateInput>
    /**
     * Choose, which Trucks to update.
     */
    where: TrucksWhereUniqueInput
  }

  /**
   * Trucks updateMany
   */
  export type TrucksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trucks.
     */
    data: XOR<TrucksUpdateManyMutationInput, TrucksUncheckedUpdateManyInput>
    /**
     * Filter which Trucks to update
     */
    where?: TrucksWhereInput
    /**
     * Limit how many Trucks to update.
     */
    limit?: number
  }

  /**
   * Trucks upsert
   */
  export type TrucksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * The filter to search for the Trucks to update in case it exists.
     */
    where: TrucksWhereUniqueInput
    /**
     * In case the Trucks found by the `where` argument doesn't exist, create a new Trucks with this data.
     */
    create: XOR<TrucksCreateInput, TrucksUncheckedCreateInput>
    /**
     * In case the Trucks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrucksUpdateInput, TrucksUncheckedUpdateInput>
  }

  /**
   * Trucks delete
   */
  export type TrucksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    /**
     * Filter which Trucks to delete.
     */
    where: TrucksWhereUniqueInput
  }

  /**
   * Trucks deleteMany
   */
  export type TrucksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trucks to delete
     */
    where?: TrucksWhereInput
    /**
     * Limit how many Trucks to delete.
     */
    limit?: number
  }

  /**
   * Trucks.Loads
   */
  export type Trucks$LoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    cursor?: LoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Trucks.TrucksDriven
   */
  export type Trucks$TrucksDrivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    where?: TrucksDrivenWhereInput
    orderBy?: TrucksDrivenOrderByWithRelationInput | TrucksDrivenOrderByWithRelationInput[]
    cursor?: TrucksDrivenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrucksDrivenScalarFieldEnum | TrucksDrivenScalarFieldEnum[]
  }

  /**
   * Trucks without action
   */
  export type TrucksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
  }


  /**
   * Model TrucksDriven
   */

  export type AggregateTrucksDriven = {
    _count: TrucksDrivenCountAggregateOutputType | null
    _avg: TrucksDrivenAvgAggregateOutputType | null
    _sum: TrucksDrivenSumAggregateOutputType | null
    _min: TrucksDrivenMinAggregateOutputType | null
    _max: TrucksDrivenMaxAggregateOutputType | null
  }

  export type TrucksDrivenAvgAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
  }

  export type TrucksDrivenSumAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
  }

  export type TrucksDrivenMinAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
    DateDriven: Date | null
  }

  export type TrucksDrivenMaxAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
    DateDriven: Date | null
  }

  export type TrucksDrivenCountAggregateOutputType = {
    ID: number
    TruckID: number
    DriverID: number
    DateDriven: number
    _all: number
  }


  export type TrucksDrivenAvgAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
  }

  export type TrucksDrivenSumAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
  }

  export type TrucksDrivenMinAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
    DateDriven?: true
  }

  export type TrucksDrivenMaxAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
    DateDriven?: true
  }

  export type TrucksDrivenCountAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
    DateDriven?: true
    _all?: true
  }

  export type TrucksDrivenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrucksDriven to aggregate.
     */
    where?: TrucksDrivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrucksDrivens to fetch.
     */
    orderBy?: TrucksDrivenOrderByWithRelationInput | TrucksDrivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrucksDrivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrucksDrivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrucksDrivens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrucksDrivens
    **/
    _count?: true | TrucksDrivenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrucksDrivenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrucksDrivenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrucksDrivenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrucksDrivenMaxAggregateInputType
  }

  export type GetTrucksDrivenAggregateType<T extends TrucksDrivenAggregateArgs> = {
        [P in keyof T & keyof AggregateTrucksDriven]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrucksDriven[P]>
      : GetScalarType<T[P], AggregateTrucksDriven[P]>
  }




  export type TrucksDrivenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrucksDrivenWhereInput
    orderBy?: TrucksDrivenOrderByWithAggregationInput | TrucksDrivenOrderByWithAggregationInput[]
    by: TrucksDrivenScalarFieldEnum[] | TrucksDrivenScalarFieldEnum
    having?: TrucksDrivenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrucksDrivenCountAggregateInputType | true
    _avg?: TrucksDrivenAvgAggregateInputType
    _sum?: TrucksDrivenSumAggregateInputType
    _min?: TrucksDrivenMinAggregateInputType
    _max?: TrucksDrivenMaxAggregateInputType
  }

  export type TrucksDrivenGroupByOutputType = {
    ID: number
    TruckID: number
    DriverID: number
    DateDriven: Date
    _count: TrucksDrivenCountAggregateOutputType | null
    _avg: TrucksDrivenAvgAggregateOutputType | null
    _sum: TrucksDrivenSumAggregateOutputType | null
    _min: TrucksDrivenMinAggregateOutputType | null
    _max: TrucksDrivenMaxAggregateOutputType | null
  }

  type GetTrucksDrivenGroupByPayload<T extends TrucksDrivenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrucksDrivenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrucksDrivenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrucksDrivenGroupByOutputType[P]>
            : GetScalarType<T[P], TrucksDrivenGroupByOutputType[P]>
        }
      >
    >


  export type TrucksDrivenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    TruckID?: boolean
    DriverID?: boolean
    DateDriven?: boolean
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    Trucks?: boolean | TrucksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trucksDriven"]>



  export type TrucksDrivenSelectScalar = {
    ID?: boolean
    TruckID?: boolean
    DriverID?: boolean
    DateDriven?: boolean
  }

  export type TrucksDrivenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "TruckID" | "DriverID" | "DateDriven", ExtArgs["result"]["trucksDriven"]>
  export type TrucksDrivenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    Trucks?: boolean | TrucksDefaultArgs<ExtArgs>
  }

  export type $TrucksDrivenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrucksDriven"
    objects: {
      Drivers: Prisma.$DriversPayload<ExtArgs>
      Trucks: Prisma.$TrucksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      TruckID: number
      DriverID: number
      /**
       * @zod.custom(z.coerce.date())
       */
      DateDriven: Date
    }, ExtArgs["result"]["trucksDriven"]>
    composites: {}
  }

  type TrucksDrivenGetPayload<S extends boolean | null | undefined | TrucksDrivenDefaultArgs> = $Result.GetResult<Prisma.$TrucksDrivenPayload, S>

  type TrucksDrivenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrucksDrivenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrucksDrivenCountAggregateInputType | true
    }

  export interface TrucksDrivenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrucksDriven'], meta: { name: 'TrucksDriven' } }
    /**
     * Find zero or one TrucksDriven that matches the filter.
     * @param {TrucksDrivenFindUniqueArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrucksDrivenFindUniqueArgs>(args: SelectSubset<T, TrucksDrivenFindUniqueArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrucksDriven that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrucksDrivenFindUniqueOrThrowArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrucksDrivenFindUniqueOrThrowArgs>(args: SelectSubset<T, TrucksDrivenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrucksDriven that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenFindFirstArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrucksDrivenFindFirstArgs>(args?: SelectSubset<T, TrucksDrivenFindFirstArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrucksDriven that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenFindFirstOrThrowArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrucksDrivenFindFirstOrThrowArgs>(args?: SelectSubset<T, TrucksDrivenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrucksDrivens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrucksDrivens
     * const trucksDrivens = await prisma.trucksDriven.findMany()
     * 
     * // Get first 10 TrucksDrivens
     * const trucksDrivens = await prisma.trucksDriven.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const trucksDrivenWithIDOnly = await prisma.trucksDriven.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends TrucksDrivenFindManyArgs>(args?: SelectSubset<T, TrucksDrivenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrucksDriven.
     * @param {TrucksDrivenCreateArgs} args - Arguments to create a TrucksDriven.
     * @example
     * // Create one TrucksDriven
     * const TrucksDriven = await prisma.trucksDriven.create({
     *   data: {
     *     // ... data to create a TrucksDriven
     *   }
     * })
     * 
     */
    create<T extends TrucksDrivenCreateArgs>(args: SelectSubset<T, TrucksDrivenCreateArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrucksDrivens.
     * @param {TrucksDrivenCreateManyArgs} args - Arguments to create many TrucksDrivens.
     * @example
     * // Create many TrucksDrivens
     * const trucksDriven = await prisma.trucksDriven.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrucksDrivenCreateManyArgs>(args?: SelectSubset<T, TrucksDrivenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrucksDriven.
     * @param {TrucksDrivenDeleteArgs} args - Arguments to delete one TrucksDriven.
     * @example
     * // Delete one TrucksDriven
     * const TrucksDriven = await prisma.trucksDriven.delete({
     *   where: {
     *     // ... filter to delete one TrucksDriven
     *   }
     * })
     * 
     */
    delete<T extends TrucksDrivenDeleteArgs>(args: SelectSubset<T, TrucksDrivenDeleteArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrucksDriven.
     * @param {TrucksDrivenUpdateArgs} args - Arguments to update one TrucksDriven.
     * @example
     * // Update one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrucksDrivenUpdateArgs>(args: SelectSubset<T, TrucksDrivenUpdateArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrucksDrivens.
     * @param {TrucksDrivenDeleteManyArgs} args - Arguments to filter TrucksDrivens to delete.
     * @example
     * // Delete a few TrucksDrivens
     * const { count } = await prisma.trucksDriven.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrucksDrivenDeleteManyArgs>(args?: SelectSubset<T, TrucksDrivenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrucksDrivens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrucksDrivens
     * const trucksDriven = await prisma.trucksDriven.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrucksDrivenUpdateManyArgs>(args: SelectSubset<T, TrucksDrivenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrucksDriven.
     * @param {TrucksDrivenUpsertArgs} args - Arguments to update or create a TrucksDriven.
     * @example
     * // Update or create a TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.upsert({
     *   create: {
     *     // ... data to create a TrucksDriven
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrucksDriven we want to update
     *   }
     * })
     */
    upsert<T extends TrucksDrivenUpsertArgs>(args: SelectSubset<T, TrucksDrivenUpsertArgs<ExtArgs>>): Prisma__TrucksDrivenClient<$Result.GetResult<Prisma.$TrucksDrivenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrucksDrivens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenCountArgs} args - Arguments to filter TrucksDrivens to count.
     * @example
     * // Count the number of TrucksDrivens
     * const count = await prisma.trucksDriven.count({
     *   where: {
     *     // ... the filter for the TrucksDrivens we want to count
     *   }
     * })
    **/
    count<T extends TrucksDrivenCountArgs>(
      args?: Subset<T, TrucksDrivenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrucksDrivenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrucksDriven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrucksDrivenAggregateArgs>(args: Subset<T, TrucksDrivenAggregateArgs>): Prisma.PrismaPromise<GetTrucksDrivenAggregateType<T>>

    /**
     * Group by TrucksDriven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrucksDrivenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrucksDrivenGroupByArgs['orderBy'] }
        : { orderBy?: TrucksDrivenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrucksDrivenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrucksDrivenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrucksDriven model
   */
  readonly fields: TrucksDrivenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrucksDriven.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrucksDrivenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Drivers<T extends DriversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriversDefaultArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Trucks<T extends TrucksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrucksDefaultArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrucksDriven model
   */
  interface TrucksDrivenFieldRefs {
    readonly ID: FieldRef<"TrucksDriven", 'Int'>
    readonly TruckID: FieldRef<"TrucksDriven", 'Int'>
    readonly DriverID: FieldRef<"TrucksDriven", 'Int'>
    readonly DateDriven: FieldRef<"TrucksDriven", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrucksDriven findUnique
   */
  export type TrucksDrivenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * Filter, which TrucksDriven to fetch.
     */
    where: TrucksDrivenWhereUniqueInput
  }

  /**
   * TrucksDriven findUniqueOrThrow
   */
  export type TrucksDrivenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * Filter, which TrucksDriven to fetch.
     */
    where: TrucksDrivenWhereUniqueInput
  }

  /**
   * TrucksDriven findFirst
   */
  export type TrucksDrivenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * Filter, which TrucksDriven to fetch.
     */
    where?: TrucksDrivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrucksDrivens to fetch.
     */
    orderBy?: TrucksDrivenOrderByWithRelationInput | TrucksDrivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrucksDrivens.
     */
    cursor?: TrucksDrivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrucksDrivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrucksDrivens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrucksDrivens.
     */
    distinct?: TrucksDrivenScalarFieldEnum | TrucksDrivenScalarFieldEnum[]
  }

  /**
   * TrucksDriven findFirstOrThrow
   */
  export type TrucksDrivenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * Filter, which TrucksDriven to fetch.
     */
    where?: TrucksDrivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrucksDrivens to fetch.
     */
    orderBy?: TrucksDrivenOrderByWithRelationInput | TrucksDrivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrucksDrivens.
     */
    cursor?: TrucksDrivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrucksDrivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrucksDrivens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrucksDrivens.
     */
    distinct?: TrucksDrivenScalarFieldEnum | TrucksDrivenScalarFieldEnum[]
  }

  /**
   * TrucksDriven findMany
   */
  export type TrucksDrivenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * Filter, which TrucksDrivens to fetch.
     */
    where?: TrucksDrivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrucksDrivens to fetch.
     */
    orderBy?: TrucksDrivenOrderByWithRelationInput | TrucksDrivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrucksDrivens.
     */
    cursor?: TrucksDrivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrucksDrivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrucksDrivens.
     */
    skip?: number
    distinct?: TrucksDrivenScalarFieldEnum | TrucksDrivenScalarFieldEnum[]
  }

  /**
   * TrucksDriven create
   */
  export type TrucksDrivenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * The data needed to create a TrucksDriven.
     */
    data: XOR<TrucksDrivenCreateInput, TrucksDrivenUncheckedCreateInput>
  }

  /**
   * TrucksDriven createMany
   */
  export type TrucksDrivenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrucksDrivens.
     */
    data: TrucksDrivenCreateManyInput | TrucksDrivenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrucksDriven update
   */
  export type TrucksDrivenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * The data needed to update a TrucksDriven.
     */
    data: XOR<TrucksDrivenUpdateInput, TrucksDrivenUncheckedUpdateInput>
    /**
     * Choose, which TrucksDriven to update.
     */
    where: TrucksDrivenWhereUniqueInput
  }

  /**
   * TrucksDriven updateMany
   */
  export type TrucksDrivenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrucksDrivens.
     */
    data: XOR<TrucksDrivenUpdateManyMutationInput, TrucksDrivenUncheckedUpdateManyInput>
    /**
     * Filter which TrucksDrivens to update
     */
    where?: TrucksDrivenWhereInput
    /**
     * Limit how many TrucksDrivens to update.
     */
    limit?: number
  }

  /**
   * TrucksDriven upsert
   */
  export type TrucksDrivenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * The filter to search for the TrucksDriven to update in case it exists.
     */
    where: TrucksDrivenWhereUniqueInput
    /**
     * In case the TrucksDriven found by the `where` argument doesn't exist, create a new TrucksDriven with this data.
     */
    create: XOR<TrucksDrivenCreateInput, TrucksDrivenUncheckedCreateInput>
    /**
     * In case the TrucksDriven was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrucksDrivenUpdateInput, TrucksDrivenUncheckedUpdateInput>
  }

  /**
   * TrucksDriven delete
   */
  export type TrucksDrivenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
    /**
     * Filter which TrucksDriven to delete.
     */
    where: TrucksDrivenWhereUniqueInput
  }

  /**
   * TrucksDriven deleteMany
   */
  export type TrucksDrivenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrucksDrivens to delete
     */
    where?: TrucksDrivenWhereInput
    /**
     * Limit how many TrucksDrivens to delete.
     */
    limit?: number
  }

  /**
   * TrucksDriven without action
   */
  export type TrucksDrivenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     */
    select?: TrucksDrivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrucksDriven
     */
    omit?: TrucksDrivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksDrivenInclude<ExtArgs> | null
  }


  /**
   * Model Loads
   */

  export type AggregateLoads = {
    _count: LoadsCountAggregateOutputType | null
    _avg: LoadsAvgAggregateOutputType | null
    _sum: LoadsSumAggregateOutputType | null
    _min: LoadsMinAggregateOutputType | null
    _max: LoadsMaxAggregateOutputType | null
  }

  export type LoadsAvgAggregateOutputType = {
    ID: number | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    TicketNumber: number | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    JobID: number | null
    DriverRate: number | null
  }

  export type LoadsSumAggregateOutputType = {
    ID: number | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    TicketNumber: number | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    JobID: number | null
    DriverRate: number | null
  }

  export type LoadsMinAggregateOutputType = {
    ID: number | null
    StartDate: Date | null
    Created: Date | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    Received: string | null
    Notes: string | null
    TicketNumber: number | null
    Invoiced: boolean | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    Deleted: boolean | null
    JobID: number | null
    Week: string | null
    DriverRate: number | null
  }

  export type LoadsMaxAggregateOutputType = {
    ID: number | null
    StartDate: Date | null
    Created: Date | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    Received: string | null
    Notes: string | null
    TicketNumber: number | null
    Invoiced: boolean | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    Deleted: boolean | null
    JobID: number | null
    Week: string | null
    DriverRate: number | null
  }

  export type LoadsCountAggregateOutputType = {
    ID: number
    StartDate: number
    Created: number
    Weight: number
    Hours: number
    TotalRate: number
    TotalAmount: number
    TruckRate: number
    MaterialRate: number
    Received: number
    Notes: number
    TicketNumber: number
    Invoiced: number
    CustomerID: number
    InvoiceID: number
    LoadTypeID: number
    DeliveryLocationID: number
    TruckID: number
    DriverID: number
    Deleted: number
    JobID: number
    Week: number
    DriverRate: number
    _all: number
  }


  export type LoadsAvgAggregateInputType = {
    ID?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    TicketNumber?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    JobID?: true
    DriverRate?: true
  }

  export type LoadsSumAggregateInputType = {
    ID?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    TicketNumber?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    JobID?: true
    DriverRate?: true
  }

  export type LoadsMinAggregateInputType = {
    ID?: true
    StartDate?: true
    Created?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    Received?: true
    Notes?: true
    TicketNumber?: true
    Invoiced?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    Deleted?: true
    JobID?: true
    Week?: true
    DriverRate?: true
  }

  export type LoadsMaxAggregateInputType = {
    ID?: true
    StartDate?: true
    Created?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    Received?: true
    Notes?: true
    TicketNumber?: true
    Invoiced?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    Deleted?: true
    JobID?: true
    Week?: true
    DriverRate?: true
  }

  export type LoadsCountAggregateInputType = {
    ID?: true
    StartDate?: true
    Created?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    Received?: true
    Notes?: true
    TicketNumber?: true
    Invoiced?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    Deleted?: true
    JobID?: true
    Week?: true
    DriverRate?: true
    _all?: true
  }

  export type LoadsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loads to aggregate.
     */
    where?: LoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loads to fetch.
     */
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loads
    **/
    _count?: true | LoadsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoadsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoadsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoadsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoadsMaxAggregateInputType
  }

  export type GetLoadsAggregateType<T extends LoadsAggregateArgs> = {
        [P in keyof T & keyof AggregateLoads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoads[P]>
      : GetScalarType<T[P], AggregateLoads[P]>
  }




  export type LoadsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithAggregationInput | LoadsOrderByWithAggregationInput[]
    by: LoadsScalarFieldEnum[] | LoadsScalarFieldEnum
    having?: LoadsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoadsCountAggregateInputType | true
    _avg?: LoadsAvgAggregateInputType
    _sum?: LoadsSumAggregateInputType
    _min?: LoadsMinAggregateInputType
    _max?: LoadsMaxAggregateInputType
  }

  export type LoadsGroupByOutputType = {
    ID: number
    StartDate: Date
    Created: Date
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    Received: string | null
    Notes: string | null
    TicketNumber: number
    Invoiced: boolean | null
    CustomerID: number
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    Deleted: boolean | null
    JobID: number | null
    Week: string
    DriverRate: number | null
    _count: LoadsCountAggregateOutputType | null
    _avg: LoadsAvgAggregateOutputType | null
    _sum: LoadsSumAggregateOutputType | null
    _min: LoadsMinAggregateOutputType | null
    _max: LoadsMaxAggregateOutputType | null
  }

  type GetLoadsGroupByPayload<T extends LoadsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoadsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoadsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoadsGroupByOutputType[P]>
            : GetScalarType<T[P], LoadsGroupByOutputType[P]>
        }
      >
    >


  export type LoadsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    StartDate?: boolean
    Created?: boolean
    Weight?: boolean
    Hours?: boolean
    TotalRate?: boolean
    TotalAmount?: boolean
    TruckRate?: boolean
    MaterialRate?: boolean
    Received?: boolean
    Notes?: boolean
    TicketNumber?: boolean
    Invoiced?: boolean
    CustomerID?: boolean
    InvoiceID?: boolean
    LoadTypeID?: boolean
    DeliveryLocationID?: boolean
    TruckID?: boolean
    DriverID?: boolean
    Deleted?: boolean
    JobID?: boolean
    Week?: boolean
    DriverRate?: boolean
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | Loads$DeliveryLocationsArgs<ExtArgs>
    Drivers?: boolean | Loads$DriversArgs<ExtArgs>
    Invoices?: boolean | Loads$InvoicesArgs<ExtArgs>
    Jobs?: boolean | Loads$JobsArgs<ExtArgs>
    LoadTypes?: boolean | Loads$LoadTypesArgs<ExtArgs>
    Trucks?: boolean | Loads$TrucksArgs<ExtArgs>
  }, ExtArgs["result"]["loads"]>



  export type LoadsSelectScalar = {
    ID?: boolean
    StartDate?: boolean
    Created?: boolean
    Weight?: boolean
    Hours?: boolean
    TotalRate?: boolean
    TotalAmount?: boolean
    TruckRate?: boolean
    MaterialRate?: boolean
    Received?: boolean
    Notes?: boolean
    TicketNumber?: boolean
    Invoiced?: boolean
    CustomerID?: boolean
    InvoiceID?: boolean
    LoadTypeID?: boolean
    DeliveryLocationID?: boolean
    TruckID?: boolean
    DriverID?: boolean
    Deleted?: boolean
    JobID?: boolean
    Week?: boolean
    DriverRate?: boolean
  }

  export type LoadsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "StartDate" | "Created" | "Weight" | "Hours" | "TotalRate" | "TotalAmount" | "TruckRate" | "MaterialRate" | "Received" | "Notes" | "TicketNumber" | "Invoiced" | "CustomerID" | "InvoiceID" | "LoadTypeID" | "DeliveryLocationID" | "TruckID" | "DriverID" | "Deleted" | "JobID" | "Week" | "DriverRate", ExtArgs["result"]["loads"]>
  export type LoadsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | Loads$DeliveryLocationsArgs<ExtArgs>
    Drivers?: boolean | Loads$DriversArgs<ExtArgs>
    Invoices?: boolean | Loads$InvoicesArgs<ExtArgs>
    Jobs?: boolean | Loads$JobsArgs<ExtArgs>
    LoadTypes?: boolean | Loads$LoadTypesArgs<ExtArgs>
    Trucks?: boolean | Loads$TrucksArgs<ExtArgs>
  }

  export type $LoadsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loads"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>
      DeliveryLocations: Prisma.$DeliveryLocationsPayload<ExtArgs> | null
      Drivers: Prisma.$DriversPayload<ExtArgs> | null
      Invoices: Prisma.$InvoicesPayload<ExtArgs> | null
      Jobs: Prisma.$JobsPayload<ExtArgs> | null
      LoadTypes: Prisma.$LoadTypesPayload<ExtArgs> | null
      Trucks: Prisma.$TrucksPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      /**
       * @zod.custom(z.coerce.date())
       */
      StartDate: Date
      /**
       * @zod.custom(z.coerce.date())
       */
      Created: Date
      /**
       * @zod.custom(z.coerce.number())
       */
      Weight: number | null
      /**
       * @zod.custom(z.coerce.number())
       */
      Hours: number | null
      /**
       * @zod.custom(z.coerce.number())
       */
      TotalRate: number | null
      /**
       * @zod.custom(z.coerce.number())
       */
      TotalAmount: number | null
      /**
       * @zod.custom(z.coerce.number())
       */
      TruckRate: number | null
      /**
       * @zod.custom(z.coerce.number())
       */
      MaterialRate: number | null
      Received: string | null
      Notes: string | null
      TicketNumber: number
      Invoiced: boolean | null
      /**
       * @zod.min(1)
       */
      CustomerID: number
      /**
       * @zod.min(1)
       */
      InvoiceID: number | null
      /**
       * @zod.min(1)
       */
      LoadTypeID: number | null
      DeliveryLocationID: number | null
      TruckID: number | null
      DriverID: number | null
      Deleted: boolean | null
      JobID: number | null
      Week: string
      DriverRate: number | null
    }, ExtArgs["result"]["loads"]>
    composites: {}
  }

  type LoadsGetPayload<S extends boolean | null | undefined | LoadsDefaultArgs> = $Result.GetResult<Prisma.$LoadsPayload, S>

  type LoadsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoadsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoadsCountAggregateInputType | true
    }

  export interface LoadsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loads'], meta: { name: 'Loads' } }
    /**
     * Find zero or one Loads that matches the filter.
     * @param {LoadsFindUniqueArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoadsFindUniqueArgs>(args: SelectSubset<T, LoadsFindUniqueArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loads that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoadsFindUniqueOrThrowArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoadsFindUniqueOrThrowArgs>(args: SelectSubset<T, LoadsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsFindFirstArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoadsFindFirstArgs>(args?: SelectSubset<T, LoadsFindFirstArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsFindFirstOrThrowArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoadsFindFirstOrThrowArgs>(args?: SelectSubset<T, LoadsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loads
     * const loads = await prisma.loads.findMany()
     * 
     * // Get first 10 Loads
     * const loads = await prisma.loads.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const loadsWithIDOnly = await prisma.loads.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends LoadsFindManyArgs>(args?: SelectSubset<T, LoadsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loads.
     * @param {LoadsCreateArgs} args - Arguments to create a Loads.
     * @example
     * // Create one Loads
     * const Loads = await prisma.loads.create({
     *   data: {
     *     // ... data to create a Loads
     *   }
     * })
     * 
     */
    create<T extends LoadsCreateArgs>(args: SelectSubset<T, LoadsCreateArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loads.
     * @param {LoadsCreateManyArgs} args - Arguments to create many Loads.
     * @example
     * // Create many Loads
     * const loads = await prisma.loads.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoadsCreateManyArgs>(args?: SelectSubset<T, LoadsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Loads.
     * @param {LoadsDeleteArgs} args - Arguments to delete one Loads.
     * @example
     * // Delete one Loads
     * const Loads = await prisma.loads.delete({
     *   where: {
     *     // ... filter to delete one Loads
     *   }
     * })
     * 
     */
    delete<T extends LoadsDeleteArgs>(args: SelectSubset<T, LoadsDeleteArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loads.
     * @param {LoadsUpdateArgs} args - Arguments to update one Loads.
     * @example
     * // Update one Loads
     * const loads = await prisma.loads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoadsUpdateArgs>(args: SelectSubset<T, LoadsUpdateArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loads.
     * @param {LoadsDeleteManyArgs} args - Arguments to filter Loads to delete.
     * @example
     * // Delete a few Loads
     * const { count } = await prisma.loads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoadsDeleteManyArgs>(args?: SelectSubset<T, LoadsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loads
     * const loads = await prisma.loads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoadsUpdateManyArgs>(args: SelectSubset<T, LoadsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loads.
     * @param {LoadsUpsertArgs} args - Arguments to update or create a Loads.
     * @example
     * // Update or create a Loads
     * const loads = await prisma.loads.upsert({
     *   create: {
     *     // ... data to create a Loads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loads we want to update
     *   }
     * })
     */
    upsert<T extends LoadsUpsertArgs>(args: SelectSubset<T, LoadsUpsertArgs<ExtArgs>>): Prisma__LoadsClient<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsCountArgs} args - Arguments to filter Loads to count.
     * @example
     * // Count the number of Loads
     * const count = await prisma.loads.count({
     *   where: {
     *     // ... the filter for the Loads we want to count
     *   }
     * })
    **/
    count<T extends LoadsCountArgs>(
      args?: Subset<T, LoadsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoadsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoadsAggregateArgs>(args: Subset<T, LoadsAggregateArgs>): Prisma.PrismaPromise<GetLoadsAggregateType<T>>

    /**
     * Group by Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoadsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoadsGroupByArgs['orderBy'] }
        : { orderBy?: LoadsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoadsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoadsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loads model
   */
  readonly fields: LoadsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoadsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeliveryLocations<T extends Loads$DeliveryLocationsArgs<ExtArgs> = {}>(args?: Subset<T, Loads$DeliveryLocationsArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Drivers<T extends Loads$DriversArgs<ExtArgs> = {}>(args?: Subset<T, Loads$DriversArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Invoices<T extends Loads$InvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Loads$InvoicesArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Jobs<T extends Loads$JobsArgs<ExtArgs> = {}>(args?: Subset<T, Loads$JobsArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    LoadTypes<T extends Loads$LoadTypesArgs<ExtArgs> = {}>(args?: Subset<T, Loads$LoadTypesArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Trucks<T extends Loads$TrucksArgs<ExtArgs> = {}>(args?: Subset<T, Loads$TrucksArgs<ExtArgs>>): Prisma__TrucksClient<$Result.GetResult<Prisma.$TrucksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loads model
   */
  interface LoadsFieldRefs {
    readonly ID: FieldRef<"Loads", 'Int'>
    readonly StartDate: FieldRef<"Loads", 'DateTime'>
    readonly Created: FieldRef<"Loads", 'DateTime'>
    readonly Weight: FieldRef<"Loads", 'Float'>
    readonly Hours: FieldRef<"Loads", 'Float'>
    readonly TotalRate: FieldRef<"Loads", 'Float'>
    readonly TotalAmount: FieldRef<"Loads", 'Float'>
    readonly TruckRate: FieldRef<"Loads", 'Float'>
    readonly MaterialRate: FieldRef<"Loads", 'Float'>
    readonly Received: FieldRef<"Loads", 'String'>
    readonly Notes: FieldRef<"Loads", 'String'>
    readonly TicketNumber: FieldRef<"Loads", 'Int'>
    readonly Invoiced: FieldRef<"Loads", 'Boolean'>
    readonly CustomerID: FieldRef<"Loads", 'Int'>
    readonly InvoiceID: FieldRef<"Loads", 'Int'>
    readonly LoadTypeID: FieldRef<"Loads", 'Int'>
    readonly DeliveryLocationID: FieldRef<"Loads", 'Int'>
    readonly TruckID: FieldRef<"Loads", 'Int'>
    readonly DriverID: FieldRef<"Loads", 'Int'>
    readonly Deleted: FieldRef<"Loads", 'Boolean'>
    readonly JobID: FieldRef<"Loads", 'Int'>
    readonly Week: FieldRef<"Loads", 'String'>
    readonly DriverRate: FieldRef<"Loads", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Loads findUnique
   */
  export type LoadsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * Filter, which Loads to fetch.
     */
    where: LoadsWhereUniqueInput
  }

  /**
   * Loads findUniqueOrThrow
   */
  export type LoadsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * Filter, which Loads to fetch.
     */
    where: LoadsWhereUniqueInput
  }

  /**
   * Loads findFirst
   */
  export type LoadsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * Filter, which Loads to fetch.
     */
    where?: LoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loads to fetch.
     */
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loads.
     */
    cursor?: LoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loads.
     */
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Loads findFirstOrThrow
   */
  export type LoadsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * Filter, which Loads to fetch.
     */
    where?: LoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loads to fetch.
     */
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loads.
     */
    cursor?: LoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loads.
     */
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Loads findMany
   */
  export type LoadsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * Filter, which Loads to fetch.
     */
    where?: LoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loads to fetch.
     */
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loads.
     */
    cursor?: LoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loads.
     */
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Loads create
   */
  export type LoadsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * The data needed to create a Loads.
     */
    data: XOR<LoadsCreateInput, LoadsUncheckedCreateInput>
  }

  /**
   * Loads createMany
   */
  export type LoadsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loads.
     */
    data: LoadsCreateManyInput | LoadsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loads update
   */
  export type LoadsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * The data needed to update a Loads.
     */
    data: XOR<LoadsUpdateInput, LoadsUncheckedUpdateInput>
    /**
     * Choose, which Loads to update.
     */
    where: LoadsWhereUniqueInput
  }

  /**
   * Loads updateMany
   */
  export type LoadsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loads.
     */
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyInput>
    /**
     * Filter which Loads to update
     */
    where?: LoadsWhereInput
    /**
     * Limit how many Loads to update.
     */
    limit?: number
  }

  /**
   * Loads upsert
   */
  export type LoadsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * The filter to search for the Loads to update in case it exists.
     */
    where: LoadsWhereUniqueInput
    /**
     * In case the Loads found by the `where` argument doesn't exist, create a new Loads with this data.
     */
    create: XOR<LoadsCreateInput, LoadsUncheckedCreateInput>
    /**
     * In case the Loads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoadsUpdateInput, LoadsUncheckedUpdateInput>
  }

  /**
   * Loads delete
   */
  export type LoadsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    /**
     * Filter which Loads to delete.
     */
    where: LoadsWhereUniqueInput
  }

  /**
   * Loads deleteMany
   */
  export type LoadsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loads to delete
     */
    where?: LoadsWhereInput
    /**
     * Limit how many Loads to delete.
     */
    limit?: number
  }

  /**
   * Loads.DeliveryLocations
   */
  export type Loads$DeliveryLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     */
    select?: DeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLocations
     */
    omit?: DeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLocationsInclude<ExtArgs> | null
    where?: DeliveryLocationsWhereInput
  }

  /**
   * Loads.Drivers
   */
  export type Loads$DriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drivers
     */
    select?: DriversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drivers
     */
    omit?: DriversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriversInclude<ExtArgs> | null
    where?: DriversWhereInput
  }

  /**
   * Loads.Invoices
   */
  export type Loads$InvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    where?: InvoicesWhereInput
  }

  /**
   * Loads.Jobs
   */
  export type Loads$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
  }

  /**
   * Loads.LoadTypes
   */
  export type Loads$LoadTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoadTypes
     */
    select?: LoadTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoadTypes
     */
    omit?: LoadTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadTypesInclude<ExtArgs> | null
    where?: LoadTypesWhereInput
  }

  /**
   * Loads.Trucks
   */
  export type Loads$TrucksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trucks
     */
    select?: TrucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trucks
     */
    omit?: TrucksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrucksInclude<ExtArgs> | null
    where?: TrucksWhereInput
  }

  /**
   * Loads without action
   */
  export type LoadsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
  }


  /**
   * Model CustomerDeliveryLocations
   */

  export type AggregateCustomerDeliveryLocations = {
    _count: CustomerDeliveryLocationsCountAggregateOutputType | null
    _avg: CustomerDeliveryLocationsAvgAggregateOutputType | null
    _sum: CustomerDeliveryLocationsSumAggregateOutputType | null
    _min: CustomerDeliveryLocationsMinAggregateOutputType | null
    _max: CustomerDeliveryLocationsMaxAggregateOutputType | null
  }

  export type CustomerDeliveryLocationsAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
  }

  export type CustomerDeliveryLocationsSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
  }

  export type CustomerDeliveryLocationsMinAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
    DateUsed: Date | null
  }

  export type CustomerDeliveryLocationsMaxAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
    DateUsed: Date | null
  }

  export type CustomerDeliveryLocationsCountAggregateOutputType = {
    ID: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: number
    _all: number
  }


  export type CustomerDeliveryLocationsAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
  }

  export type CustomerDeliveryLocationsSumAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
  }

  export type CustomerDeliveryLocationsMinAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
    DateUsed?: true
  }

  export type CustomerDeliveryLocationsMaxAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
    DateUsed?: true
  }

  export type CustomerDeliveryLocationsCountAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
    DateUsed?: true
    _all?: true
  }

  export type CustomerDeliveryLocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDeliveryLocations to aggregate.
     */
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDeliveryLocations to fetch.
     */
    orderBy?: CustomerDeliveryLocationsOrderByWithRelationInput | CustomerDeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDeliveryLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerDeliveryLocations
    **/
    _count?: true | CustomerDeliveryLocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerDeliveryLocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerDeliveryLocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerDeliveryLocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerDeliveryLocationsMaxAggregateInputType
  }

  export type GetCustomerDeliveryLocationsAggregateType<T extends CustomerDeliveryLocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerDeliveryLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerDeliveryLocations[P]>
      : GetScalarType<T[P], AggregateCustomerDeliveryLocations[P]>
  }




  export type CustomerDeliveryLocationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDeliveryLocationsWhereInput
    orderBy?: CustomerDeliveryLocationsOrderByWithAggregationInput | CustomerDeliveryLocationsOrderByWithAggregationInput[]
    by: CustomerDeliveryLocationsScalarFieldEnum[] | CustomerDeliveryLocationsScalarFieldEnum
    having?: CustomerDeliveryLocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerDeliveryLocationsCountAggregateInputType | true
    _avg?: CustomerDeliveryLocationsAvgAggregateInputType
    _sum?: CustomerDeliveryLocationsSumAggregateInputType
    _min?: CustomerDeliveryLocationsMinAggregateInputType
    _max?: CustomerDeliveryLocationsMaxAggregateInputType
  }

  export type CustomerDeliveryLocationsGroupByOutputType = {
    ID: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: Date
    _count: CustomerDeliveryLocationsCountAggregateOutputType | null
    _avg: CustomerDeliveryLocationsAvgAggregateOutputType | null
    _sum: CustomerDeliveryLocationsSumAggregateOutputType | null
    _min: CustomerDeliveryLocationsMinAggregateOutputType | null
    _max: CustomerDeliveryLocationsMaxAggregateOutputType | null
  }

  type GetCustomerDeliveryLocationsGroupByPayload<T extends CustomerDeliveryLocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerDeliveryLocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerDeliveryLocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerDeliveryLocationsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerDeliveryLocationsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerDeliveryLocationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CustomerID?: boolean
    DeliveryLocationID?: boolean
    DateUsed?: boolean
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | DeliveryLocationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDeliveryLocations"]>



  export type CustomerDeliveryLocationsSelectScalar = {
    ID?: boolean
    CustomerID?: boolean
    DeliveryLocationID?: boolean
    DateUsed?: boolean
  }

  export type CustomerDeliveryLocationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "CustomerID" | "DeliveryLocationID" | "DateUsed", ExtArgs["result"]["customerDeliveryLocations"]>
  export type CustomerDeliveryLocationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | DeliveryLocationsDefaultArgs<ExtArgs>
  }

  export type $CustomerDeliveryLocationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerDeliveryLocations"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>
      DeliveryLocations: Prisma.$DeliveryLocationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      CustomerID: number
      DeliveryLocationID: number
      /**
       * @zod.custom(z.coerce.date())
       */
      DateUsed: Date
    }, ExtArgs["result"]["customerDeliveryLocations"]>
    composites: {}
  }

  type CustomerDeliveryLocationsGetPayload<S extends boolean | null | undefined | CustomerDeliveryLocationsDefaultArgs> = $Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload, S>

  type CustomerDeliveryLocationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerDeliveryLocationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerDeliveryLocationsCountAggregateInputType | true
    }

  export interface CustomerDeliveryLocationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerDeliveryLocations'], meta: { name: 'CustomerDeliveryLocations' } }
    /**
     * Find zero or one CustomerDeliveryLocations that matches the filter.
     * @param {CustomerDeliveryLocationsFindUniqueArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerDeliveryLocationsFindUniqueArgs>(args: SelectSubset<T, CustomerDeliveryLocationsFindUniqueArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerDeliveryLocations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerDeliveryLocationsFindUniqueOrThrowArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerDeliveryLocationsFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerDeliveryLocationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsFindFirstArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerDeliveryLocationsFindFirstArgs>(args?: SelectSubset<T, CustomerDeliveryLocationsFindFirstArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDeliveryLocations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsFindFirstOrThrowArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerDeliveryLocationsFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerDeliveryLocationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerDeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findMany()
     * 
     * // Get first 10 CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const customerDeliveryLocationsWithIDOnly = await prisma.customerDeliveryLocations.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends CustomerDeliveryLocationsFindManyArgs>(args?: SelectSubset<T, CustomerDeliveryLocationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsCreateArgs} args - Arguments to create a CustomerDeliveryLocations.
     * @example
     * // Create one CustomerDeliveryLocations
     * const CustomerDeliveryLocations = await prisma.customerDeliveryLocations.create({
     *   data: {
     *     // ... data to create a CustomerDeliveryLocations
     *   }
     * })
     * 
     */
    create<T extends CustomerDeliveryLocationsCreateArgs>(args: SelectSubset<T, CustomerDeliveryLocationsCreateArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsCreateManyArgs} args - Arguments to create many CustomerDeliveryLocations.
     * @example
     * // Create many CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerDeliveryLocationsCreateManyArgs>(args?: SelectSubset<T, CustomerDeliveryLocationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsDeleteArgs} args - Arguments to delete one CustomerDeliveryLocations.
     * @example
     * // Delete one CustomerDeliveryLocations
     * const CustomerDeliveryLocations = await prisma.customerDeliveryLocations.delete({
     *   where: {
     *     // ... filter to delete one CustomerDeliveryLocations
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeliveryLocationsDeleteArgs>(args: SelectSubset<T, CustomerDeliveryLocationsDeleteArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsUpdateArgs} args - Arguments to update one CustomerDeliveryLocations.
     * @example
     * // Update one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerDeliveryLocationsUpdateArgs>(args: SelectSubset<T, CustomerDeliveryLocationsUpdateArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsDeleteManyArgs} args - Arguments to filter CustomerDeliveryLocations to delete.
     * @example
     * // Delete a few CustomerDeliveryLocations
     * const { count } = await prisma.customerDeliveryLocations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeliveryLocationsDeleteManyArgs>(args?: SelectSubset<T, CustomerDeliveryLocationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerDeliveryLocationsUpdateManyArgs>(args: SelectSubset<T, CustomerDeliveryLocationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsUpsertArgs} args - Arguments to update or create a CustomerDeliveryLocations.
     * @example
     * // Update or create a CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.upsert({
     *   create: {
     *     // ... data to create a CustomerDeliveryLocations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerDeliveryLocations we want to update
     *   }
     * })
     */
    upsert<T extends CustomerDeliveryLocationsUpsertArgs>(args: SelectSubset<T, CustomerDeliveryLocationsUpsertArgs<ExtArgs>>): Prisma__CustomerDeliveryLocationsClient<$Result.GetResult<Prisma.$CustomerDeliveryLocationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsCountArgs} args - Arguments to filter CustomerDeliveryLocations to count.
     * @example
     * // Count the number of CustomerDeliveryLocations
     * const count = await prisma.customerDeliveryLocations.count({
     *   where: {
     *     // ... the filter for the CustomerDeliveryLocations we want to count
     *   }
     * })
    **/
    count<T extends CustomerDeliveryLocationsCountArgs>(
      args?: Subset<T, CustomerDeliveryLocationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerDeliveryLocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerDeliveryLocationsAggregateArgs>(args: Subset<T, CustomerDeliveryLocationsAggregateArgs>): Prisma.PrismaPromise<GetCustomerDeliveryLocationsAggregateType<T>>

    /**
     * Group by CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerDeliveryLocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerDeliveryLocationsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerDeliveryLocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerDeliveryLocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerDeliveryLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerDeliveryLocations model
   */
  readonly fields: CustomerDeliveryLocationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerDeliveryLocations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerDeliveryLocationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeliveryLocations<T extends DeliveryLocationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocationsDefaultArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerDeliveryLocations model
   */
  interface CustomerDeliveryLocationsFieldRefs {
    readonly ID: FieldRef<"CustomerDeliveryLocations", 'Int'>
    readonly CustomerID: FieldRef<"CustomerDeliveryLocations", 'Int'>
    readonly DeliveryLocationID: FieldRef<"CustomerDeliveryLocations", 'Int'>
    readonly DateUsed: FieldRef<"CustomerDeliveryLocations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerDeliveryLocations findUnique
   */
  export type CustomerDeliveryLocationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     */
    where: CustomerDeliveryLocationsWhereUniqueInput
  }

  /**
   * CustomerDeliveryLocations findUniqueOrThrow
   */
  export type CustomerDeliveryLocationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     */
    where: CustomerDeliveryLocationsWhereUniqueInput
  }

  /**
   * CustomerDeliveryLocations findFirst
   */
  export type CustomerDeliveryLocationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     */
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDeliveryLocations to fetch.
     */
    orderBy?: CustomerDeliveryLocationsOrderByWithRelationInput | CustomerDeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDeliveryLocations.
     */
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDeliveryLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDeliveryLocations.
     */
    distinct?: CustomerDeliveryLocationsScalarFieldEnum | CustomerDeliveryLocationsScalarFieldEnum[]
  }

  /**
   * CustomerDeliveryLocations findFirstOrThrow
   */
  export type CustomerDeliveryLocationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     */
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDeliveryLocations to fetch.
     */
    orderBy?: CustomerDeliveryLocationsOrderByWithRelationInput | CustomerDeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDeliveryLocations.
     */
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDeliveryLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDeliveryLocations.
     */
    distinct?: CustomerDeliveryLocationsScalarFieldEnum | CustomerDeliveryLocationsScalarFieldEnum[]
  }

  /**
   * CustomerDeliveryLocations findMany
   */
  export type CustomerDeliveryLocationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     */
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDeliveryLocations to fetch.
     */
    orderBy?: CustomerDeliveryLocationsOrderByWithRelationInput | CustomerDeliveryLocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerDeliveryLocations.
     */
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDeliveryLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDeliveryLocations.
     */
    skip?: number
    distinct?: CustomerDeliveryLocationsScalarFieldEnum | CustomerDeliveryLocationsScalarFieldEnum[]
  }

  /**
   * CustomerDeliveryLocations create
   */
  export type CustomerDeliveryLocationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerDeliveryLocations.
     */
    data: XOR<CustomerDeliveryLocationsCreateInput, CustomerDeliveryLocationsUncheckedCreateInput>
  }

  /**
   * CustomerDeliveryLocations createMany
   */
  export type CustomerDeliveryLocationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerDeliveryLocations.
     */
    data: CustomerDeliveryLocationsCreateManyInput | CustomerDeliveryLocationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerDeliveryLocations update
   */
  export type CustomerDeliveryLocationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerDeliveryLocations.
     */
    data: XOR<CustomerDeliveryLocationsUpdateInput, CustomerDeliveryLocationsUncheckedUpdateInput>
    /**
     * Choose, which CustomerDeliveryLocations to update.
     */
    where: CustomerDeliveryLocationsWhereUniqueInput
  }

  /**
   * CustomerDeliveryLocations updateMany
   */
  export type CustomerDeliveryLocationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerDeliveryLocations.
     */
    data: XOR<CustomerDeliveryLocationsUpdateManyMutationInput, CustomerDeliveryLocationsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDeliveryLocations to update
     */
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * Limit how many CustomerDeliveryLocations to update.
     */
    limit?: number
  }

  /**
   * CustomerDeliveryLocations upsert
   */
  export type CustomerDeliveryLocationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerDeliveryLocations to update in case it exists.
     */
    where: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * In case the CustomerDeliveryLocations found by the `where` argument doesn't exist, create a new CustomerDeliveryLocations with this data.
     */
    create: XOR<CustomerDeliveryLocationsCreateInput, CustomerDeliveryLocationsUncheckedCreateInput>
    /**
     * In case the CustomerDeliveryLocations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerDeliveryLocationsUpdateInput, CustomerDeliveryLocationsUncheckedUpdateInput>
  }

  /**
   * CustomerDeliveryLocations delete
   */
  export type CustomerDeliveryLocationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
    /**
     * Filter which CustomerDeliveryLocations to delete.
     */
    where: CustomerDeliveryLocationsWhereUniqueInput
  }

  /**
   * CustomerDeliveryLocations deleteMany
   */
  export type CustomerDeliveryLocationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDeliveryLocations to delete
     */
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * Limit how many CustomerDeliveryLocations to delete.
     */
    limit?: number
  }

  /**
   * CustomerDeliveryLocations without action
   */
  export type CustomerDeliveryLocationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     */
    select?: CustomerDeliveryLocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDeliveryLocations
     */
    omit?: CustomerDeliveryLocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeliveryLocationsInclude<ExtArgs> | null
  }


  /**
   * Model Dailies
   */

  export type AggregateDailies = {
    _count: DailiesCountAggregateOutputType | null
    _avg: DailiesAvgAggregateOutputType | null
    _sum: DailiesSumAggregateOutputType | null
    _min: DailiesMinAggregateOutputType | null
    _max: DailiesMaxAggregateOutputType | null
  }

  export type DailiesAvgAggregateOutputType = {
    ID: number | null
    DriverID: number | null
  }

  export type DailiesSumAggregateOutputType = {
    ID: number | null
    DriverID: number | null
  }

  export type DailiesMinAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Week: string | null
    LastPrinted: Date | null
  }

  export type DailiesMaxAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Week: string | null
    LastPrinted: Date | null
  }

  export type DailiesCountAggregateOutputType = {
    ID: number
    DriverID: number
    Week: number
    LastPrinted: number
    _all: number
  }


  export type DailiesAvgAggregateInputType = {
    ID?: true
    DriverID?: true
  }

  export type DailiesSumAggregateInputType = {
    ID?: true
    DriverID?: true
  }

  export type DailiesMinAggregateInputType = {
    ID?: true
    DriverID?: true
    Week?: true
    LastPrinted?: true
  }

  export type DailiesMaxAggregateInputType = {
    ID?: true
    DriverID?: true
    Week?: true
    LastPrinted?: true
  }

  export type DailiesCountAggregateInputType = {
    ID?: true
    DriverID?: true
    Week?: true
    LastPrinted?: true
    _all?: true
  }

  export type DailiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dailies to aggregate.
     */
    where?: DailiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dailies to fetch.
     */
    orderBy?: DailiesOrderByWithRelationInput | DailiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dailies
    **/
    _count?: true | DailiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailiesMaxAggregateInputType
  }

  export type GetDailiesAggregateType<T extends DailiesAggregateArgs> = {
        [P in keyof T & keyof AggregateDailies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailies[P]>
      : GetScalarType<T[P], AggregateDailies[P]>
  }




  export type DailiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailiesWhereInput
    orderBy?: DailiesOrderByWithAggregationInput | DailiesOrderByWithAggregationInput[]
    by: DailiesScalarFieldEnum[] | DailiesScalarFieldEnum
    having?: DailiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailiesCountAggregateInputType | true
    _avg?: DailiesAvgAggregateInputType
    _sum?: DailiesSumAggregateInputType
    _min?: DailiesMinAggregateInputType
    _max?: DailiesMaxAggregateInputType
  }

  export type DailiesGroupByOutputType = {
    ID: number
    DriverID: number
    Week: string
    LastPrinted: Date | null
    _count: DailiesCountAggregateOutputType | null
    _avg: DailiesAvgAggregateOutputType | null
    _sum: DailiesSumAggregateOutputType | null
    _min: DailiesMinAggregateOutputType | null
    _max: DailiesMaxAggregateOutputType | null
  }

  type GetDailiesGroupByPayload<T extends DailiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailiesGroupByOutputType[P]>
            : GetScalarType<T[P], DailiesGroupByOutputType[P]>
        }
      >
    >


  export type DailiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    DriverID?: boolean
    Week?: boolean
    LastPrinted?: boolean
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    Jobs?: boolean | Dailies$JobsArgs<ExtArgs>
    _count?: boolean | DailiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailies"]>



  export type DailiesSelectScalar = {
    ID?: boolean
    DriverID?: boolean
    Week?: boolean
    LastPrinted?: boolean
  }

  export type DailiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "DriverID" | "Week" | "LastPrinted", ExtArgs["result"]["dailies"]>
  export type DailiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    Jobs?: boolean | Dailies$JobsArgs<ExtArgs>
    _count?: boolean | DailiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DailiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dailies"
    objects: {
      Drivers: Prisma.$DriversPayload<ExtArgs>
      Jobs: Prisma.$JobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      DriverID: number
      Week: string
      LastPrinted: Date | null
    }, ExtArgs["result"]["dailies"]>
    composites: {}
  }

  type DailiesGetPayload<S extends boolean | null | undefined | DailiesDefaultArgs> = $Result.GetResult<Prisma.$DailiesPayload, S>

  type DailiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailiesCountAggregateInputType | true
    }

  export interface DailiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dailies'], meta: { name: 'Dailies' } }
    /**
     * Find zero or one Dailies that matches the filter.
     * @param {DailiesFindUniqueArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailiesFindUniqueArgs>(args: SelectSubset<T, DailiesFindUniqueArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dailies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailiesFindUniqueOrThrowArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailiesFindUniqueOrThrowArgs>(args: SelectSubset<T, DailiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesFindFirstArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailiesFindFirstArgs>(args?: SelectSubset<T, DailiesFindFirstArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dailies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesFindFirstOrThrowArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailiesFindFirstOrThrowArgs>(args?: SelectSubset<T, DailiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dailies
     * const dailies = await prisma.dailies.findMany()
     * 
     * // Get first 10 Dailies
     * const dailies = await prisma.dailies.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const dailiesWithIDOnly = await prisma.dailies.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends DailiesFindManyArgs>(args?: SelectSubset<T, DailiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dailies.
     * @param {DailiesCreateArgs} args - Arguments to create a Dailies.
     * @example
     * // Create one Dailies
     * const Dailies = await prisma.dailies.create({
     *   data: {
     *     // ... data to create a Dailies
     *   }
     * })
     * 
     */
    create<T extends DailiesCreateArgs>(args: SelectSubset<T, DailiesCreateArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dailies.
     * @param {DailiesCreateManyArgs} args - Arguments to create many Dailies.
     * @example
     * // Create many Dailies
     * const dailies = await prisma.dailies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailiesCreateManyArgs>(args?: SelectSubset<T, DailiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dailies.
     * @param {DailiesDeleteArgs} args - Arguments to delete one Dailies.
     * @example
     * // Delete one Dailies
     * const Dailies = await prisma.dailies.delete({
     *   where: {
     *     // ... filter to delete one Dailies
     *   }
     * })
     * 
     */
    delete<T extends DailiesDeleteArgs>(args: SelectSubset<T, DailiesDeleteArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dailies.
     * @param {DailiesUpdateArgs} args - Arguments to update one Dailies.
     * @example
     * // Update one Dailies
     * const dailies = await prisma.dailies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailiesUpdateArgs>(args: SelectSubset<T, DailiesUpdateArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dailies.
     * @param {DailiesDeleteManyArgs} args - Arguments to filter Dailies to delete.
     * @example
     * // Delete a few Dailies
     * const { count } = await prisma.dailies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailiesDeleteManyArgs>(args?: SelectSubset<T, DailiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dailies
     * const dailies = await prisma.dailies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailiesUpdateManyArgs>(args: SelectSubset<T, DailiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dailies.
     * @param {DailiesUpsertArgs} args - Arguments to update or create a Dailies.
     * @example
     * // Update or create a Dailies
     * const dailies = await prisma.dailies.upsert({
     *   create: {
     *     // ... data to create a Dailies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dailies we want to update
     *   }
     * })
     */
    upsert<T extends DailiesUpsertArgs>(args: SelectSubset<T, DailiesUpsertArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesCountArgs} args - Arguments to filter Dailies to count.
     * @example
     * // Count the number of Dailies
     * const count = await prisma.dailies.count({
     *   where: {
     *     // ... the filter for the Dailies we want to count
     *   }
     * })
    **/
    count<T extends DailiesCountArgs>(
      args?: Subset<T, DailiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailiesAggregateArgs>(args: Subset<T, DailiesAggregateArgs>): Prisma.PrismaPromise<GetDailiesAggregateType<T>>

    /**
     * Group by Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailiesGroupByArgs['orderBy'] }
        : { orderBy?: DailiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dailies model
   */
  readonly fields: DailiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dailies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Drivers<T extends DriversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriversDefaultArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Jobs<T extends Dailies$JobsArgs<ExtArgs> = {}>(args?: Subset<T, Dailies$JobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dailies model
   */
  interface DailiesFieldRefs {
    readonly ID: FieldRef<"Dailies", 'Int'>
    readonly DriverID: FieldRef<"Dailies", 'Int'>
    readonly Week: FieldRef<"Dailies", 'String'>
    readonly LastPrinted: FieldRef<"Dailies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dailies findUnique
   */
  export type DailiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * Filter, which Dailies to fetch.
     */
    where: DailiesWhereUniqueInput
  }

  /**
   * Dailies findUniqueOrThrow
   */
  export type DailiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * Filter, which Dailies to fetch.
     */
    where: DailiesWhereUniqueInput
  }

  /**
   * Dailies findFirst
   */
  export type DailiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * Filter, which Dailies to fetch.
     */
    where?: DailiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dailies to fetch.
     */
    orderBy?: DailiesOrderByWithRelationInput | DailiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dailies.
     */
    cursor?: DailiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dailies.
     */
    distinct?: DailiesScalarFieldEnum | DailiesScalarFieldEnum[]
  }

  /**
   * Dailies findFirstOrThrow
   */
  export type DailiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * Filter, which Dailies to fetch.
     */
    where?: DailiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dailies to fetch.
     */
    orderBy?: DailiesOrderByWithRelationInput | DailiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dailies.
     */
    cursor?: DailiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dailies.
     */
    distinct?: DailiesScalarFieldEnum | DailiesScalarFieldEnum[]
  }

  /**
   * Dailies findMany
   */
  export type DailiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * Filter, which Dailies to fetch.
     */
    where?: DailiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dailies to fetch.
     */
    orderBy?: DailiesOrderByWithRelationInput | DailiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dailies.
     */
    cursor?: DailiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dailies.
     */
    skip?: number
    distinct?: DailiesScalarFieldEnum | DailiesScalarFieldEnum[]
  }

  /**
   * Dailies create
   */
  export type DailiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * The data needed to create a Dailies.
     */
    data: XOR<DailiesCreateInput, DailiesUncheckedCreateInput>
  }

  /**
   * Dailies createMany
   */
  export type DailiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dailies.
     */
    data: DailiesCreateManyInput | DailiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dailies update
   */
  export type DailiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * The data needed to update a Dailies.
     */
    data: XOR<DailiesUpdateInput, DailiesUncheckedUpdateInput>
    /**
     * Choose, which Dailies to update.
     */
    where: DailiesWhereUniqueInput
  }

  /**
   * Dailies updateMany
   */
  export type DailiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dailies.
     */
    data: XOR<DailiesUpdateManyMutationInput, DailiesUncheckedUpdateManyInput>
    /**
     * Filter which Dailies to update
     */
    where?: DailiesWhereInput
    /**
     * Limit how many Dailies to update.
     */
    limit?: number
  }

  /**
   * Dailies upsert
   */
  export type DailiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * The filter to search for the Dailies to update in case it exists.
     */
    where: DailiesWhereUniqueInput
    /**
     * In case the Dailies found by the `where` argument doesn't exist, create a new Dailies with this data.
     */
    create: XOR<DailiesCreateInput, DailiesUncheckedCreateInput>
    /**
     * In case the Dailies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailiesUpdateInput, DailiesUncheckedUpdateInput>
  }

  /**
   * Dailies delete
   */
  export type DailiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
    /**
     * Filter which Dailies to delete.
     */
    where: DailiesWhereUniqueInput
  }

  /**
   * Dailies deleteMany
   */
  export type DailiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dailies to delete
     */
    where?: DailiesWhereInput
    /**
     * Limit how many Dailies to delete.
     */
    limit?: number
  }

  /**
   * Dailies.Jobs
   */
  export type Dailies$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Dailies without action
   */
  export type DailiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dailies
     */
    select?: DailiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dailies
     */
    omit?: DailiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailiesInclude<ExtArgs> | null
  }


  /**
   * Model Jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsSumAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsMinAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    PaidOut: boolean | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsMaxAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    PaidOut: boolean | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsCountAggregateOutputType = {
    ID: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut: number
    TruckingRevenue: number
    CompanyRevenue: number
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsSumAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsMinAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    PaidOut?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsMaxAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    PaidOut?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsCountAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    PaidOut?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to aggregate.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type JobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithAggregationInput | JobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: JobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    ID: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut: boolean
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID: number | null
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type JobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    DriverID?: boolean
    LoadTypeID?: boolean
    CustomerID?: boolean
    PaidOut?: boolean
    TruckingRevenue?: boolean
    CompanyRevenue?: boolean
    TruckingRate?: boolean
    CompanyRate?: boolean
    DeliveryLocationID?: boolean
    WeeklyID?: boolean
    DailyID?: boolean
    MaterialRate?: boolean
    DriverRate?: boolean
    PayStubID?: boolean
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    Dailies?: boolean | DailiesDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | DeliveryLocationsDefaultArgs<ExtArgs>
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    LoadTypes?: boolean | LoadTypesDefaultArgs<ExtArgs>
    PayStubs?: boolean | Jobs$PayStubsArgs<ExtArgs>
    Weeklies?: boolean | WeekliesDefaultArgs<ExtArgs>
    Loads?: boolean | Jobs$LoadsArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>



  export type JobsSelectScalar = {
    ID?: boolean
    DriverID?: boolean
    LoadTypeID?: boolean
    CustomerID?: boolean
    PaidOut?: boolean
    TruckingRevenue?: boolean
    CompanyRevenue?: boolean
    TruckingRate?: boolean
    CompanyRate?: boolean
    DeliveryLocationID?: boolean
    WeeklyID?: boolean
    DailyID?: boolean
    MaterialRate?: boolean
    DriverRate?: boolean
    PayStubID?: boolean
  }

  export type JobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "DriverID" | "LoadTypeID" | "CustomerID" | "PaidOut" | "TruckingRevenue" | "CompanyRevenue" | "TruckingRate" | "CompanyRate" | "DeliveryLocationID" | "WeeklyID" | "DailyID" | "MaterialRate" | "DriverRate" | "PayStubID", ExtArgs["result"]["jobs"]>
  export type JobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    Dailies?: boolean | DailiesDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | DeliveryLocationsDefaultArgs<ExtArgs>
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    LoadTypes?: boolean | LoadTypesDefaultArgs<ExtArgs>
    PayStubs?: boolean | Jobs$PayStubsArgs<ExtArgs>
    Weeklies?: boolean | WeekliesDefaultArgs<ExtArgs>
    Loads?: boolean | Jobs$LoadsArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobs"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>
      Dailies: Prisma.$DailiesPayload<ExtArgs>
      DeliveryLocations: Prisma.$DeliveryLocationsPayload<ExtArgs>
      Drivers: Prisma.$DriversPayload<ExtArgs>
      LoadTypes: Prisma.$LoadTypesPayload<ExtArgs>
      PayStubs: Prisma.$PayStubsPayload<ExtArgs> | null
      Weeklies: Prisma.$WeekliesPayload<ExtArgs>
      Loads: Prisma.$LoadsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      DriverID: number
      LoadTypeID: number
      CustomerID: number
      PaidOut: boolean
      TruckingRevenue: number | null
      CompanyRevenue: number | null
      TruckingRate: number
      CompanyRate: number
      DeliveryLocationID: number
      WeeklyID: number
      DailyID: number
      MaterialRate: number
      DriverRate: number
      PayStubID: number | null
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type JobsGetPayload<S extends boolean | null | undefined | JobsDefaultArgs> = $Result.GetResult<Prisma.$JobsPayload, S>

  type JobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface JobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobs'], meta: { name: 'Jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobsFindUniqueArgs>(args: SelectSubset<T, JobsFindUniqueArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs>(args: SelectSubset<T, JobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobsFindFirstArgs>(args?: SelectSubset<T, JobsFindFirstArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs>(args?: SelectSubset<T, JobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const jobsWithIDOnly = await prisma.jobs.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends JobsFindManyArgs>(args?: SelectSubset<T, JobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends JobsCreateArgs>(args: SelectSubset<T, JobsCreateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobsCreateManyArgs>(args?: SelectSubset<T, JobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends JobsDeleteArgs>(args: SelectSubset<T, JobsDeleteArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobsUpdateArgs>(args: SelectSubset<T, JobsUpdateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobsDeleteManyArgs>(args?: SelectSubset<T, JobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobsUpdateManyArgs>(args: SelectSubset<T, JobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends JobsUpsertArgs>(args: SelectSubset<T, JobsUpsertArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs['orderBy'] }
        : { orderBy?: JobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobs model
   */
  readonly fields: JobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Dailies<T extends DailiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailiesDefaultArgs<ExtArgs>>): Prisma__DailiesClient<$Result.GetResult<Prisma.$DailiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeliveryLocations<T extends DeliveryLocationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocationsDefaultArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Drivers<T extends DriversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriversDefaultArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LoadTypes<T extends LoadTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoadTypesDefaultArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PayStubs<T extends Jobs$PayStubsArgs<ExtArgs> = {}>(args?: Subset<T, Jobs$PayStubsArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Weeklies<T extends WeekliesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeekliesDefaultArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Loads<T extends Jobs$LoadsArgs<ExtArgs> = {}>(args?: Subset<T, Jobs$LoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobs model
   */
  interface JobsFieldRefs {
    readonly ID: FieldRef<"Jobs", 'Int'>
    readonly DriverID: FieldRef<"Jobs", 'Int'>
    readonly LoadTypeID: FieldRef<"Jobs", 'Int'>
    readonly CustomerID: FieldRef<"Jobs", 'Int'>
    readonly PaidOut: FieldRef<"Jobs", 'Boolean'>
    readonly TruckingRevenue: FieldRef<"Jobs", 'Float'>
    readonly CompanyRevenue: FieldRef<"Jobs", 'Float'>
    readonly TruckingRate: FieldRef<"Jobs", 'Float'>
    readonly CompanyRate: FieldRef<"Jobs", 'Float'>
    readonly DeliveryLocationID: FieldRef<"Jobs", 'Int'>
    readonly WeeklyID: FieldRef<"Jobs", 'Int'>
    readonly DailyID: FieldRef<"Jobs", 'Int'>
    readonly MaterialRate: FieldRef<"Jobs", 'Float'>
    readonly DriverRate: FieldRef<"Jobs", 'Float'>
    readonly PayStubID: FieldRef<"Jobs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Jobs findUnique
   */
  export type JobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findFirst
   */
  export type JobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs create
   */
  export type JobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to create a Jobs.
     */
    data: XOR<JobsCreateInput, JobsUncheckedCreateInput>
  }

  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jobs update
   */
  export type JobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to update a Jobs.
     */
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
    /**
     * Choose, which Jobs to update.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobsWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The filter to search for the Jobs to update in case it exists.
     */
    where: JobsWhereUniqueInput
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     */
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
  }

  /**
   * Jobs delete
   */
  export type JobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter which Jobs to delete.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobsWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Jobs.PayStubs
   */
  export type Jobs$PayStubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    where?: PayStubsWhereInput
  }

  /**
   * Jobs.Loads
   */
  export type Jobs$LoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loads
     */
    select?: LoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loads
     */
    omit?: LoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoadsInclude<ExtArgs> | null
    where?: LoadsWhereInput
    orderBy?: LoadsOrderByWithRelationInput | LoadsOrderByWithRelationInput[]
    cursor?: LoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoadsScalarFieldEnum | LoadsScalarFieldEnum[]
  }

  /**
   * Jobs without action
   */
  export type JobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
  }


  /**
   * Model Weeklies
   */

  export type AggregateWeeklies = {
    _count: WeekliesCountAggregateOutputType | null
    _avg: WeekliesAvgAggregateOutputType | null
    _sum: WeekliesSumAggregateOutputType | null
    _min: WeekliesMinAggregateOutputType | null
    _max: WeekliesMaxAggregateOutputType | null
  }

  export type WeekliesAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TotalWeight: number | null
  }

  export type WeekliesSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TotalWeight: number | null
  }

  export type WeekliesMinAggregateOutputType = {
    ID: number | null
    Week: string | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    LastPrinted: Date | null
    TotalWeight: number | null
  }

  export type WeekliesMaxAggregateOutputType = {
    ID: number | null
    Week: string | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    LastPrinted: Date | null
    TotalWeight: number | null
  }

  export type WeekliesCountAggregateOutputType = {
    ID: number
    Week: number
    CustomerID: number
    InvoiceID: number
    CompanyRate: number
    Revenue: number
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted: number
    TotalWeight: number
    _all: number
  }


  export type WeekliesAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TotalWeight?: true
  }

  export type WeekliesSumAggregateInputType = {
    ID?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TotalWeight?: true
  }

  export type WeekliesMinAggregateInputType = {
    ID?: true
    Week?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    LastPrinted?: true
    TotalWeight?: true
  }

  export type WeekliesMaxAggregateInputType = {
    ID?: true
    Week?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    LastPrinted?: true
    TotalWeight?: true
  }

  export type WeekliesCountAggregateInputType = {
    ID?: true
    Week?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    LastPrinted?: true
    TotalWeight?: true
    _all?: true
  }

  export type WeekliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weeklies to aggregate.
     */
    where?: WeekliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeklies to fetch.
     */
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeekliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeklies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeklies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weeklies
    **/
    _count?: true | WeekliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeekliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeekliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeekliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeekliesMaxAggregateInputType
  }

  export type GetWeekliesAggregateType<T extends WeekliesAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklies[P]>
      : GetScalarType<T[P], AggregateWeeklies[P]>
  }




  export type WeekliesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeekliesWhereInput
    orderBy?: WeekliesOrderByWithAggregationInput | WeekliesOrderByWithAggregationInput[]
    by: WeekliesScalarFieldEnum[] | WeekliesScalarFieldEnum
    having?: WeekliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeekliesCountAggregateInputType | true
    _avg?: WeekliesAvgAggregateInputType
    _sum?: WeekliesSumAggregateInputType
    _min?: WeekliesMinAggregateInputType
    _max?: WeekliesMaxAggregateInputType
  }

  export type WeekliesGroupByOutputType = {
    ID: number
    Week: string
    CustomerID: number
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted: Date | null
    TotalWeight: number | null
    _count: WeekliesCountAggregateOutputType | null
    _avg: WeekliesAvgAggregateOutputType | null
    _sum: WeekliesSumAggregateOutputType | null
    _min: WeekliesMinAggregateOutputType | null
    _max: WeekliesMaxAggregateOutputType | null
  }

  type GetWeekliesGroupByPayload<T extends WeekliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeekliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeekliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeekliesGroupByOutputType[P]>
            : GetScalarType<T[P], WeekliesGroupByOutputType[P]>
        }
      >
    >


  export type WeekliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Week?: boolean
    CustomerID?: boolean
    InvoiceID?: boolean
    CompanyRate?: boolean
    Revenue?: boolean
    LoadTypeID?: boolean
    DeliveryLocationID?: boolean
    LastPrinted?: boolean
    TotalWeight?: boolean
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | DeliveryLocationsDefaultArgs<ExtArgs>
    Invoices?: boolean | Weeklies$InvoicesArgs<ExtArgs>
    LoadTypes?: boolean | LoadTypesDefaultArgs<ExtArgs>
    Jobs?: boolean | Weeklies$JobsArgs<ExtArgs>
    _count?: boolean | WeekliesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklies"]>



  export type WeekliesSelectScalar = {
    ID?: boolean
    Week?: boolean
    CustomerID?: boolean
    InvoiceID?: boolean
    CompanyRate?: boolean
    Revenue?: boolean
    LoadTypeID?: boolean
    DeliveryLocationID?: boolean
    LastPrinted?: boolean
    TotalWeight?: boolean
  }

  export type WeekliesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Week" | "CustomerID" | "InvoiceID" | "CompanyRate" | "Revenue" | "LoadTypeID" | "DeliveryLocationID" | "LastPrinted" | "TotalWeight", ExtArgs["result"]["weeklies"]>
  export type WeekliesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    DeliveryLocations?: boolean | DeliveryLocationsDefaultArgs<ExtArgs>
    Invoices?: boolean | Weeklies$InvoicesArgs<ExtArgs>
    LoadTypes?: boolean | LoadTypesDefaultArgs<ExtArgs>
    Jobs?: boolean | Weeklies$JobsArgs<ExtArgs>
    _count?: boolean | WeekliesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WeekliesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weeklies"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>
      DeliveryLocations: Prisma.$DeliveryLocationsPayload<ExtArgs>
      Invoices: Prisma.$InvoicesPayload<ExtArgs> | null
      LoadTypes: Prisma.$LoadTypesPayload<ExtArgs>
      Jobs: Prisma.$JobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Week: string
      CustomerID: number
      InvoiceID: number | null
      CompanyRate: number | null
      Revenue: number | null
      LoadTypeID: number
      DeliveryLocationID: number
      LastPrinted: Date | null
      TotalWeight: number | null
    }, ExtArgs["result"]["weeklies"]>
    composites: {}
  }

  type WeekliesGetPayload<S extends boolean | null | undefined | WeekliesDefaultArgs> = $Result.GetResult<Prisma.$WeekliesPayload, S>

  type WeekliesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeekliesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeekliesCountAggregateInputType | true
    }

  export interface WeekliesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weeklies'], meta: { name: 'Weeklies' } }
    /**
     * Find zero or one Weeklies that matches the filter.
     * @param {WeekliesFindUniqueArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeekliesFindUniqueArgs>(args: SelectSubset<T, WeekliesFindUniqueArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weeklies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeekliesFindUniqueOrThrowArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeekliesFindUniqueOrThrowArgs>(args: SelectSubset<T, WeekliesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weeklies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesFindFirstArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeekliesFindFirstArgs>(args?: SelectSubset<T, WeekliesFindFirstArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weeklies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesFindFirstOrThrowArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeekliesFindFirstOrThrowArgs>(args?: SelectSubset<T, WeekliesFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weeklies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weeklies
     * const weeklies = await prisma.weeklies.findMany()
     * 
     * // Get first 10 Weeklies
     * const weeklies = await prisma.weeklies.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const weekliesWithIDOnly = await prisma.weeklies.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WeekliesFindManyArgs>(args?: SelectSubset<T, WeekliesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weeklies.
     * @param {WeekliesCreateArgs} args - Arguments to create a Weeklies.
     * @example
     * // Create one Weeklies
     * const Weeklies = await prisma.weeklies.create({
     *   data: {
     *     // ... data to create a Weeklies
     *   }
     * })
     * 
     */
    create<T extends WeekliesCreateArgs>(args: SelectSubset<T, WeekliesCreateArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weeklies.
     * @param {WeekliesCreateManyArgs} args - Arguments to create many Weeklies.
     * @example
     * // Create many Weeklies
     * const weeklies = await prisma.weeklies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeekliesCreateManyArgs>(args?: SelectSubset<T, WeekliesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Weeklies.
     * @param {WeekliesDeleteArgs} args - Arguments to delete one Weeklies.
     * @example
     * // Delete one Weeklies
     * const Weeklies = await prisma.weeklies.delete({
     *   where: {
     *     // ... filter to delete one Weeklies
     *   }
     * })
     * 
     */
    delete<T extends WeekliesDeleteArgs>(args: SelectSubset<T, WeekliesDeleteArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weeklies.
     * @param {WeekliesUpdateArgs} args - Arguments to update one Weeklies.
     * @example
     * // Update one Weeklies
     * const weeklies = await prisma.weeklies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeekliesUpdateArgs>(args: SelectSubset<T, WeekliesUpdateArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weeklies.
     * @param {WeekliesDeleteManyArgs} args - Arguments to filter Weeklies to delete.
     * @example
     * // Delete a few Weeklies
     * const { count } = await prisma.weeklies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeekliesDeleteManyArgs>(args?: SelectSubset<T, WeekliesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weeklies
     * const weeklies = await prisma.weeklies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeekliesUpdateManyArgs>(args: SelectSubset<T, WeekliesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Weeklies.
     * @param {WeekliesUpsertArgs} args - Arguments to update or create a Weeklies.
     * @example
     * // Update or create a Weeklies
     * const weeklies = await prisma.weeklies.upsert({
     *   create: {
     *     // ... data to create a Weeklies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weeklies we want to update
     *   }
     * })
     */
    upsert<T extends WeekliesUpsertArgs>(args: SelectSubset<T, WeekliesUpsertArgs<ExtArgs>>): Prisma__WeekliesClient<$Result.GetResult<Prisma.$WeekliesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesCountArgs} args - Arguments to filter Weeklies to count.
     * @example
     * // Count the number of Weeklies
     * const count = await prisma.weeklies.count({
     *   where: {
     *     // ... the filter for the Weeklies we want to count
     *   }
     * })
    **/
    count<T extends WeekliesCountArgs>(
      args?: Subset<T, WeekliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeekliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeekliesAggregateArgs>(args: Subset<T, WeekliesAggregateArgs>): Prisma.PrismaPromise<GetWeekliesAggregateType<T>>

    /**
     * Group by Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeekliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeekliesGroupByArgs['orderBy'] }
        : { orderBy?: WeekliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeekliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeekliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weeklies model
   */
  readonly fields: WeekliesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weeklies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeekliesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeliveryLocations<T extends DeliveryLocationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLocationsDefaultArgs<ExtArgs>>): Prisma__DeliveryLocationsClient<$Result.GetResult<Prisma.$DeliveryLocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Invoices<T extends Weeklies$InvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Weeklies$InvoicesArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    LoadTypes<T extends LoadTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoadTypesDefaultArgs<ExtArgs>>): Prisma__LoadTypesClient<$Result.GetResult<Prisma.$LoadTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Jobs<T extends Weeklies$JobsArgs<ExtArgs> = {}>(args?: Subset<T, Weeklies$JobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weeklies model
   */
  interface WeekliesFieldRefs {
    readonly ID: FieldRef<"Weeklies", 'Int'>
    readonly Week: FieldRef<"Weeklies", 'String'>
    readonly CustomerID: FieldRef<"Weeklies", 'Int'>
    readonly InvoiceID: FieldRef<"Weeklies", 'Int'>
    readonly CompanyRate: FieldRef<"Weeklies", 'Float'>
    readonly Revenue: FieldRef<"Weeklies", 'Float'>
    readonly LoadTypeID: FieldRef<"Weeklies", 'Int'>
    readonly DeliveryLocationID: FieldRef<"Weeklies", 'Int'>
    readonly LastPrinted: FieldRef<"Weeklies", 'DateTime'>
    readonly TotalWeight: FieldRef<"Weeklies", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Weeklies findUnique
   */
  export type WeekliesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * Filter, which Weeklies to fetch.
     */
    where: WeekliesWhereUniqueInput
  }

  /**
   * Weeklies findUniqueOrThrow
   */
  export type WeekliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * Filter, which Weeklies to fetch.
     */
    where: WeekliesWhereUniqueInput
  }

  /**
   * Weeklies findFirst
   */
  export type WeekliesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * Filter, which Weeklies to fetch.
     */
    where?: WeekliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeklies to fetch.
     */
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weeklies.
     */
    cursor?: WeekliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeklies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeklies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weeklies.
     */
    distinct?: WeekliesScalarFieldEnum | WeekliesScalarFieldEnum[]
  }

  /**
   * Weeklies findFirstOrThrow
   */
  export type WeekliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * Filter, which Weeklies to fetch.
     */
    where?: WeekliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeklies to fetch.
     */
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weeklies.
     */
    cursor?: WeekliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeklies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeklies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weeklies.
     */
    distinct?: WeekliesScalarFieldEnum | WeekliesScalarFieldEnum[]
  }

  /**
   * Weeklies findMany
   */
  export type WeekliesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * Filter, which Weeklies to fetch.
     */
    where?: WeekliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeklies to fetch.
     */
    orderBy?: WeekliesOrderByWithRelationInput | WeekliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weeklies.
     */
    cursor?: WeekliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeklies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeklies.
     */
    skip?: number
    distinct?: WeekliesScalarFieldEnum | WeekliesScalarFieldEnum[]
  }

  /**
   * Weeklies create
   */
  export type WeekliesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * The data needed to create a Weeklies.
     */
    data: XOR<WeekliesCreateInput, WeekliesUncheckedCreateInput>
  }

  /**
   * Weeklies createMany
   */
  export type WeekliesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weeklies.
     */
    data: WeekliesCreateManyInput | WeekliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weeklies update
   */
  export type WeekliesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * The data needed to update a Weeklies.
     */
    data: XOR<WeekliesUpdateInput, WeekliesUncheckedUpdateInput>
    /**
     * Choose, which Weeklies to update.
     */
    where: WeekliesWhereUniqueInput
  }

  /**
   * Weeklies updateMany
   */
  export type WeekliesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weeklies.
     */
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyInput>
    /**
     * Filter which Weeklies to update
     */
    where?: WeekliesWhereInput
    /**
     * Limit how many Weeklies to update.
     */
    limit?: number
  }

  /**
   * Weeklies upsert
   */
  export type WeekliesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * The filter to search for the Weeklies to update in case it exists.
     */
    where: WeekliesWhereUniqueInput
    /**
     * In case the Weeklies found by the `where` argument doesn't exist, create a new Weeklies with this data.
     */
    create: XOR<WeekliesCreateInput, WeekliesUncheckedCreateInput>
    /**
     * In case the Weeklies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeekliesUpdateInput, WeekliesUncheckedUpdateInput>
  }

  /**
   * Weeklies delete
   */
  export type WeekliesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
    /**
     * Filter which Weeklies to delete.
     */
    where: WeekliesWhereUniqueInput
  }

  /**
   * Weeklies deleteMany
   */
  export type WeekliesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weeklies to delete
     */
    where?: WeekliesWhereInput
    /**
     * Limit how many Weeklies to delete.
     */
    limit?: number
  }

  /**
   * Weeklies.Invoices
   */
  export type Weeklies$InvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    where?: InvoicesWhereInput
  }

  /**
   * Weeklies.Jobs
   */
  export type Weeklies$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Weeklies without action
   */
  export type WeekliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weeklies
     */
    select?: WeekliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weeklies
     */
    omit?: WeekliesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeekliesInclude<ExtArgs> | null
  }


  /**
   * Model PayStubs
   */

  export type AggregatePayStubs = {
    _count: PayStubsCountAggregateOutputType | null
    _avg: PayStubsAvgAggregateOutputType | null
    _sum: PayStubsSumAggregateOutputType | null
    _min: PayStubsMinAggregateOutputType | null
    _max: PayStubsMaxAggregateOutputType | null
  }

  export type PayStubsAvgAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
  }

  export type PayStubsSumAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
  }

  export type PayStubsMinAggregateOutputType = {
    ID: number | null
    Created: Date | null
    DriverID: number | null
    CheckNumber: string | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    LastPrinted: Date | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
    Notes: string | null
    DepositDate: Date | null
  }

  export type PayStubsMaxAggregateOutputType = {
    ID: number | null
    Created: Date | null
    DriverID: number | null
    CheckNumber: string | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    LastPrinted: Date | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
    Notes: string | null
    DepositDate: Date | null
  }

  export type PayStubsCountAggregateOutputType = {
    ID: number
    Created: number
    DriverID: number
    CheckNumber: number
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted: number
    TakeHome: number
    Deductions: number
    Additions: number
    Notes: number
    DepositDate: number
    _all: number
  }


  export type PayStubsAvgAggregateInputType = {
    ID?: true
    DriverID?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
  }

  export type PayStubsSumAggregateInputType = {
    ID?: true
    DriverID?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
  }

  export type PayStubsMinAggregateInputType = {
    ID?: true
    Created?: true
    DriverID?: true
    CheckNumber?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    LastPrinted?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
    Notes?: true
    DepositDate?: true
  }

  export type PayStubsMaxAggregateInputType = {
    ID?: true
    Created?: true
    DriverID?: true
    CheckNumber?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    LastPrinted?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
    Notes?: true
    DepositDate?: true
  }

  export type PayStubsCountAggregateInputType = {
    ID?: true
    Created?: true
    DriverID?: true
    CheckNumber?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    LastPrinted?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
    Notes?: true
    DepositDate?: true
    _all?: true
  }

  export type PayStubsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayStubs to aggregate.
     */
    where?: PayStubsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStubs to fetch.
     */
    orderBy?: PayStubsOrderByWithRelationInput | PayStubsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayStubsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayStubs
    **/
    _count?: true | PayStubsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayStubsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayStubsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayStubsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayStubsMaxAggregateInputType
  }

  export type GetPayStubsAggregateType<T extends PayStubsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayStubs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayStubs[P]>
      : GetScalarType<T[P], AggregatePayStubs[P]>
  }




  export type PayStubsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayStubsWhereInput
    orderBy?: PayStubsOrderByWithAggregationInput | PayStubsOrderByWithAggregationInput[]
    by: PayStubsScalarFieldEnum[] | PayStubsScalarFieldEnum
    having?: PayStubsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayStubsCountAggregateInputType | true
    _avg?: PayStubsAvgAggregateInputType
    _sum?: PayStubsSumAggregateInputType
    _min?: PayStubsMinAggregateInputType
    _max?: PayStubsMaxAggregateInputType
  }

  export type PayStubsGroupByOutputType = {
    ID: number
    Created: Date
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted: Date | null
    TakeHome: number
    Deductions: number
    Additions: number
    Notes: string | null
    DepositDate: Date | null
    _count: PayStubsCountAggregateOutputType | null
    _avg: PayStubsAvgAggregateOutputType | null
    _sum: PayStubsSumAggregateOutputType | null
    _min: PayStubsMinAggregateOutputType | null
    _max: PayStubsMaxAggregateOutputType | null
  }

  type GetPayStubsGroupByPayload<T extends PayStubsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayStubsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayStubsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayStubsGroupByOutputType[P]>
            : GetScalarType<T[P], PayStubsGroupByOutputType[P]>
        }
      >
    >


  export type PayStubsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Created?: boolean
    DriverID?: boolean
    CheckNumber?: boolean
    Gross?: boolean
    Percentage?: boolean
    NetTotal?: boolean
    LastPrinted?: boolean
    TakeHome?: boolean
    Deductions?: boolean
    Additions?: boolean
    Notes?: boolean
    DepositDate?: boolean
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    Jobs?: boolean | PayStubs$JobsArgs<ExtArgs>
    _count?: boolean | PayStubsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payStubs"]>



  export type PayStubsSelectScalar = {
    ID?: boolean
    Created?: boolean
    DriverID?: boolean
    CheckNumber?: boolean
    Gross?: boolean
    Percentage?: boolean
    NetTotal?: boolean
    LastPrinted?: boolean
    TakeHome?: boolean
    Deductions?: boolean
    Additions?: boolean
    Notes?: boolean
    DepositDate?: boolean
  }

  export type PayStubsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Created" | "DriverID" | "CheckNumber" | "Gross" | "Percentage" | "NetTotal" | "LastPrinted" | "TakeHome" | "Deductions" | "Additions" | "Notes" | "DepositDate", ExtArgs["result"]["payStubs"]>
  export type PayStubsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Drivers?: boolean | DriversDefaultArgs<ExtArgs>
    Jobs?: boolean | PayStubs$JobsArgs<ExtArgs>
    _count?: boolean | PayStubsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PayStubsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayStubs"
    objects: {
      Drivers: Prisma.$DriversPayload<ExtArgs>
      Jobs: Prisma.$JobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      /**
       * @zod.custom(z.coerce.date())
       */
      Created: Date
      DriverID: number
      CheckNumber: string
      /**
       * @zod.custom(z.coerce.number())
       */
      Gross: number
      /**
       * @zod.custom(z.coerce.number())
       */
      Percentage: number
      /**
       * @zod.custom(z.coerce.number())
       */
      NetTotal: number
      /**
       * @zod.custom(z.coerce.date())
       */
      LastPrinted: Date | null
      /**
       * @zod.custom(z.coerce.number())
       */
      TakeHome: number
      Deductions: number
      Additions: number
      Notes: string | null
      /**
       * @zod.custom(z.coerce.date())
       */
      DepositDate: Date | null
    }, ExtArgs["result"]["payStubs"]>
    composites: {}
  }

  type PayStubsGetPayload<S extends boolean | null | undefined | PayStubsDefaultArgs> = $Result.GetResult<Prisma.$PayStubsPayload, S>

  type PayStubsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayStubsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayStubsCountAggregateInputType | true
    }

  export interface PayStubsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayStubs'], meta: { name: 'PayStubs' } }
    /**
     * Find zero or one PayStubs that matches the filter.
     * @param {PayStubsFindUniqueArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayStubsFindUniqueArgs>(args: SelectSubset<T, PayStubsFindUniqueArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayStubs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayStubsFindUniqueOrThrowArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayStubsFindUniqueOrThrowArgs>(args: SelectSubset<T, PayStubsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayStubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsFindFirstArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayStubsFindFirstArgs>(args?: SelectSubset<T, PayStubsFindFirstArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayStubs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsFindFirstOrThrowArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayStubsFindFirstOrThrowArgs>(args?: SelectSubset<T, PayStubsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayStubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayStubs
     * const payStubs = await prisma.payStubs.findMany()
     * 
     * // Get first 10 PayStubs
     * const payStubs = await prisma.payStubs.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const payStubsWithIDOnly = await prisma.payStubs.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends PayStubsFindManyArgs>(args?: SelectSubset<T, PayStubsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayStubs.
     * @param {PayStubsCreateArgs} args - Arguments to create a PayStubs.
     * @example
     * // Create one PayStubs
     * const PayStubs = await prisma.payStubs.create({
     *   data: {
     *     // ... data to create a PayStubs
     *   }
     * })
     * 
     */
    create<T extends PayStubsCreateArgs>(args: SelectSubset<T, PayStubsCreateArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayStubs.
     * @param {PayStubsCreateManyArgs} args - Arguments to create many PayStubs.
     * @example
     * // Create many PayStubs
     * const payStubs = await prisma.payStubs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayStubsCreateManyArgs>(args?: SelectSubset<T, PayStubsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PayStubs.
     * @param {PayStubsDeleteArgs} args - Arguments to delete one PayStubs.
     * @example
     * // Delete one PayStubs
     * const PayStubs = await prisma.payStubs.delete({
     *   where: {
     *     // ... filter to delete one PayStubs
     *   }
     * })
     * 
     */
    delete<T extends PayStubsDeleteArgs>(args: SelectSubset<T, PayStubsDeleteArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayStubs.
     * @param {PayStubsUpdateArgs} args - Arguments to update one PayStubs.
     * @example
     * // Update one PayStubs
     * const payStubs = await prisma.payStubs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayStubsUpdateArgs>(args: SelectSubset<T, PayStubsUpdateArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayStubs.
     * @param {PayStubsDeleteManyArgs} args - Arguments to filter PayStubs to delete.
     * @example
     * // Delete a few PayStubs
     * const { count } = await prisma.payStubs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayStubsDeleteManyArgs>(args?: SelectSubset<T, PayStubsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayStubs
     * const payStubs = await prisma.payStubs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayStubsUpdateManyArgs>(args: SelectSubset<T, PayStubsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PayStubs.
     * @param {PayStubsUpsertArgs} args - Arguments to update or create a PayStubs.
     * @example
     * // Update or create a PayStubs
     * const payStubs = await prisma.payStubs.upsert({
     *   create: {
     *     // ... data to create a PayStubs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayStubs we want to update
     *   }
     * })
     */
    upsert<T extends PayStubsUpsertArgs>(args: SelectSubset<T, PayStubsUpsertArgs<ExtArgs>>): Prisma__PayStubsClient<$Result.GetResult<Prisma.$PayStubsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsCountArgs} args - Arguments to filter PayStubs to count.
     * @example
     * // Count the number of PayStubs
     * const count = await prisma.payStubs.count({
     *   where: {
     *     // ... the filter for the PayStubs we want to count
     *   }
     * })
    **/
    count<T extends PayStubsCountArgs>(
      args?: Subset<T, PayStubsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayStubsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayStubsAggregateArgs>(args: Subset<T, PayStubsAggregateArgs>): Prisma.PrismaPromise<GetPayStubsAggregateType<T>>

    /**
     * Group by PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayStubsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayStubsGroupByArgs['orderBy'] }
        : { orderBy?: PayStubsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayStubsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayStubsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayStubs model
   */
  readonly fields: PayStubsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayStubs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayStubsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Drivers<T extends DriversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriversDefaultArgs<ExtArgs>>): Prisma__DriversClient<$Result.GetResult<Prisma.$DriversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Jobs<T extends PayStubs$JobsArgs<ExtArgs> = {}>(args?: Subset<T, PayStubs$JobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayStubs model
   */
  interface PayStubsFieldRefs {
    readonly ID: FieldRef<"PayStubs", 'Int'>
    readonly Created: FieldRef<"PayStubs", 'DateTime'>
    readonly DriverID: FieldRef<"PayStubs", 'Int'>
    readonly CheckNumber: FieldRef<"PayStubs", 'String'>
    readonly Gross: FieldRef<"PayStubs", 'Float'>
    readonly Percentage: FieldRef<"PayStubs", 'Float'>
    readonly NetTotal: FieldRef<"PayStubs", 'Float'>
    readonly LastPrinted: FieldRef<"PayStubs", 'DateTime'>
    readonly TakeHome: FieldRef<"PayStubs", 'Float'>
    readonly Deductions: FieldRef<"PayStubs", 'Float'>
    readonly Additions: FieldRef<"PayStubs", 'Float'>
    readonly Notes: FieldRef<"PayStubs", 'String'>
    readonly DepositDate: FieldRef<"PayStubs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayStubs findUnique
   */
  export type PayStubsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * Filter, which PayStubs to fetch.
     */
    where: PayStubsWhereUniqueInput
  }

  /**
   * PayStubs findUniqueOrThrow
   */
  export type PayStubsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * Filter, which PayStubs to fetch.
     */
    where: PayStubsWhereUniqueInput
  }

  /**
   * PayStubs findFirst
   */
  export type PayStubsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * Filter, which PayStubs to fetch.
     */
    where?: PayStubsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStubs to fetch.
     */
    orderBy?: PayStubsOrderByWithRelationInput | PayStubsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayStubs.
     */
    cursor?: PayStubsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayStubs.
     */
    distinct?: PayStubsScalarFieldEnum | PayStubsScalarFieldEnum[]
  }

  /**
   * PayStubs findFirstOrThrow
   */
  export type PayStubsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * Filter, which PayStubs to fetch.
     */
    where?: PayStubsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStubs to fetch.
     */
    orderBy?: PayStubsOrderByWithRelationInput | PayStubsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayStubs.
     */
    cursor?: PayStubsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayStubs.
     */
    distinct?: PayStubsScalarFieldEnum | PayStubsScalarFieldEnum[]
  }

  /**
   * PayStubs findMany
   */
  export type PayStubsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * Filter, which PayStubs to fetch.
     */
    where?: PayStubsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStubs to fetch.
     */
    orderBy?: PayStubsOrderByWithRelationInput | PayStubsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayStubs.
     */
    cursor?: PayStubsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStubs.
     */
    skip?: number
    distinct?: PayStubsScalarFieldEnum | PayStubsScalarFieldEnum[]
  }

  /**
   * PayStubs create
   */
  export type PayStubsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * The data needed to create a PayStubs.
     */
    data: XOR<PayStubsCreateInput, PayStubsUncheckedCreateInput>
  }

  /**
   * PayStubs createMany
   */
  export type PayStubsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayStubs.
     */
    data: PayStubsCreateManyInput | PayStubsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayStubs update
   */
  export type PayStubsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * The data needed to update a PayStubs.
     */
    data: XOR<PayStubsUpdateInput, PayStubsUncheckedUpdateInput>
    /**
     * Choose, which PayStubs to update.
     */
    where: PayStubsWhereUniqueInput
  }

  /**
   * PayStubs updateMany
   */
  export type PayStubsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayStubs.
     */
    data: XOR<PayStubsUpdateManyMutationInput, PayStubsUncheckedUpdateManyInput>
    /**
     * Filter which PayStubs to update
     */
    where?: PayStubsWhereInput
    /**
     * Limit how many PayStubs to update.
     */
    limit?: number
  }

  /**
   * PayStubs upsert
   */
  export type PayStubsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * The filter to search for the PayStubs to update in case it exists.
     */
    where: PayStubsWhereUniqueInput
    /**
     * In case the PayStubs found by the `where` argument doesn't exist, create a new PayStubs with this data.
     */
    create: XOR<PayStubsCreateInput, PayStubsUncheckedCreateInput>
    /**
     * In case the PayStubs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayStubsUpdateInput, PayStubsUncheckedUpdateInput>
  }

  /**
   * PayStubs delete
   */
  export type PayStubsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
    /**
     * Filter which PayStubs to delete.
     */
    where: PayStubsWhereUniqueInput
  }

  /**
   * PayStubs deleteMany
   */
  export type PayStubsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayStubs to delete
     */
    where?: PayStubsWhereInput
    /**
     * Limit how many PayStubs to delete.
     */
    limit?: number
  }

  /**
   * PayStubs.Jobs
   */
  export type PayStubs$JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobs
     */
    omit?: JobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * PayStubs without action
   */
  export type PayStubsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStubs
     */
    select?: PayStubsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStubs
     */
    omit?: PayStubsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayStubsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    organization: 'organization',
    password: 'password',
    username: 'username'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerLoadTypesScalarFieldEnum: {
    ID: 'ID',
    CustomerID: 'CustomerID',
    LoadTypeID: 'LoadTypeID',
    DateDelivered: 'DateDelivered'
  };

  export type CustomerLoadTypesScalarFieldEnum = (typeof CustomerLoadTypesScalarFieldEnum)[keyof typeof CustomerLoadTypesScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Street: 'Street',
    City: 'City',
    State: 'State',
    ZIP: 'ZIP',
    Phone: 'Phone',
    Email: 'Email',
    Notes: 'Notes',
    MainContact: 'MainContact',
    Deleted: 'Deleted'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const DeliveryLocationsScalarFieldEnum: {
    ID: 'ID',
    Description: 'Description',
    Deleted: 'Deleted',
    CustomerID: 'CustomerID'
  };

  export type DeliveryLocationsScalarFieldEnum = (typeof DeliveryLocationsScalarFieldEnum)[keyof typeof DeliveryLocationsScalarFieldEnum]


  export const DriversScalarFieldEnum: {
    ID: 'ID',
    FirstName: 'FirstName',
    MiddleName: 'MiddleName',
    LastName: 'LastName',
    Street: 'Street',
    City: 'City',
    State: 'State',
    ZIP: 'ZIP',
    DOB: 'DOB',
    License: 'License',
    Email: 'Email',
    Phone: 'Phone',
    Notes: 'Notes',
    Deleted: 'Deleted',
    HireDate: 'HireDate',
    OwnerOperator: 'OwnerOperator'
  };

  export type DriversScalarFieldEnum = (typeof DriversScalarFieldEnum)[keyof typeof DriversScalarFieldEnum]


  export const InvoicesScalarFieldEnum: {
    ID: 'ID',
    InvoiceDate: 'InvoiceDate',
    Number: 'Number',
    CustomerID: 'CustomerID',
    TotalAmount: 'TotalAmount',
    PaidDate: 'PaidDate',
    CheckNumber: 'CheckNumber',
    Paid: 'Paid',
    Printed: 'Printed',
    Deleted: 'Deleted',
    PaymentType: 'PaymentType',
    Consolidated: 'Consolidated',
    ConsolidatedID: 'ConsolidatedID'
  };

  export type InvoicesScalarFieldEnum = (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum]


  export const LoadTypesScalarFieldEnum: {
    ID: 'ID',
    Description: 'Description',
    Deleted: 'Deleted',
    SourceID: 'SourceID',
    Notes: 'Notes'
  };

  export type LoadTypesScalarFieldEnum = (typeof LoadTypesScalarFieldEnum)[keyof typeof LoadTypesScalarFieldEnum]


  export const StatesScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Abbreviation: 'Abbreviation'
  };

  export type StatesScalarFieldEnum = (typeof StatesScalarFieldEnum)[keyof typeof StatesScalarFieldEnum]


  export const TrucksScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    VIN: 'VIN',
    Deleted: 'Deleted',
    Notes: 'Notes'
  };

  export type TrucksScalarFieldEnum = (typeof TrucksScalarFieldEnum)[keyof typeof TrucksScalarFieldEnum]


  export const TrucksDrivenScalarFieldEnum: {
    ID: 'ID',
    TruckID: 'TruckID',
    DriverID: 'DriverID',
    DateDriven: 'DateDriven'
  };

  export type TrucksDrivenScalarFieldEnum = (typeof TrucksDrivenScalarFieldEnum)[keyof typeof TrucksDrivenScalarFieldEnum]


  export const LoadsScalarFieldEnum: {
    ID: 'ID',
    StartDate: 'StartDate',
    Created: 'Created',
    Weight: 'Weight',
    Hours: 'Hours',
    TotalRate: 'TotalRate',
    TotalAmount: 'TotalAmount',
    TruckRate: 'TruckRate',
    MaterialRate: 'MaterialRate',
    Received: 'Received',
    Notes: 'Notes',
    TicketNumber: 'TicketNumber',
    Invoiced: 'Invoiced',
    CustomerID: 'CustomerID',
    InvoiceID: 'InvoiceID',
    LoadTypeID: 'LoadTypeID',
    DeliveryLocationID: 'DeliveryLocationID',
    TruckID: 'TruckID',
    DriverID: 'DriverID',
    Deleted: 'Deleted',
    JobID: 'JobID',
    Week: 'Week',
    DriverRate: 'DriverRate'
  };

  export type LoadsScalarFieldEnum = (typeof LoadsScalarFieldEnum)[keyof typeof LoadsScalarFieldEnum]


  export const CustomerDeliveryLocationsScalarFieldEnum: {
    ID: 'ID',
    CustomerID: 'CustomerID',
    DeliveryLocationID: 'DeliveryLocationID',
    DateUsed: 'DateUsed'
  };

  export type CustomerDeliveryLocationsScalarFieldEnum = (typeof CustomerDeliveryLocationsScalarFieldEnum)[keyof typeof CustomerDeliveryLocationsScalarFieldEnum]


  export const DailiesScalarFieldEnum: {
    ID: 'ID',
    DriverID: 'DriverID',
    Week: 'Week',
    LastPrinted: 'LastPrinted'
  };

  export type DailiesScalarFieldEnum = (typeof DailiesScalarFieldEnum)[keyof typeof DailiesScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    ID: 'ID',
    DriverID: 'DriverID',
    LoadTypeID: 'LoadTypeID',
    CustomerID: 'CustomerID',
    PaidOut: 'PaidOut',
    TruckingRevenue: 'TruckingRevenue',
    CompanyRevenue: 'CompanyRevenue',
    TruckingRate: 'TruckingRate',
    CompanyRate: 'CompanyRate',
    DeliveryLocationID: 'DeliveryLocationID',
    WeeklyID: 'WeeklyID',
    DailyID: 'DailyID',
    MaterialRate: 'MaterialRate',
    DriverRate: 'DriverRate',
    PayStubID: 'PayStubID'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const WeekliesScalarFieldEnum: {
    ID: 'ID',
    Week: 'Week',
    CustomerID: 'CustomerID',
    InvoiceID: 'InvoiceID',
    CompanyRate: 'CompanyRate',
    Revenue: 'Revenue',
    LoadTypeID: 'LoadTypeID',
    DeliveryLocationID: 'DeliveryLocationID',
    LastPrinted: 'LastPrinted',
    TotalWeight: 'TotalWeight'
  };

  export type WeekliesScalarFieldEnum = (typeof WeekliesScalarFieldEnum)[keyof typeof WeekliesScalarFieldEnum]


  export const PayStubsScalarFieldEnum: {
    ID: 'ID',
    Created: 'Created',
    DriverID: 'DriverID',
    CheckNumber: 'CheckNumber',
    Gross: 'Gross',
    Percentage: 'Percentage',
    NetTotal: 'NetTotal',
    LastPrinted: 'LastPrinted',
    TakeHome: 'TakeHome',
    Deductions: 'Deductions',
    Additions: 'Additions',
    Notes: 'Notes',
    DepositDate: 'DepositDate'
  };

  export type PayStubsScalarFieldEnum = (typeof PayStubsScalarFieldEnum)[keyof typeof PayStubsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    organization: 'organization',
    password: 'password',
    username: 'username'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CustomersOrderByRelevanceFieldEnum: {
    Name: 'Name',
    Street: 'Street',
    City: 'City',
    ZIP: 'ZIP',
    Phone: 'Phone',
    Email: 'Email',
    Notes: 'Notes',
    MainContact: 'MainContact'
  };

  export type CustomersOrderByRelevanceFieldEnum = (typeof CustomersOrderByRelevanceFieldEnum)[keyof typeof CustomersOrderByRelevanceFieldEnum]


  export const DeliveryLocationsOrderByRelevanceFieldEnum: {
    Description: 'Description'
  };

  export type DeliveryLocationsOrderByRelevanceFieldEnum = (typeof DeliveryLocationsOrderByRelevanceFieldEnum)[keyof typeof DeliveryLocationsOrderByRelevanceFieldEnum]


  export const DriversOrderByRelevanceFieldEnum: {
    FirstName: 'FirstName',
    MiddleName: 'MiddleName',
    LastName: 'LastName',
    Street: 'Street',
    City: 'City',
    ZIP: 'ZIP',
    License: 'License',
    Email: 'Email',
    Phone: 'Phone',
    Notes: 'Notes',
    HireDate: 'HireDate'
  };

  export type DriversOrderByRelevanceFieldEnum = (typeof DriversOrderByRelevanceFieldEnum)[keyof typeof DriversOrderByRelevanceFieldEnum]


  export const InvoicesOrderByRelevanceFieldEnum: {
    CheckNumber: 'CheckNumber',
    PaymentType: 'PaymentType'
  };

  export type InvoicesOrderByRelevanceFieldEnum = (typeof InvoicesOrderByRelevanceFieldEnum)[keyof typeof InvoicesOrderByRelevanceFieldEnum]


  export const LoadTypesOrderByRelevanceFieldEnum: {
    Description: 'Description',
    Notes: 'Notes'
  };

  export type LoadTypesOrderByRelevanceFieldEnum = (typeof LoadTypesOrderByRelevanceFieldEnum)[keyof typeof LoadTypesOrderByRelevanceFieldEnum]


  export const StatesOrderByRelevanceFieldEnum: {
    Name: 'Name',
    Abbreviation: 'Abbreviation'
  };

  export type StatesOrderByRelevanceFieldEnum = (typeof StatesOrderByRelevanceFieldEnum)[keyof typeof StatesOrderByRelevanceFieldEnum]


  export const TrucksOrderByRelevanceFieldEnum: {
    Name: 'Name',
    VIN: 'VIN',
    Notes: 'Notes'
  };

  export type TrucksOrderByRelevanceFieldEnum = (typeof TrucksOrderByRelevanceFieldEnum)[keyof typeof TrucksOrderByRelevanceFieldEnum]


  export const LoadsOrderByRelevanceFieldEnum: {
    Received: 'Received',
    Notes: 'Notes',
    Week: 'Week'
  };

  export type LoadsOrderByRelevanceFieldEnum = (typeof LoadsOrderByRelevanceFieldEnum)[keyof typeof LoadsOrderByRelevanceFieldEnum]


  export const DailiesOrderByRelevanceFieldEnum: {
    Week: 'Week'
  };

  export type DailiesOrderByRelevanceFieldEnum = (typeof DailiesOrderByRelevanceFieldEnum)[keyof typeof DailiesOrderByRelevanceFieldEnum]


  export const WeekliesOrderByRelevanceFieldEnum: {
    Week: 'Week'
  };

  export type WeekliesOrderByRelevanceFieldEnum = (typeof WeekliesOrderByRelevanceFieldEnum)[keyof typeof WeekliesOrderByRelevanceFieldEnum]


  export const PayStubsOrderByRelevanceFieldEnum: {
    CheckNumber: 'CheckNumber',
    Notes: 'Notes'
  };

  export type PayStubsOrderByRelevanceFieldEnum = (typeof PayStubsOrderByRelevanceFieldEnum)[keyof typeof PayStubsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    organization?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringFilter<"User"> | string
    organization?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    organization?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
  }

  export type CustomerLoadTypesWhereInput = {
    AND?: CustomerLoadTypesWhereInput | CustomerLoadTypesWhereInput[]
    OR?: CustomerLoadTypesWhereInput[]
    NOT?: CustomerLoadTypesWhereInput | CustomerLoadTypesWhereInput[]
    ID?: IntFilter<"CustomerLoadTypes"> | number
    CustomerID?: IntFilter<"CustomerLoadTypes"> | number
    LoadTypeID?: IntFilter<"CustomerLoadTypes"> | number
    DateDelivered?: DateTimeFilter<"CustomerLoadTypes"> | Date | string
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    LoadTypes?: XOR<LoadTypesScalarRelationFilter, LoadTypesWhereInput>
  }

  export type CustomerLoadTypesOrderByWithRelationInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
    Customers?: CustomersOrderByWithRelationInput
    LoadTypes?: LoadTypesOrderByWithRelationInput
  }

  export type CustomerLoadTypesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: CustomerLoadTypesWhereInput | CustomerLoadTypesWhereInput[]
    OR?: CustomerLoadTypesWhereInput[]
    NOT?: CustomerLoadTypesWhereInput | CustomerLoadTypesWhereInput[]
    CustomerID?: IntFilter<"CustomerLoadTypes"> | number
    LoadTypeID?: IntFilter<"CustomerLoadTypes"> | number
    DateDelivered?: DateTimeFilter<"CustomerLoadTypes"> | Date | string
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    LoadTypes?: XOR<LoadTypesScalarRelationFilter, LoadTypesWhereInput>
  }, "ID">

  export type CustomerLoadTypesOrderByWithAggregationInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
    _count?: CustomerLoadTypesCountOrderByAggregateInput
    _avg?: CustomerLoadTypesAvgOrderByAggregateInput
    _max?: CustomerLoadTypesMaxOrderByAggregateInput
    _min?: CustomerLoadTypesMinOrderByAggregateInput
    _sum?: CustomerLoadTypesSumOrderByAggregateInput
  }

  export type CustomerLoadTypesScalarWhereWithAggregatesInput = {
    AND?: CustomerLoadTypesScalarWhereWithAggregatesInput | CustomerLoadTypesScalarWhereWithAggregatesInput[]
    OR?: CustomerLoadTypesScalarWhereWithAggregatesInput[]
    NOT?: CustomerLoadTypesScalarWhereWithAggregatesInput | CustomerLoadTypesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"CustomerLoadTypes"> | number
    CustomerID?: IntWithAggregatesFilter<"CustomerLoadTypes"> | number
    LoadTypeID?: IntWithAggregatesFilter<"CustomerLoadTypes"> | number
    DateDelivered?: DateTimeWithAggregatesFilter<"CustomerLoadTypes"> | Date | string
  }

  export type CustomersWhereInput = {
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    ID?: IntFilter<"Customers"> | number
    Name?: StringFilter<"Customers"> | string
    Street?: StringFilter<"Customers"> | string
    City?: StringFilter<"Customers"> | string
    State?: IntFilter<"Customers"> | number
    ZIP?: StringFilter<"Customers"> | string
    Phone?: StringNullableFilter<"Customers"> | string | null
    Email?: StringNullableFilter<"Customers"> | string | null
    Notes?: StringNullableFilter<"Customers"> | string | null
    MainContact?: StringNullableFilter<"Customers"> | string | null
    Deleted?: BoolNullableFilter<"Customers"> | boolean | null
    States?: XOR<StatesScalarRelationFilter, StatesWhereInput>
    CustomerDeliveryLocations?: CustomerDeliveryLocationsListRelationFilter
    CustomerLoadTypes?: CustomerLoadTypesListRelationFilter
    DeliveryLocations?: DeliveryLocationsListRelationFilter
    Invoices?: InvoicesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type CustomersOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    MainContact?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    States?: StatesOrderByWithRelationInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsOrderByRelationAggregateInput
    CustomerLoadTypes?: CustomerLoadTypesOrderByRelationAggregateInput
    DeliveryLocations?: DeliveryLocationsOrderByRelationAggregateInput
    Invoices?: InvoicesOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: CustomersOrderByRelevanceInput
  }

  export type CustomersWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    Name?: StringFilter<"Customers"> | string
    Street?: StringFilter<"Customers"> | string
    City?: StringFilter<"Customers"> | string
    State?: IntFilter<"Customers"> | number
    ZIP?: StringFilter<"Customers"> | string
    Phone?: StringNullableFilter<"Customers"> | string | null
    Email?: StringNullableFilter<"Customers"> | string | null
    Notes?: StringNullableFilter<"Customers"> | string | null
    MainContact?: StringNullableFilter<"Customers"> | string | null
    Deleted?: BoolNullableFilter<"Customers"> | boolean | null
    States?: XOR<StatesScalarRelationFilter, StatesWhereInput>
    CustomerDeliveryLocations?: CustomerDeliveryLocationsListRelationFilter
    CustomerLoadTypes?: CustomerLoadTypesListRelationFilter
    DeliveryLocations?: DeliveryLocationsListRelationFilter
    Invoices?: InvoicesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }, "ID">

  export type CustomersOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    MainContact?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    OR?: CustomersScalarWhereWithAggregatesInput[]
    NOT?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Customers"> | number
    Name?: StringWithAggregatesFilter<"Customers"> | string
    Street?: StringWithAggregatesFilter<"Customers"> | string
    City?: StringWithAggregatesFilter<"Customers"> | string
    State?: IntWithAggregatesFilter<"Customers"> | number
    ZIP?: StringWithAggregatesFilter<"Customers"> | string
    Phone?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    Notes?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    MainContact?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    Deleted?: BoolNullableWithAggregatesFilter<"Customers"> | boolean | null
  }

  export type DeliveryLocationsWhereInput = {
    AND?: DeliveryLocationsWhereInput | DeliveryLocationsWhereInput[]
    OR?: DeliveryLocationsWhereInput[]
    NOT?: DeliveryLocationsWhereInput | DeliveryLocationsWhereInput[]
    ID?: IntFilter<"DeliveryLocations"> | number
    Description?: StringFilter<"DeliveryLocations"> | string
    Deleted?: BoolNullableFilter<"DeliveryLocations"> | boolean | null
    CustomerID?: IntNullableFilter<"DeliveryLocations"> | number | null
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type DeliveryLocationsOrderByWithRelationInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrderInput | SortOrder
    CustomerID?: SortOrderInput | SortOrder
    Customers?: CustomersOrderByWithRelationInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: DeliveryLocationsOrderByRelevanceInput
  }

  export type DeliveryLocationsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: DeliveryLocationsWhereInput | DeliveryLocationsWhereInput[]
    OR?: DeliveryLocationsWhereInput[]
    NOT?: DeliveryLocationsWhereInput | DeliveryLocationsWhereInput[]
    Description?: StringFilter<"DeliveryLocations"> | string
    Deleted?: BoolNullableFilter<"DeliveryLocations"> | boolean | null
    CustomerID?: IntNullableFilter<"DeliveryLocations"> | number | null
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }, "ID">

  export type DeliveryLocationsOrderByWithAggregationInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrderInput | SortOrder
    CustomerID?: SortOrderInput | SortOrder
    _count?: DeliveryLocationsCountOrderByAggregateInput
    _avg?: DeliveryLocationsAvgOrderByAggregateInput
    _max?: DeliveryLocationsMaxOrderByAggregateInput
    _min?: DeliveryLocationsMinOrderByAggregateInput
    _sum?: DeliveryLocationsSumOrderByAggregateInput
  }

  export type DeliveryLocationsScalarWhereWithAggregatesInput = {
    AND?: DeliveryLocationsScalarWhereWithAggregatesInput | DeliveryLocationsScalarWhereWithAggregatesInput[]
    OR?: DeliveryLocationsScalarWhereWithAggregatesInput[]
    NOT?: DeliveryLocationsScalarWhereWithAggregatesInput | DeliveryLocationsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"DeliveryLocations"> | number
    Description?: StringWithAggregatesFilter<"DeliveryLocations"> | string
    Deleted?: BoolNullableWithAggregatesFilter<"DeliveryLocations"> | boolean | null
    CustomerID?: IntNullableWithAggregatesFilter<"DeliveryLocations"> | number | null
  }

  export type DriversWhereInput = {
    AND?: DriversWhereInput | DriversWhereInput[]
    OR?: DriversWhereInput[]
    NOT?: DriversWhereInput | DriversWhereInput[]
    ID?: IntFilter<"Drivers"> | number
    FirstName?: StringFilter<"Drivers"> | string
    MiddleName?: StringNullableFilter<"Drivers"> | string | null
    LastName?: StringFilter<"Drivers"> | string
    Street?: StringNullableFilter<"Drivers"> | string | null
    City?: StringNullableFilter<"Drivers"> | string | null
    State?: IntNullableFilter<"Drivers"> | number | null
    ZIP?: StringNullableFilter<"Drivers"> | string | null
    DOB?: DateTimeNullableFilter<"Drivers"> | Date | string | null
    License?: StringNullableFilter<"Drivers"> | string | null
    Email?: StringNullableFilter<"Drivers"> | string | null
    Phone?: StringNullableFilter<"Drivers"> | string | null
    Notes?: StringNullableFilter<"Drivers"> | string | null
    Deleted?: BoolNullableFilter<"Drivers"> | boolean | null
    HireDate?: StringNullableFilter<"Drivers"> | string | null
    OwnerOperator?: BoolFilter<"Drivers"> | boolean
    States?: XOR<StatesNullableScalarRelationFilter, StatesWhereInput> | null
    Dailies?: DailiesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    PayStubs?: PayStubsListRelationFilter
    TrucksDriven?: TrucksDrivenListRelationFilter
  }

  export type DriversOrderByWithRelationInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrderInput | SortOrder
    LastName?: SortOrder
    Street?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    State?: SortOrderInput | SortOrder
    ZIP?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    License?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    HireDate?: SortOrderInput | SortOrder
    OwnerOperator?: SortOrder
    States?: StatesOrderByWithRelationInput
    Dailies?: DailiesOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    PayStubs?: PayStubsOrderByRelationAggregateInput
    TrucksDriven?: TrucksDrivenOrderByRelationAggregateInput
    _relevance?: DriversOrderByRelevanceInput
  }

  export type DriversWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: DriversWhereInput | DriversWhereInput[]
    OR?: DriversWhereInput[]
    NOT?: DriversWhereInput | DriversWhereInput[]
    FirstName?: StringFilter<"Drivers"> | string
    MiddleName?: StringNullableFilter<"Drivers"> | string | null
    LastName?: StringFilter<"Drivers"> | string
    Street?: StringNullableFilter<"Drivers"> | string | null
    City?: StringNullableFilter<"Drivers"> | string | null
    State?: IntNullableFilter<"Drivers"> | number | null
    ZIP?: StringNullableFilter<"Drivers"> | string | null
    DOB?: DateTimeNullableFilter<"Drivers"> | Date | string | null
    License?: StringNullableFilter<"Drivers"> | string | null
    Email?: StringNullableFilter<"Drivers"> | string | null
    Phone?: StringNullableFilter<"Drivers"> | string | null
    Notes?: StringNullableFilter<"Drivers"> | string | null
    Deleted?: BoolNullableFilter<"Drivers"> | boolean | null
    HireDate?: StringNullableFilter<"Drivers"> | string | null
    OwnerOperator?: BoolFilter<"Drivers"> | boolean
    States?: XOR<StatesNullableScalarRelationFilter, StatesWhereInput> | null
    Dailies?: DailiesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    PayStubs?: PayStubsListRelationFilter
    TrucksDriven?: TrucksDrivenListRelationFilter
  }, "ID">

  export type DriversOrderByWithAggregationInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrderInput | SortOrder
    LastName?: SortOrder
    Street?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    State?: SortOrderInput | SortOrder
    ZIP?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    License?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    HireDate?: SortOrderInput | SortOrder
    OwnerOperator?: SortOrder
    _count?: DriversCountOrderByAggregateInput
    _avg?: DriversAvgOrderByAggregateInput
    _max?: DriversMaxOrderByAggregateInput
    _min?: DriversMinOrderByAggregateInput
    _sum?: DriversSumOrderByAggregateInput
  }

  export type DriversScalarWhereWithAggregatesInput = {
    AND?: DriversScalarWhereWithAggregatesInput | DriversScalarWhereWithAggregatesInput[]
    OR?: DriversScalarWhereWithAggregatesInput[]
    NOT?: DriversScalarWhereWithAggregatesInput | DriversScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Drivers"> | number
    FirstName?: StringWithAggregatesFilter<"Drivers"> | string
    MiddleName?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    LastName?: StringWithAggregatesFilter<"Drivers"> | string
    Street?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    City?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    State?: IntNullableWithAggregatesFilter<"Drivers"> | number | null
    ZIP?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    DOB?: DateTimeNullableWithAggregatesFilter<"Drivers"> | Date | string | null
    License?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    Phone?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    Notes?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    Deleted?: BoolNullableWithAggregatesFilter<"Drivers"> | boolean | null
    HireDate?: StringNullableWithAggregatesFilter<"Drivers"> | string | null
    OwnerOperator?: BoolWithAggregatesFilter<"Drivers"> | boolean
  }

  export type InvoicesWhereInput = {
    AND?: InvoicesWhereInput | InvoicesWhereInput[]
    OR?: InvoicesWhereInput[]
    NOT?: InvoicesWhereInput | InvoicesWhereInput[]
    ID?: IntFilter<"Invoices"> | number
    InvoiceDate?: DateTimeFilter<"Invoices"> | Date | string
    Number?: IntNullableFilter<"Invoices"> | number | null
    CustomerID?: IntFilter<"Invoices"> | number
    TotalAmount?: FloatFilter<"Invoices"> | number
    PaidDate?: DateTimeNullableFilter<"Invoices"> | Date | string | null
    CheckNumber?: StringNullableFilter<"Invoices"> | string | null
    Paid?: BoolNullableFilter<"Invoices"> | boolean | null
    Printed?: BoolNullableFilter<"Invoices"> | boolean | null
    Deleted?: BoolNullableFilter<"Invoices"> | boolean | null
    PaymentType?: StringNullableFilter<"Invoices"> | string | null
    Consolidated?: BoolNullableFilter<"Invoices"> | boolean | null
    ConsolidatedID?: IntNullableFilter<"Invoices"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type InvoicesOrderByWithRelationInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrderInput | SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrderInput | SortOrder
    CheckNumber?: SortOrderInput | SortOrder
    Paid?: SortOrderInput | SortOrder
    Printed?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    PaymentType?: SortOrderInput | SortOrder
    Consolidated?: SortOrderInput | SortOrder
    ConsolidatedID?: SortOrderInput | SortOrder
    Customers?: CustomersOrderByWithRelationInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: InvoicesOrderByRelevanceInput
  }

  export type InvoicesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: InvoicesWhereInput | InvoicesWhereInput[]
    OR?: InvoicesWhereInput[]
    NOT?: InvoicesWhereInput | InvoicesWhereInput[]
    InvoiceDate?: DateTimeFilter<"Invoices"> | Date | string
    Number?: IntNullableFilter<"Invoices"> | number | null
    CustomerID?: IntFilter<"Invoices"> | number
    TotalAmount?: FloatFilter<"Invoices"> | number
    PaidDate?: DateTimeNullableFilter<"Invoices"> | Date | string | null
    CheckNumber?: StringNullableFilter<"Invoices"> | string | null
    Paid?: BoolNullableFilter<"Invoices"> | boolean | null
    Printed?: BoolNullableFilter<"Invoices"> | boolean | null
    Deleted?: BoolNullableFilter<"Invoices"> | boolean | null
    PaymentType?: StringNullableFilter<"Invoices"> | string | null
    Consolidated?: BoolNullableFilter<"Invoices"> | boolean | null
    ConsolidatedID?: IntNullableFilter<"Invoices"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }, "ID">

  export type InvoicesOrderByWithAggregationInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrderInput | SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrderInput | SortOrder
    CheckNumber?: SortOrderInput | SortOrder
    Paid?: SortOrderInput | SortOrder
    Printed?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    PaymentType?: SortOrderInput | SortOrder
    Consolidated?: SortOrderInput | SortOrder
    ConsolidatedID?: SortOrderInput | SortOrder
    _count?: InvoicesCountOrderByAggregateInput
    _avg?: InvoicesAvgOrderByAggregateInput
    _max?: InvoicesMaxOrderByAggregateInput
    _min?: InvoicesMinOrderByAggregateInput
    _sum?: InvoicesSumOrderByAggregateInput
  }

  export type InvoicesScalarWhereWithAggregatesInput = {
    AND?: InvoicesScalarWhereWithAggregatesInput | InvoicesScalarWhereWithAggregatesInput[]
    OR?: InvoicesScalarWhereWithAggregatesInput[]
    NOT?: InvoicesScalarWhereWithAggregatesInput | InvoicesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Invoices"> | number
    InvoiceDate?: DateTimeWithAggregatesFilter<"Invoices"> | Date | string
    Number?: IntNullableWithAggregatesFilter<"Invoices"> | number | null
    CustomerID?: IntWithAggregatesFilter<"Invoices"> | number
    TotalAmount?: FloatWithAggregatesFilter<"Invoices"> | number
    PaidDate?: DateTimeNullableWithAggregatesFilter<"Invoices"> | Date | string | null
    CheckNumber?: StringNullableWithAggregatesFilter<"Invoices"> | string | null
    Paid?: BoolNullableWithAggregatesFilter<"Invoices"> | boolean | null
    Printed?: BoolNullableWithAggregatesFilter<"Invoices"> | boolean | null
    Deleted?: BoolNullableWithAggregatesFilter<"Invoices"> | boolean | null
    PaymentType?: StringNullableWithAggregatesFilter<"Invoices"> | string | null
    Consolidated?: BoolNullableWithAggregatesFilter<"Invoices"> | boolean | null
    ConsolidatedID?: IntNullableWithAggregatesFilter<"Invoices"> | number | null
  }

  export type LoadTypesWhereInput = {
    AND?: LoadTypesWhereInput | LoadTypesWhereInput[]
    OR?: LoadTypesWhereInput[]
    NOT?: LoadTypesWhereInput | LoadTypesWhereInput[]
    ID?: IntFilter<"LoadTypes"> | number
    Description?: StringFilter<"LoadTypes"> | string
    Deleted?: BoolNullableFilter<"LoadTypes"> | boolean | null
    SourceID?: IntNullableFilter<"LoadTypes"> | number | null
    Notes?: StringNullableFilter<"LoadTypes"> | string | null
    CustomerLoadTypes?: CustomerLoadTypesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type LoadTypesOrderByWithRelationInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrderInput | SortOrder
    SourceID?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    CustomerLoadTypes?: CustomerLoadTypesOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: LoadTypesOrderByRelevanceInput
  }

  export type LoadTypesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: LoadTypesWhereInput | LoadTypesWhereInput[]
    OR?: LoadTypesWhereInput[]
    NOT?: LoadTypesWhereInput | LoadTypesWhereInput[]
    Description?: StringFilter<"LoadTypes"> | string
    Deleted?: BoolNullableFilter<"LoadTypes"> | boolean | null
    SourceID?: IntNullableFilter<"LoadTypes"> | number | null
    Notes?: StringNullableFilter<"LoadTypes"> | string | null
    CustomerLoadTypes?: CustomerLoadTypesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }, "ID">

  export type LoadTypesOrderByWithAggregationInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrderInput | SortOrder
    SourceID?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    _count?: LoadTypesCountOrderByAggregateInput
    _avg?: LoadTypesAvgOrderByAggregateInput
    _max?: LoadTypesMaxOrderByAggregateInput
    _min?: LoadTypesMinOrderByAggregateInput
    _sum?: LoadTypesSumOrderByAggregateInput
  }

  export type LoadTypesScalarWhereWithAggregatesInput = {
    AND?: LoadTypesScalarWhereWithAggregatesInput | LoadTypesScalarWhereWithAggregatesInput[]
    OR?: LoadTypesScalarWhereWithAggregatesInput[]
    NOT?: LoadTypesScalarWhereWithAggregatesInput | LoadTypesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"LoadTypes"> | number
    Description?: StringWithAggregatesFilter<"LoadTypes"> | string
    Deleted?: BoolNullableWithAggregatesFilter<"LoadTypes"> | boolean | null
    SourceID?: IntNullableWithAggregatesFilter<"LoadTypes"> | number | null
    Notes?: StringNullableWithAggregatesFilter<"LoadTypes"> | string | null
  }

  export type StatesWhereInput = {
    AND?: StatesWhereInput | StatesWhereInput[]
    OR?: StatesWhereInput[]
    NOT?: StatesWhereInput | StatesWhereInput[]
    ID?: IntFilter<"States"> | number
    Name?: StringFilter<"States"> | string
    Abbreviation?: StringFilter<"States"> | string
    Customers?: CustomersListRelationFilter
    Drivers?: DriversListRelationFilter
  }

  export type StatesOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
    Customers?: CustomersOrderByRelationAggregateInput
    Drivers?: DriversOrderByRelationAggregateInput
    _relevance?: StatesOrderByRelevanceInput
  }

  export type StatesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: StatesWhereInput | StatesWhereInput[]
    OR?: StatesWhereInput[]
    NOT?: StatesWhereInput | StatesWhereInput[]
    Name?: StringFilter<"States"> | string
    Abbreviation?: StringFilter<"States"> | string
    Customers?: CustomersListRelationFilter
    Drivers?: DriversListRelationFilter
  }, "ID">

  export type StatesOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
    _count?: StatesCountOrderByAggregateInput
    _avg?: StatesAvgOrderByAggregateInput
    _max?: StatesMaxOrderByAggregateInput
    _min?: StatesMinOrderByAggregateInput
    _sum?: StatesSumOrderByAggregateInput
  }

  export type StatesScalarWhereWithAggregatesInput = {
    AND?: StatesScalarWhereWithAggregatesInput | StatesScalarWhereWithAggregatesInput[]
    OR?: StatesScalarWhereWithAggregatesInput[]
    NOT?: StatesScalarWhereWithAggregatesInput | StatesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"States"> | number
    Name?: StringWithAggregatesFilter<"States"> | string
    Abbreviation?: StringWithAggregatesFilter<"States"> | string
  }

  export type TrucksWhereInput = {
    AND?: TrucksWhereInput | TrucksWhereInput[]
    OR?: TrucksWhereInput[]
    NOT?: TrucksWhereInput | TrucksWhereInput[]
    ID?: IntFilter<"Trucks"> | number
    Name?: StringFilter<"Trucks"> | string
    VIN?: StringNullableFilter<"Trucks"> | string | null
    Deleted?: BoolNullableFilter<"Trucks"> | boolean | null
    Notes?: StringNullableFilter<"Trucks"> | string | null
    Loads?: LoadsListRelationFilter
    TrucksDriven?: TrucksDrivenListRelationFilter
  }

  export type TrucksOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    Loads?: LoadsOrderByRelationAggregateInput
    TrucksDriven?: TrucksDrivenOrderByRelationAggregateInput
    _relevance?: TrucksOrderByRelevanceInput
  }

  export type TrucksWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: TrucksWhereInput | TrucksWhereInput[]
    OR?: TrucksWhereInput[]
    NOT?: TrucksWhereInput | TrucksWhereInput[]
    Name?: StringFilter<"Trucks"> | string
    VIN?: StringNullableFilter<"Trucks"> | string | null
    Deleted?: BoolNullableFilter<"Trucks"> | boolean | null
    Notes?: StringNullableFilter<"Trucks"> | string | null
    Loads?: LoadsListRelationFilter
    TrucksDriven?: TrucksDrivenListRelationFilter
  }, "ID">

  export type TrucksOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    _count?: TrucksCountOrderByAggregateInput
    _avg?: TrucksAvgOrderByAggregateInput
    _max?: TrucksMaxOrderByAggregateInput
    _min?: TrucksMinOrderByAggregateInput
    _sum?: TrucksSumOrderByAggregateInput
  }

  export type TrucksScalarWhereWithAggregatesInput = {
    AND?: TrucksScalarWhereWithAggregatesInput | TrucksScalarWhereWithAggregatesInput[]
    OR?: TrucksScalarWhereWithAggregatesInput[]
    NOT?: TrucksScalarWhereWithAggregatesInput | TrucksScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Trucks"> | number
    Name?: StringWithAggregatesFilter<"Trucks"> | string
    VIN?: StringNullableWithAggregatesFilter<"Trucks"> | string | null
    Deleted?: BoolNullableWithAggregatesFilter<"Trucks"> | boolean | null
    Notes?: StringNullableWithAggregatesFilter<"Trucks"> | string | null
  }

  export type TrucksDrivenWhereInput = {
    AND?: TrucksDrivenWhereInput | TrucksDrivenWhereInput[]
    OR?: TrucksDrivenWhereInput[]
    NOT?: TrucksDrivenWhereInput | TrucksDrivenWhereInput[]
    ID?: IntFilter<"TrucksDriven"> | number
    TruckID?: IntFilter<"TrucksDriven"> | number
    DriverID?: IntFilter<"TrucksDriven"> | number
    DateDriven?: DateTimeFilter<"TrucksDriven"> | Date | string
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    Trucks?: XOR<TrucksScalarRelationFilter, TrucksWhereInput>
  }

  export type TrucksDrivenOrderByWithRelationInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
    Drivers?: DriversOrderByWithRelationInput
    Trucks?: TrucksOrderByWithRelationInput
  }

  export type TrucksDrivenWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: TrucksDrivenWhereInput | TrucksDrivenWhereInput[]
    OR?: TrucksDrivenWhereInput[]
    NOT?: TrucksDrivenWhereInput | TrucksDrivenWhereInput[]
    TruckID?: IntFilter<"TrucksDriven"> | number
    DriverID?: IntFilter<"TrucksDriven"> | number
    DateDriven?: DateTimeFilter<"TrucksDriven"> | Date | string
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    Trucks?: XOR<TrucksScalarRelationFilter, TrucksWhereInput>
  }, "ID">

  export type TrucksDrivenOrderByWithAggregationInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
    _count?: TrucksDrivenCountOrderByAggregateInput
    _avg?: TrucksDrivenAvgOrderByAggregateInput
    _max?: TrucksDrivenMaxOrderByAggregateInput
    _min?: TrucksDrivenMinOrderByAggregateInput
    _sum?: TrucksDrivenSumOrderByAggregateInput
  }

  export type TrucksDrivenScalarWhereWithAggregatesInput = {
    AND?: TrucksDrivenScalarWhereWithAggregatesInput | TrucksDrivenScalarWhereWithAggregatesInput[]
    OR?: TrucksDrivenScalarWhereWithAggregatesInput[]
    NOT?: TrucksDrivenScalarWhereWithAggregatesInput | TrucksDrivenScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"TrucksDriven"> | number
    TruckID?: IntWithAggregatesFilter<"TrucksDriven"> | number
    DriverID?: IntWithAggregatesFilter<"TrucksDriven"> | number
    DateDriven?: DateTimeWithAggregatesFilter<"TrucksDriven"> | Date | string
  }

  export type LoadsWhereInput = {
    AND?: LoadsWhereInput | LoadsWhereInput[]
    OR?: LoadsWhereInput[]
    NOT?: LoadsWhereInput | LoadsWhereInput[]
    ID?: IntFilter<"Loads"> | number
    StartDate?: DateTimeFilter<"Loads"> | Date | string
    Created?: DateTimeFilter<"Loads"> | Date | string
    Weight?: FloatNullableFilter<"Loads"> | number | null
    Hours?: FloatNullableFilter<"Loads"> | number | null
    TotalRate?: FloatNullableFilter<"Loads"> | number | null
    TotalAmount?: FloatNullableFilter<"Loads"> | number | null
    TruckRate?: FloatNullableFilter<"Loads"> | number | null
    MaterialRate?: FloatNullableFilter<"Loads"> | number | null
    Received?: StringNullableFilter<"Loads"> | string | null
    Notes?: StringNullableFilter<"Loads"> | string | null
    TicketNumber?: IntFilter<"Loads"> | number
    Invoiced?: BoolNullableFilter<"Loads"> | boolean | null
    CustomerID?: IntFilter<"Loads"> | number
    InvoiceID?: IntNullableFilter<"Loads"> | number | null
    LoadTypeID?: IntNullableFilter<"Loads"> | number | null
    DeliveryLocationID?: IntNullableFilter<"Loads"> | number | null
    TruckID?: IntNullableFilter<"Loads"> | number | null
    DriverID?: IntNullableFilter<"Loads"> | number | null
    Deleted?: BoolNullableFilter<"Loads"> | boolean | null
    JobID?: IntNullableFilter<"Loads"> | number | null
    Week?: StringFilter<"Loads"> | string
    DriverRate?: FloatNullableFilter<"Loads"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsNullableScalarRelationFilter, DeliveryLocationsWhereInput> | null
    Drivers?: XOR<DriversNullableScalarRelationFilter, DriversWhereInput> | null
    Invoices?: XOR<InvoicesNullableScalarRelationFilter, InvoicesWhereInput> | null
    Jobs?: XOR<JobsNullableScalarRelationFilter, JobsWhereInput> | null
    LoadTypes?: XOR<LoadTypesNullableScalarRelationFilter, LoadTypesWhereInput> | null
    Trucks?: XOR<TrucksNullableScalarRelationFilter, TrucksWhereInput> | null
  }

  export type LoadsOrderByWithRelationInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrderInput | SortOrder
    Hours?: SortOrderInput | SortOrder
    TotalRate?: SortOrderInput | SortOrder
    TotalAmount?: SortOrderInput | SortOrder
    TruckRate?: SortOrderInput | SortOrder
    MaterialRate?: SortOrderInput | SortOrder
    Received?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrderInput | SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrderInput | SortOrder
    LoadTypeID?: SortOrderInput | SortOrder
    DeliveryLocationID?: SortOrderInput | SortOrder
    TruckID?: SortOrderInput | SortOrder
    DriverID?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    JobID?: SortOrderInput | SortOrder
    Week?: SortOrder
    DriverRate?: SortOrderInput | SortOrder
    Customers?: CustomersOrderByWithRelationInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationInput
    Drivers?: DriversOrderByWithRelationInput
    Invoices?: InvoicesOrderByWithRelationInput
    Jobs?: JobsOrderByWithRelationInput
    LoadTypes?: LoadTypesOrderByWithRelationInput
    Trucks?: TrucksOrderByWithRelationInput
    _relevance?: LoadsOrderByRelevanceInput
  }

  export type LoadsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: LoadsWhereInput | LoadsWhereInput[]
    OR?: LoadsWhereInput[]
    NOT?: LoadsWhereInput | LoadsWhereInput[]
    StartDate?: DateTimeFilter<"Loads"> | Date | string
    Created?: DateTimeFilter<"Loads"> | Date | string
    Weight?: FloatNullableFilter<"Loads"> | number | null
    Hours?: FloatNullableFilter<"Loads"> | number | null
    TotalRate?: FloatNullableFilter<"Loads"> | number | null
    TotalAmount?: FloatNullableFilter<"Loads"> | number | null
    TruckRate?: FloatNullableFilter<"Loads"> | number | null
    MaterialRate?: FloatNullableFilter<"Loads"> | number | null
    Received?: StringNullableFilter<"Loads"> | string | null
    Notes?: StringNullableFilter<"Loads"> | string | null
    TicketNumber?: IntFilter<"Loads"> | number
    Invoiced?: BoolNullableFilter<"Loads"> | boolean | null
    CustomerID?: IntFilter<"Loads"> | number
    InvoiceID?: IntNullableFilter<"Loads"> | number | null
    LoadTypeID?: IntNullableFilter<"Loads"> | number | null
    DeliveryLocationID?: IntNullableFilter<"Loads"> | number | null
    TruckID?: IntNullableFilter<"Loads"> | number | null
    DriverID?: IntNullableFilter<"Loads"> | number | null
    Deleted?: BoolNullableFilter<"Loads"> | boolean | null
    JobID?: IntNullableFilter<"Loads"> | number | null
    Week?: StringFilter<"Loads"> | string
    DriverRate?: FloatNullableFilter<"Loads"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsNullableScalarRelationFilter, DeliveryLocationsWhereInput> | null
    Drivers?: XOR<DriversNullableScalarRelationFilter, DriversWhereInput> | null
    Invoices?: XOR<InvoicesNullableScalarRelationFilter, InvoicesWhereInput> | null
    Jobs?: XOR<JobsNullableScalarRelationFilter, JobsWhereInput> | null
    LoadTypes?: XOR<LoadTypesNullableScalarRelationFilter, LoadTypesWhereInput> | null
    Trucks?: XOR<TrucksNullableScalarRelationFilter, TrucksWhereInput> | null
  }, "ID">

  export type LoadsOrderByWithAggregationInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrderInput | SortOrder
    Hours?: SortOrderInput | SortOrder
    TotalRate?: SortOrderInput | SortOrder
    TotalAmount?: SortOrderInput | SortOrder
    TruckRate?: SortOrderInput | SortOrder
    MaterialRate?: SortOrderInput | SortOrder
    Received?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrderInput | SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrderInput | SortOrder
    LoadTypeID?: SortOrderInput | SortOrder
    DeliveryLocationID?: SortOrderInput | SortOrder
    TruckID?: SortOrderInput | SortOrder
    DriverID?: SortOrderInput | SortOrder
    Deleted?: SortOrderInput | SortOrder
    JobID?: SortOrderInput | SortOrder
    Week?: SortOrder
    DriverRate?: SortOrderInput | SortOrder
    _count?: LoadsCountOrderByAggregateInput
    _avg?: LoadsAvgOrderByAggregateInput
    _max?: LoadsMaxOrderByAggregateInput
    _min?: LoadsMinOrderByAggregateInput
    _sum?: LoadsSumOrderByAggregateInput
  }

  export type LoadsScalarWhereWithAggregatesInput = {
    AND?: LoadsScalarWhereWithAggregatesInput | LoadsScalarWhereWithAggregatesInput[]
    OR?: LoadsScalarWhereWithAggregatesInput[]
    NOT?: LoadsScalarWhereWithAggregatesInput | LoadsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Loads"> | number
    StartDate?: DateTimeWithAggregatesFilter<"Loads"> | Date | string
    Created?: DateTimeWithAggregatesFilter<"Loads"> | Date | string
    Weight?: FloatNullableWithAggregatesFilter<"Loads"> | number | null
    Hours?: FloatNullableWithAggregatesFilter<"Loads"> | number | null
    TotalRate?: FloatNullableWithAggregatesFilter<"Loads"> | number | null
    TotalAmount?: FloatNullableWithAggregatesFilter<"Loads"> | number | null
    TruckRate?: FloatNullableWithAggregatesFilter<"Loads"> | number | null
    MaterialRate?: FloatNullableWithAggregatesFilter<"Loads"> | number | null
    Received?: StringNullableWithAggregatesFilter<"Loads"> | string | null
    Notes?: StringNullableWithAggregatesFilter<"Loads"> | string | null
    TicketNumber?: IntWithAggregatesFilter<"Loads"> | number
    Invoiced?: BoolNullableWithAggregatesFilter<"Loads"> | boolean | null
    CustomerID?: IntWithAggregatesFilter<"Loads"> | number
    InvoiceID?: IntNullableWithAggregatesFilter<"Loads"> | number | null
    LoadTypeID?: IntNullableWithAggregatesFilter<"Loads"> | number | null
    DeliveryLocationID?: IntNullableWithAggregatesFilter<"Loads"> | number | null
    TruckID?: IntNullableWithAggregatesFilter<"Loads"> | number | null
    DriverID?: IntNullableWithAggregatesFilter<"Loads"> | number | null
    Deleted?: BoolNullableWithAggregatesFilter<"Loads"> | boolean | null
    JobID?: IntNullableWithAggregatesFilter<"Loads"> | number | null
    Week?: StringWithAggregatesFilter<"Loads"> | string
    DriverRate?: FloatNullableWithAggregatesFilter<"Loads"> | number | null
  }

  export type CustomerDeliveryLocationsWhereInput = {
    AND?: CustomerDeliveryLocationsWhereInput | CustomerDeliveryLocationsWhereInput[]
    OR?: CustomerDeliveryLocationsWhereInput[]
    NOT?: CustomerDeliveryLocationsWhereInput | CustomerDeliveryLocationsWhereInput[]
    ID?: IntFilter<"CustomerDeliveryLocations"> | number
    CustomerID?: IntFilter<"CustomerDeliveryLocations"> | number
    DeliveryLocationID?: IntFilter<"CustomerDeliveryLocations"> | number
    DateUsed?: DateTimeFilter<"CustomerDeliveryLocations"> | Date | string
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsScalarRelationFilter, DeliveryLocationsWhereInput>
  }

  export type CustomerDeliveryLocationsOrderByWithRelationInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
    Customers?: CustomersOrderByWithRelationInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationInput
  }

  export type CustomerDeliveryLocationsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: CustomerDeliveryLocationsWhereInput | CustomerDeliveryLocationsWhereInput[]
    OR?: CustomerDeliveryLocationsWhereInput[]
    NOT?: CustomerDeliveryLocationsWhereInput | CustomerDeliveryLocationsWhereInput[]
    CustomerID?: IntFilter<"CustomerDeliveryLocations"> | number
    DeliveryLocationID?: IntFilter<"CustomerDeliveryLocations"> | number
    DateUsed?: DateTimeFilter<"CustomerDeliveryLocations"> | Date | string
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsScalarRelationFilter, DeliveryLocationsWhereInput>
  }, "ID">

  export type CustomerDeliveryLocationsOrderByWithAggregationInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
    _count?: CustomerDeliveryLocationsCountOrderByAggregateInput
    _avg?: CustomerDeliveryLocationsAvgOrderByAggregateInput
    _max?: CustomerDeliveryLocationsMaxOrderByAggregateInput
    _min?: CustomerDeliveryLocationsMinOrderByAggregateInput
    _sum?: CustomerDeliveryLocationsSumOrderByAggregateInput
  }

  export type CustomerDeliveryLocationsScalarWhereWithAggregatesInput = {
    AND?: CustomerDeliveryLocationsScalarWhereWithAggregatesInput | CustomerDeliveryLocationsScalarWhereWithAggregatesInput[]
    OR?: CustomerDeliveryLocationsScalarWhereWithAggregatesInput[]
    NOT?: CustomerDeliveryLocationsScalarWhereWithAggregatesInput | CustomerDeliveryLocationsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"CustomerDeliveryLocations"> | number
    CustomerID?: IntWithAggregatesFilter<"CustomerDeliveryLocations"> | number
    DeliveryLocationID?: IntWithAggregatesFilter<"CustomerDeliveryLocations"> | number
    DateUsed?: DateTimeWithAggregatesFilter<"CustomerDeliveryLocations"> | Date | string
  }

  export type DailiesWhereInput = {
    AND?: DailiesWhereInput | DailiesWhereInput[]
    OR?: DailiesWhereInput[]
    NOT?: DailiesWhereInput | DailiesWhereInput[]
    ID?: IntFilter<"Dailies"> | number
    DriverID?: IntFilter<"Dailies"> | number
    Week?: StringFilter<"Dailies"> | string
    LastPrinted?: DateTimeNullableFilter<"Dailies"> | Date | string | null
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    Jobs?: JobsListRelationFilter
  }

  export type DailiesOrderByWithRelationInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrderInput | SortOrder
    Drivers?: DriversOrderByWithRelationInput
    Jobs?: JobsOrderByRelationAggregateInput
    _relevance?: DailiesOrderByRelevanceInput
  }

  export type DailiesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: DailiesWhereInput | DailiesWhereInput[]
    OR?: DailiesWhereInput[]
    NOT?: DailiesWhereInput | DailiesWhereInput[]
    DriverID?: IntFilter<"Dailies"> | number
    Week?: StringFilter<"Dailies"> | string
    LastPrinted?: DateTimeNullableFilter<"Dailies"> | Date | string | null
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    Jobs?: JobsListRelationFilter
  }, "ID">

  export type DailiesOrderByWithAggregationInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrderInput | SortOrder
    _count?: DailiesCountOrderByAggregateInput
    _avg?: DailiesAvgOrderByAggregateInput
    _max?: DailiesMaxOrderByAggregateInput
    _min?: DailiesMinOrderByAggregateInput
    _sum?: DailiesSumOrderByAggregateInput
  }

  export type DailiesScalarWhereWithAggregatesInput = {
    AND?: DailiesScalarWhereWithAggregatesInput | DailiesScalarWhereWithAggregatesInput[]
    OR?: DailiesScalarWhereWithAggregatesInput[]
    NOT?: DailiesScalarWhereWithAggregatesInput | DailiesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Dailies"> | number
    DriverID?: IntWithAggregatesFilter<"Dailies"> | number
    Week?: StringWithAggregatesFilter<"Dailies"> | string
    LastPrinted?: DateTimeNullableWithAggregatesFilter<"Dailies"> | Date | string | null
  }

  export type JobsWhereInput = {
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    ID?: IntFilter<"Jobs"> | number
    DriverID?: IntFilter<"Jobs"> | number
    LoadTypeID?: IntFilter<"Jobs"> | number
    CustomerID?: IntFilter<"Jobs"> | number
    PaidOut?: BoolFilter<"Jobs"> | boolean
    TruckingRevenue?: FloatNullableFilter<"Jobs"> | number | null
    CompanyRevenue?: FloatNullableFilter<"Jobs"> | number | null
    TruckingRate?: FloatFilter<"Jobs"> | number
    CompanyRate?: FloatFilter<"Jobs"> | number
    DeliveryLocationID?: IntFilter<"Jobs"> | number
    WeeklyID?: IntFilter<"Jobs"> | number
    DailyID?: IntFilter<"Jobs"> | number
    MaterialRate?: FloatFilter<"Jobs"> | number
    DriverRate?: FloatFilter<"Jobs"> | number
    PayStubID?: IntNullableFilter<"Jobs"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    Dailies?: XOR<DailiesScalarRelationFilter, DailiesWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsScalarRelationFilter, DeliveryLocationsWhereInput>
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    LoadTypes?: XOR<LoadTypesScalarRelationFilter, LoadTypesWhereInput>
    PayStubs?: XOR<PayStubsNullableScalarRelationFilter, PayStubsWhereInput> | null
    Weeklies?: XOR<WeekliesScalarRelationFilter, WeekliesWhereInput>
    Loads?: LoadsListRelationFilter
  }

  export type JobsOrderByWithRelationInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrderInput | SortOrder
    CompanyRevenue?: SortOrderInput | SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrderInput | SortOrder
    Customers?: CustomersOrderByWithRelationInput
    Dailies?: DailiesOrderByWithRelationInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationInput
    Drivers?: DriversOrderByWithRelationInput
    LoadTypes?: LoadTypesOrderByWithRelationInput
    PayStubs?: PayStubsOrderByWithRelationInput
    Weeklies?: WeekliesOrderByWithRelationInput
    Loads?: LoadsOrderByRelationAggregateInput
  }

  export type JobsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    DriverID?: IntFilter<"Jobs"> | number
    LoadTypeID?: IntFilter<"Jobs"> | number
    CustomerID?: IntFilter<"Jobs"> | number
    PaidOut?: BoolFilter<"Jobs"> | boolean
    TruckingRevenue?: FloatNullableFilter<"Jobs"> | number | null
    CompanyRevenue?: FloatNullableFilter<"Jobs"> | number | null
    TruckingRate?: FloatFilter<"Jobs"> | number
    CompanyRate?: FloatFilter<"Jobs"> | number
    DeliveryLocationID?: IntFilter<"Jobs"> | number
    WeeklyID?: IntFilter<"Jobs"> | number
    DailyID?: IntFilter<"Jobs"> | number
    MaterialRate?: FloatFilter<"Jobs"> | number
    DriverRate?: FloatFilter<"Jobs"> | number
    PayStubID?: IntNullableFilter<"Jobs"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    Dailies?: XOR<DailiesScalarRelationFilter, DailiesWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsScalarRelationFilter, DeliveryLocationsWhereInput>
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    LoadTypes?: XOR<LoadTypesScalarRelationFilter, LoadTypesWhereInput>
    PayStubs?: XOR<PayStubsNullableScalarRelationFilter, PayStubsWhereInput> | null
    Weeklies?: XOR<WeekliesScalarRelationFilter, WeekliesWhereInput>
    Loads?: LoadsListRelationFilter
  }, "ID">

  export type JobsOrderByWithAggregationInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrderInput | SortOrder
    CompanyRevenue?: SortOrderInput | SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrderInput | SortOrder
    _count?: JobsCountOrderByAggregateInput
    _avg?: JobsAvgOrderByAggregateInput
    _max?: JobsMaxOrderByAggregateInput
    _min?: JobsMinOrderByAggregateInput
    _sum?: JobsSumOrderByAggregateInput
  }

  export type JobsScalarWhereWithAggregatesInput = {
    AND?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    OR?: JobsScalarWhereWithAggregatesInput[]
    NOT?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Jobs"> | number
    DriverID?: IntWithAggregatesFilter<"Jobs"> | number
    LoadTypeID?: IntWithAggregatesFilter<"Jobs"> | number
    CustomerID?: IntWithAggregatesFilter<"Jobs"> | number
    PaidOut?: BoolWithAggregatesFilter<"Jobs"> | boolean
    TruckingRevenue?: FloatNullableWithAggregatesFilter<"Jobs"> | number | null
    CompanyRevenue?: FloatNullableWithAggregatesFilter<"Jobs"> | number | null
    TruckingRate?: FloatWithAggregatesFilter<"Jobs"> | number
    CompanyRate?: FloatWithAggregatesFilter<"Jobs"> | number
    DeliveryLocationID?: IntWithAggregatesFilter<"Jobs"> | number
    WeeklyID?: IntWithAggregatesFilter<"Jobs"> | number
    DailyID?: IntWithAggregatesFilter<"Jobs"> | number
    MaterialRate?: FloatWithAggregatesFilter<"Jobs"> | number
    DriverRate?: FloatWithAggregatesFilter<"Jobs"> | number
    PayStubID?: IntNullableWithAggregatesFilter<"Jobs"> | number | null
  }

  export type WeekliesWhereInput = {
    AND?: WeekliesWhereInput | WeekliesWhereInput[]
    OR?: WeekliesWhereInput[]
    NOT?: WeekliesWhereInput | WeekliesWhereInput[]
    ID?: IntFilter<"Weeklies"> | number
    Week?: StringFilter<"Weeklies"> | string
    CustomerID?: IntFilter<"Weeklies"> | number
    InvoiceID?: IntNullableFilter<"Weeklies"> | number | null
    CompanyRate?: FloatNullableFilter<"Weeklies"> | number | null
    Revenue?: FloatNullableFilter<"Weeklies"> | number | null
    LoadTypeID?: IntFilter<"Weeklies"> | number
    DeliveryLocationID?: IntFilter<"Weeklies"> | number
    LastPrinted?: DateTimeNullableFilter<"Weeklies"> | Date | string | null
    TotalWeight?: FloatNullableFilter<"Weeklies"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsScalarRelationFilter, DeliveryLocationsWhereInput>
    Invoices?: XOR<InvoicesNullableScalarRelationFilter, InvoicesWhereInput> | null
    LoadTypes?: XOR<LoadTypesScalarRelationFilter, LoadTypesWhereInput>
    Jobs?: JobsListRelationFilter
  }

  export type WeekliesOrderByWithRelationInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrderInput | SortOrder
    CompanyRate?: SortOrderInput | SortOrder
    Revenue?: SortOrderInput | SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrderInput | SortOrder
    TotalWeight?: SortOrderInput | SortOrder
    Customers?: CustomersOrderByWithRelationInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationInput
    Invoices?: InvoicesOrderByWithRelationInput
    LoadTypes?: LoadTypesOrderByWithRelationInput
    Jobs?: JobsOrderByRelationAggregateInput
    _relevance?: WeekliesOrderByRelevanceInput
  }

  export type WeekliesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WeekliesWhereInput | WeekliesWhereInput[]
    OR?: WeekliesWhereInput[]
    NOT?: WeekliesWhereInput | WeekliesWhereInput[]
    Week?: StringFilter<"Weeklies"> | string
    CustomerID?: IntFilter<"Weeklies"> | number
    InvoiceID?: IntNullableFilter<"Weeklies"> | number | null
    CompanyRate?: FloatNullableFilter<"Weeklies"> | number | null
    Revenue?: FloatNullableFilter<"Weeklies"> | number | null
    LoadTypeID?: IntFilter<"Weeklies"> | number
    DeliveryLocationID?: IntFilter<"Weeklies"> | number
    LastPrinted?: DateTimeNullableFilter<"Weeklies"> | Date | string | null
    TotalWeight?: FloatNullableFilter<"Weeklies"> | number | null
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsScalarRelationFilter, DeliveryLocationsWhereInput>
    Invoices?: XOR<InvoicesNullableScalarRelationFilter, InvoicesWhereInput> | null
    LoadTypes?: XOR<LoadTypesScalarRelationFilter, LoadTypesWhereInput>
    Jobs?: JobsListRelationFilter
  }, "ID">

  export type WeekliesOrderByWithAggregationInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrderInput | SortOrder
    CompanyRate?: SortOrderInput | SortOrder
    Revenue?: SortOrderInput | SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrderInput | SortOrder
    TotalWeight?: SortOrderInput | SortOrder
    _count?: WeekliesCountOrderByAggregateInput
    _avg?: WeekliesAvgOrderByAggregateInput
    _max?: WeekliesMaxOrderByAggregateInput
    _min?: WeekliesMinOrderByAggregateInput
    _sum?: WeekliesSumOrderByAggregateInput
  }

  export type WeekliesScalarWhereWithAggregatesInput = {
    AND?: WeekliesScalarWhereWithAggregatesInput | WeekliesScalarWhereWithAggregatesInput[]
    OR?: WeekliesScalarWhereWithAggregatesInput[]
    NOT?: WeekliesScalarWhereWithAggregatesInput | WeekliesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Weeklies"> | number
    Week?: StringWithAggregatesFilter<"Weeklies"> | string
    CustomerID?: IntWithAggregatesFilter<"Weeklies"> | number
    InvoiceID?: IntNullableWithAggregatesFilter<"Weeklies"> | number | null
    CompanyRate?: FloatNullableWithAggregatesFilter<"Weeklies"> | number | null
    Revenue?: FloatNullableWithAggregatesFilter<"Weeklies"> | number | null
    LoadTypeID?: IntWithAggregatesFilter<"Weeklies"> | number
    DeliveryLocationID?: IntWithAggregatesFilter<"Weeklies"> | number
    LastPrinted?: DateTimeNullableWithAggregatesFilter<"Weeklies"> | Date | string | null
    TotalWeight?: FloatNullableWithAggregatesFilter<"Weeklies"> | number | null
  }

  export type PayStubsWhereInput = {
    AND?: PayStubsWhereInput | PayStubsWhereInput[]
    OR?: PayStubsWhereInput[]
    NOT?: PayStubsWhereInput | PayStubsWhereInput[]
    ID?: IntFilter<"PayStubs"> | number
    Created?: DateTimeFilter<"PayStubs"> | Date | string
    DriverID?: IntFilter<"PayStubs"> | number
    CheckNumber?: StringFilter<"PayStubs"> | string
    Gross?: FloatFilter<"PayStubs"> | number
    Percentage?: FloatFilter<"PayStubs"> | number
    NetTotal?: FloatFilter<"PayStubs"> | number
    LastPrinted?: DateTimeNullableFilter<"PayStubs"> | Date | string | null
    TakeHome?: FloatFilter<"PayStubs"> | number
    Deductions?: FloatFilter<"PayStubs"> | number
    Additions?: FloatFilter<"PayStubs"> | number
    Notes?: StringNullableFilter<"PayStubs"> | string | null
    DepositDate?: DateTimeNullableFilter<"PayStubs"> | Date | string | null
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    Jobs?: JobsListRelationFilter
  }

  export type PayStubsOrderByWithRelationInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrderInput | SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrderInput | SortOrder
    DepositDate?: SortOrderInput | SortOrder
    Drivers?: DriversOrderByWithRelationInput
    Jobs?: JobsOrderByRelationAggregateInput
    _relevance?: PayStubsOrderByRelevanceInput
  }

  export type PayStubsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: PayStubsWhereInput | PayStubsWhereInput[]
    OR?: PayStubsWhereInput[]
    NOT?: PayStubsWhereInput | PayStubsWhereInput[]
    Created?: DateTimeFilter<"PayStubs"> | Date | string
    DriverID?: IntFilter<"PayStubs"> | number
    CheckNumber?: StringFilter<"PayStubs"> | string
    Gross?: FloatFilter<"PayStubs"> | number
    Percentage?: FloatFilter<"PayStubs"> | number
    NetTotal?: FloatFilter<"PayStubs"> | number
    LastPrinted?: DateTimeNullableFilter<"PayStubs"> | Date | string | null
    TakeHome?: FloatFilter<"PayStubs"> | number
    Deductions?: FloatFilter<"PayStubs"> | number
    Additions?: FloatFilter<"PayStubs"> | number
    Notes?: StringNullableFilter<"PayStubs"> | string | null
    DepositDate?: DateTimeNullableFilter<"PayStubs"> | Date | string | null
    Drivers?: XOR<DriversScalarRelationFilter, DriversWhereInput>
    Jobs?: JobsListRelationFilter
  }, "ID">

  export type PayStubsOrderByWithAggregationInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrderInput | SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrderInput | SortOrder
    DepositDate?: SortOrderInput | SortOrder
    _count?: PayStubsCountOrderByAggregateInput
    _avg?: PayStubsAvgOrderByAggregateInput
    _max?: PayStubsMaxOrderByAggregateInput
    _min?: PayStubsMinOrderByAggregateInput
    _sum?: PayStubsSumOrderByAggregateInput
  }

  export type PayStubsScalarWhereWithAggregatesInput = {
    AND?: PayStubsScalarWhereWithAggregatesInput | PayStubsScalarWhereWithAggregatesInput[]
    OR?: PayStubsScalarWhereWithAggregatesInput[]
    NOT?: PayStubsScalarWhereWithAggregatesInput | PayStubsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"PayStubs"> | number
    Created?: DateTimeWithAggregatesFilter<"PayStubs"> | Date | string
    DriverID?: IntWithAggregatesFilter<"PayStubs"> | number
    CheckNumber?: StringWithAggregatesFilter<"PayStubs"> | string
    Gross?: FloatWithAggregatesFilter<"PayStubs"> | number
    Percentage?: FloatWithAggregatesFilter<"PayStubs"> | number
    NetTotal?: FloatWithAggregatesFilter<"PayStubs"> | number
    LastPrinted?: DateTimeNullableWithAggregatesFilter<"PayStubs"> | Date | string | null
    TakeHome?: FloatWithAggregatesFilter<"PayStubs"> | number
    Deductions?: FloatWithAggregatesFilter<"PayStubs"> | number
    Additions?: FloatWithAggregatesFilter<"PayStubs"> | number
    Notes?: StringNullableWithAggregatesFilter<"PayStubs"> | string | null
    DepositDate?: DateTimeNullableWithAggregatesFilter<"PayStubs"> | Date | string | null
  }

  export type UserCreateInput = {
    email: string
    organization: string
    password: string
    username: string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    organization: string
    password: string
    username: string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    organization: string
    password: string
    username: string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerLoadTypesCreateInput = {
    DateDelivered: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerLoadTypesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutCustomerLoadTypesInput
  }

  export type CustomerLoadTypesUncheckedCreateInput = {
    ID?: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesUpdateInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
  }

  export type CustomerLoadTypesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesCreateManyInput = {
    ID?: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesUpdateManyMutationInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersCreateInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersCreateManyInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
  }

  export type CustomersUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CustomersUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeliveryLocationsCreateInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUpdateInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsCreateManyInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
  }

  export type DeliveryLocationsUpdateManyMutationInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeliveryLocationsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DriversCreateInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversUpdateInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type DriversCreateManyInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
  }

  export type DriversUpdateManyMutationInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DriversUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicesCreateInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Customers: CustomersCreateNestedOneWithoutInvoicesInput
    Loads?: LoadsCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUpdateInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutInvoicesNestedInput
    Loads?: LoadsUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesCreateManyInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
  }

  export type InvoicesUpdateManyMutationInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InvoicesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadTypesCreateInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUpdateInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesCreateManyInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
  }

  export type LoadTypesUpdateManyMutationInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoadTypesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StatesCreateInput = {
    Name: string
    Abbreviation: string
    Customers?: CustomersCreateNestedManyWithoutStatesInput
    Drivers?: DriversCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateInput = {
    ID?: number
    Name: string
    Abbreviation: string
    Customers?: CustomersUncheckedCreateNestedManyWithoutStatesInput
    Drivers?: DriversUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUpdateManyWithoutStatesNestedInput
    Drivers?: DriversUpdateManyWithoutStatesNestedInput
  }

  export type StatesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUncheckedUpdateManyWithoutStatesNestedInput
    Drivers?: DriversUncheckedUpdateManyWithoutStatesNestedInput
  }

  export type StatesCreateManyInput = {
    ID?: number
    Name: string
    Abbreviation: string
  }

  export type StatesUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type StatesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type TrucksCreateInput = {
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsCreateNestedManyWithoutTrucksInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUncheckedCreateInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutTrucksInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUpdateManyWithoutTrucksNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUncheckedUpdateManyWithoutTrucksNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksCreateManyInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
  }

  export type TrucksUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrucksUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrucksDrivenCreateInput = {
    DateDriven: Date | string
    Drivers: DriversCreateNestedOneWithoutTrucksDrivenInput
    Trucks: TrucksCreateNestedOneWithoutTrucksDrivenInput
  }

  export type TrucksDrivenUncheckedCreateInput = {
    ID?: number
    TruckID: number
    DriverID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenUpdateInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
    Drivers?: DriversUpdateOneRequiredWithoutTrucksDrivenNestedInput
    Trucks?: TrucksUpdateOneRequiredWithoutTrucksDrivenNestedInput
  }

  export type TrucksDrivenUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrucksDrivenCreateManyInput = {
    ID?: number
    TruckID: number
    DriverID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenUpdateManyMutationInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrucksDrivenUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoadsCreateInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsUpdateInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsCreateManyInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsUpdateManyMutationInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerDeliveryLocationsCreateInput = {
    DateUsed: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerDeliveryLocationsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutCustomerDeliveryLocationsInput
  }

  export type CustomerDeliveryLocationsUncheckedCreateInput = {
    ID?: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsUpdateInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
  }

  export type CustomerDeliveryLocationsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeliveryLocationsCreateManyInput = {
    ID?: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsUpdateManyMutationInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailiesCreateInput = {
    Week: string
    LastPrinted?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutDailiesInput
    Jobs?: JobsCreateNestedManyWithoutDailiesInput
  }

  export type DailiesUncheckedCreateInput = {
    ID?: number
    DriverID: number
    Week: string
    LastPrinted?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutDailiesInput
  }

  export type DailiesUpdateInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutDailiesNestedInput
    Jobs?: JobsUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesCreateManyInput = {
    ID?: number
    DriverID: number
    Week: string
    LastPrinted?: Date | string | null
  }

  export type DailiesUpdateManyMutationInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailiesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobsCreateInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsUpdateInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsCreateManyInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsUpdateManyMutationInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
  }

  export type JobsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeekliesCreateInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUpdateInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesCreateManyInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type WeekliesUpdateManyMutationInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PayStubsCreateInput = {
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutPayStubsInput
    Jobs?: JobsCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsUncheckedCreateInput = {
    ID?: number
    Created?: Date | string
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsUpdateInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutPayStubsNestedInput
    Jobs?: JobsUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverID?: IntFieldUpdateOperationsInput | number
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsCreateManyInput = {
    ID?: number
    Created?: Date | string
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
  }

  export type PayStubsUpdateManyMutationInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayStubsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverID?: IntFieldUpdateOperationsInput | number
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CustomersScalarRelationFilter = {
    is?: CustomersWhereInput
    isNot?: CustomersWhereInput
  }

  export type LoadTypesScalarRelationFilter = {
    is?: LoadTypesWhereInput
    isNot?: LoadTypesWhereInput
  }

  export type CustomerLoadTypesCountOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
  }

  export type CustomerLoadTypesAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
  }

  export type CustomerLoadTypesMaxOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
  }

  export type CustomerLoadTypesMinOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
  }

  export type CustomerLoadTypesSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type StatesScalarRelationFilter = {
    is?: StatesWhereInput
    isNot?: StatesWhereInput
  }

  export type CustomerDeliveryLocationsListRelationFilter = {
    every?: CustomerDeliveryLocationsWhereInput
    some?: CustomerDeliveryLocationsWhereInput
    none?: CustomerDeliveryLocationsWhereInput
  }

  export type CustomerLoadTypesListRelationFilter = {
    every?: CustomerLoadTypesWhereInput
    some?: CustomerLoadTypesWhereInput
    none?: CustomerLoadTypesWhereInput
  }

  export type DeliveryLocationsListRelationFilter = {
    every?: DeliveryLocationsWhereInput
    some?: DeliveryLocationsWhereInput
    none?: DeliveryLocationsWhereInput
  }

  export type InvoicesListRelationFilter = {
    every?: InvoicesWhereInput
    some?: InvoicesWhereInput
    none?: InvoicesWhereInput
  }

  export type JobsListRelationFilter = {
    every?: JobsWhereInput
    some?: JobsWhereInput
    none?: JobsWhereInput
  }

  export type LoadsListRelationFilter = {
    every?: LoadsWhereInput
    some?: LoadsWhereInput
    none?: LoadsWhereInput
  }

  export type WeekliesListRelationFilter = {
    every?: WeekliesWhereInput
    some?: WeekliesWhereInput
    none?: WeekliesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CustomerDeliveryLocationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerLoadTypesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryLocationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoadsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeekliesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersOrderByRelevanceInput = {
    fields: CustomersOrderByRelevanceFieldEnum | CustomersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomersCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CustomersNullableScalarRelationFilter = {
    is?: CustomersWhereInput | null
    isNot?: CustomersWhereInput | null
  }

  export type DeliveryLocationsOrderByRelevanceInput = {
    fields: DeliveryLocationsOrderByRelevanceFieldEnum | DeliveryLocationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryLocationsCountOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsMinOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StatesNullableScalarRelationFilter = {
    is?: StatesWhereInput | null
    isNot?: StatesWhereInput | null
  }

  export type DailiesListRelationFilter = {
    every?: DailiesWhereInput
    some?: DailiesWhereInput
    none?: DailiesWhereInput
  }

  export type PayStubsListRelationFilter = {
    every?: PayStubsWhereInput
    some?: PayStubsWhereInput
    none?: PayStubsWhereInput
  }

  export type TrucksDrivenListRelationFilter = {
    every?: TrucksDrivenWhereInput
    some?: TrucksDrivenWhereInput
    none?: TrucksDrivenWhereInput
  }

  export type DailiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayStubsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrucksDrivenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriversOrderByRelevanceInput = {
    fields: DriversOrderByRelevanceFieldEnum | DriversOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DriversCountOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
  }

  export type DriversAvgOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type DriversMaxOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
  }

  export type DriversMinOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
  }

  export type DriversSumOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InvoicesOrderByRelevanceInput = {
    fields: InvoicesOrderByRelevanceFieldEnum | InvoicesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoicesCountOrderByAggregateInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesAvgOrderByAggregateInput = {
    ID?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesMaxOrderByAggregateInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesMinOrderByAggregateInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesSumOrderByAggregateInput = {
    ID?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LoadTypesOrderByRelevanceInput = {
    fields: LoadTypesOrderByRelevanceFieldEnum | LoadTypesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LoadTypesCountOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
  }

  export type LoadTypesAvgOrderByAggregateInput = {
    ID?: SortOrder
    SourceID?: SortOrder
  }

  export type LoadTypesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
  }

  export type LoadTypesMinOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
  }

  export type LoadTypesSumOrderByAggregateInput = {
    ID?: SortOrder
    SourceID?: SortOrder
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type DriversListRelationFilter = {
    every?: DriversWhereInput
    some?: DriversWhereInput
    none?: DriversWhereInput
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriversOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatesOrderByRelevanceInput = {
    fields: StatesOrderByRelevanceFieldEnum | StatesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StatesCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
  }

  export type StatesAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type StatesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
  }

  export type StatesMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
  }

  export type StatesSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TrucksOrderByRelevanceInput = {
    fields: TrucksOrderByRelevanceFieldEnum | TrucksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TrucksCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
  }

  export type TrucksAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TrucksMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
  }

  export type TrucksMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
  }

  export type TrucksSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type DriversScalarRelationFilter = {
    is?: DriversWhereInput
    isNot?: DriversWhereInput
  }

  export type TrucksScalarRelationFilter = {
    is?: TrucksWhereInput
    isNot?: TrucksWhereInput
  }

  export type TrucksDrivenCountOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
  }

  export type TrucksDrivenAvgOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
  }

  export type TrucksDrivenMaxOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
  }

  export type TrucksDrivenMinOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
  }

  export type TrucksDrivenSumOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DeliveryLocationsNullableScalarRelationFilter = {
    is?: DeliveryLocationsWhereInput | null
    isNot?: DeliveryLocationsWhereInput | null
  }

  export type DriversNullableScalarRelationFilter = {
    is?: DriversWhereInput | null
    isNot?: DriversWhereInput | null
  }

  export type InvoicesNullableScalarRelationFilter = {
    is?: InvoicesWhereInput | null
    isNot?: InvoicesWhereInput | null
  }

  export type JobsNullableScalarRelationFilter = {
    is?: JobsWhereInput | null
    isNot?: JobsWhereInput | null
  }

  export type LoadTypesNullableScalarRelationFilter = {
    is?: LoadTypesWhereInput | null
    isNot?: LoadTypesWhereInput | null
  }

  export type TrucksNullableScalarRelationFilter = {
    is?: TrucksWhereInput | null
    isNot?: TrucksWhereInput | null
  }

  export type LoadsOrderByRelevanceInput = {
    fields: LoadsOrderByRelevanceFieldEnum | LoadsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LoadsCountOrderByAggregateInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsAvgOrderByAggregateInput = {
    ID?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    TicketNumber?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    JobID?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsMaxOrderByAggregateInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsMinOrderByAggregateInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsSumOrderByAggregateInput = {
    ID?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    TicketNumber?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    JobID?: SortOrder
    DriverRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DeliveryLocationsScalarRelationFilter = {
    is?: DeliveryLocationsWhereInput
    isNot?: DeliveryLocationsWhereInput
  }

  export type CustomerDeliveryLocationsCountOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
  }

  export type CustomerDeliveryLocationsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
  }

  export type CustomerDeliveryLocationsMaxOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
  }

  export type CustomerDeliveryLocationsMinOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
  }

  export type CustomerDeliveryLocationsSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
  }

  export type DailiesOrderByRelevanceInput = {
    fields: DailiesOrderByRelevanceFieldEnum | DailiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DailiesCountOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
  }

  export type DailiesAvgOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
  }

  export type DailiesMaxOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
  }

  export type DailiesMinOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
  }

  export type DailiesSumOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
  }

  export type DailiesScalarRelationFilter = {
    is?: DailiesWhereInput
    isNot?: DailiesWhereInput
  }

  export type PayStubsNullableScalarRelationFilter = {
    is?: PayStubsWhereInput | null
    isNot?: PayStubsWhereInput | null
  }

  export type WeekliesScalarRelationFilter = {
    is?: WeekliesWhereInput
    isNot?: WeekliesWhereInput
  }

  export type JobsCountOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsAvgOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsMaxOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsMinOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsSumOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type WeekliesOrderByRelevanceInput = {
    fields: WeekliesOrderByRelevanceFieldEnum | WeekliesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WeekliesCountOrderByAggregateInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesMinOrderByAggregateInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TotalWeight?: SortOrder
  }

  export type PayStubsOrderByRelevanceInput = {
    fields: PayStubsOrderByRelevanceFieldEnum | PayStubsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PayStubsCountOrderByAggregateInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
  }

  export type PayStubsAvgOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
  }

  export type PayStubsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
  }

  export type PayStubsMinOrderByAggregateInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
  }

  export type PayStubsSumOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomersCreateNestedOneWithoutCustomerLoadTypesInput = {
    create?: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerLoadTypesInput
    connect?: CustomersWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutCustomerLoadTypesInput = {
    create?: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutCustomerLoadTypesInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomersUpdateOneRequiredWithoutCustomerLoadTypesNestedInput = {
    create?: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerLoadTypesInput
    upsert?: CustomersUpsertWithoutCustomerLoadTypesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutCustomerLoadTypesInput, CustomersUpdateWithoutCustomerLoadTypesInput>, CustomersUncheckedUpdateWithoutCustomerLoadTypesInput>
  }

  export type LoadTypesUpdateOneRequiredWithoutCustomerLoadTypesNestedInput = {
    create?: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutCustomerLoadTypesInput
    upsert?: LoadTypesUpsertWithoutCustomerLoadTypesInput
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<XOR<LoadTypesUpdateToOneWithWhereWithoutCustomerLoadTypesInput, LoadTypesUpdateWithoutCustomerLoadTypesInput>, LoadTypesUncheckedUpdateWithoutCustomerLoadTypesInput>
  }

  export type StatesCreateNestedOneWithoutCustomersInput = {
    create?: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StatesCreateOrConnectWithoutCustomersInput
    connect?: StatesWhereUniqueInput
  }

  export type CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput> | CustomerDeliveryLocationsCreateWithoutCustomersInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput | CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
  }

  export type CustomerLoadTypesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput> | CustomerLoadTypesCreateWithoutCustomersInput[] | CustomerLoadTypesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutCustomersInput | CustomerLoadTypesCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
  }

  export type DeliveryLocationsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput> | DeliveryLocationsCreateWithoutCustomersInput[] | DeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomersInput | DeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
  }

  export type InvoicesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput> | InvoicesCreateWithoutCustomersInput[] | InvoicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCustomersInput | InvoicesCreateOrConnectWithoutCustomersInput[]
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
  }

  export type JobsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput> | JobsCreateWithoutCustomersInput[] | JobsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutCustomersInput | JobsCreateOrConnectWithoutCustomersInput[]
    createMany?: JobsCreateManyCustomersInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput> | LoadsCreateWithoutCustomersInput[] | LoadsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutCustomersInput | LoadsCreateOrConnectWithoutCustomersInput[]
    createMany?: LoadsCreateManyCustomersInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput> | WeekliesCreateWithoutCustomersInput[] | WeekliesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutCustomersInput | WeekliesCreateOrConnectWithoutCustomersInput[]
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput> | CustomerDeliveryLocationsCreateWithoutCustomersInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput | CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
  }

  export type CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput> | CustomerLoadTypesCreateWithoutCustomersInput[] | CustomerLoadTypesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutCustomersInput | CustomerLoadTypesCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
  }

  export type DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput> | DeliveryLocationsCreateWithoutCustomersInput[] | DeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomersInput | DeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
  }

  export type InvoicesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput> | InvoicesCreateWithoutCustomersInput[] | InvoicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCustomersInput | InvoicesCreateOrConnectWithoutCustomersInput[]
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput> | JobsCreateWithoutCustomersInput[] | JobsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutCustomersInput | JobsCreateOrConnectWithoutCustomersInput[]
    createMany?: JobsCreateManyCustomersInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput> | LoadsCreateWithoutCustomersInput[] | LoadsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutCustomersInput | LoadsCreateOrConnectWithoutCustomersInput[]
    createMany?: LoadsCreateManyCustomersInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput> | WeekliesCreateWithoutCustomersInput[] | WeekliesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutCustomersInput | WeekliesCreateOrConnectWithoutCustomersInput[]
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type StatesUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StatesCreateOrConnectWithoutCustomersInput
    upsert?: StatesUpsertWithoutCustomersInput
    connect?: StatesWhereUniqueInput
    update?: XOR<XOR<StatesUpdateToOneWithWhereWithoutCustomersInput, StatesUpdateWithoutCustomersInput>, StatesUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput> | CustomerDeliveryLocationsCreateWithoutCustomersInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput | CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput | CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    set?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    disconnect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    delete?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    update?: CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput | CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput | CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerDeliveryLocationsScalarWhereInput | CustomerDeliveryLocationsScalarWhereInput[]
  }

  export type CustomerLoadTypesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput> | CustomerLoadTypesCreateWithoutCustomersInput[] | CustomerLoadTypesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutCustomersInput | CustomerLoadTypesCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput | CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    set?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    disconnect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    delete?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    update?: CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput | CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput | CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerLoadTypesScalarWhereInput | CustomerLoadTypesScalarWhereInput[]
  }

  export type DeliveryLocationsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput> | DeliveryLocationsCreateWithoutCustomersInput[] | DeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomersInput | DeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    upsert?: DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput | DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    set?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    disconnect?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    delete?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    connect?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    update?: DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput | DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput | DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: DeliveryLocationsScalarWhereInput | DeliveryLocationsScalarWhereInput[]
  }

  export type InvoicesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput> | InvoicesCreateWithoutCustomersInput[] | InvoicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCustomersInput | InvoicesCreateOrConnectWithoutCustomersInput[]
    upsert?: InvoicesUpsertWithWhereUniqueWithoutCustomersInput | InvoicesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    update?: InvoicesUpdateWithWhereUniqueWithoutCustomersInput | InvoicesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: InvoicesUpdateManyWithWhereWithoutCustomersInput | InvoicesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
  }

  export type JobsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput> | JobsCreateWithoutCustomersInput[] | JobsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutCustomersInput | JobsCreateOrConnectWithoutCustomersInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutCustomersInput | JobsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: JobsCreateManyCustomersInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutCustomersInput | JobsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutCustomersInput | JobsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput> | LoadsCreateWithoutCustomersInput[] | LoadsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutCustomersInput | LoadsCreateOrConnectWithoutCustomersInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutCustomersInput | LoadsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: LoadsCreateManyCustomersInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutCustomersInput | LoadsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutCustomersInput | LoadsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput> | WeekliesCreateWithoutCustomersInput[] | WeekliesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutCustomersInput | WeekliesCreateOrConnectWithoutCustomersInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutCustomersInput | WeekliesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutCustomersInput | WeekliesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutCustomersInput | WeekliesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput> | CustomerDeliveryLocationsCreateWithoutCustomersInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput | CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput | CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    set?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    disconnect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    delete?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    update?: CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput | CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput | CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerDeliveryLocationsScalarWhereInput | CustomerDeliveryLocationsScalarWhereInput[]
  }

  export type CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput> | CustomerLoadTypesCreateWithoutCustomersInput[] | CustomerLoadTypesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutCustomersInput | CustomerLoadTypesCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput | CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    set?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    disconnect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    delete?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    update?: CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput | CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput | CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerLoadTypesScalarWhereInput | CustomerLoadTypesScalarWhereInput[]
  }

  export type DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput> | DeliveryLocationsCreateWithoutCustomersInput[] | DeliveryLocationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomersInput | DeliveryLocationsCreateOrConnectWithoutCustomersInput[]
    upsert?: DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput | DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    set?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    disconnect?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    delete?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    connect?: DeliveryLocationsWhereUniqueInput | DeliveryLocationsWhereUniqueInput[]
    update?: DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput | DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput | DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: DeliveryLocationsScalarWhereInput | DeliveryLocationsScalarWhereInput[]
  }

  export type InvoicesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput> | InvoicesCreateWithoutCustomersInput[] | InvoicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCustomersInput | InvoicesCreateOrConnectWithoutCustomersInput[]
    upsert?: InvoicesUpsertWithWhereUniqueWithoutCustomersInput | InvoicesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    update?: InvoicesUpdateWithWhereUniqueWithoutCustomersInput | InvoicesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: InvoicesUpdateManyWithWhereWithoutCustomersInput | InvoicesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput> | JobsCreateWithoutCustomersInput[] | JobsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutCustomersInput | JobsCreateOrConnectWithoutCustomersInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutCustomersInput | JobsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: JobsCreateManyCustomersInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutCustomersInput | JobsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutCustomersInput | JobsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput> | LoadsCreateWithoutCustomersInput[] | LoadsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutCustomersInput | LoadsCreateOrConnectWithoutCustomersInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutCustomersInput | LoadsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: LoadsCreateManyCustomersInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutCustomersInput | LoadsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutCustomersInput | LoadsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput> | WeekliesCreateWithoutCustomersInput[] | WeekliesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutCustomersInput | WeekliesCreateOrConnectWithoutCustomersInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutCustomersInput | WeekliesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutCustomersInput | WeekliesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutCustomersInput | WeekliesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type CustomersCreateNestedOneWithoutDeliveryLocationsInput = {
    create?: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutDeliveryLocationsInput
    connect?: CustomersWhereUniqueInput
  }

  export type CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput> | CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput | CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
  }

  export type JobsCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput> | JobsCreateWithoutDeliveryLocationsInput[] | JobsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDeliveryLocationsInput | JobsCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput> | LoadsCreateWithoutDeliveryLocationsInput[] | LoadsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDeliveryLocationsInput | LoadsCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput> | WeekliesCreateWithoutDeliveryLocationsInput[] | WeekliesUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutDeliveryLocationsInput | WeekliesCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput> | CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput | CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput> | JobsCreateWithoutDeliveryLocationsInput[] | JobsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDeliveryLocationsInput | JobsCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput> | LoadsCreateWithoutDeliveryLocationsInput[] | LoadsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDeliveryLocationsInput | LoadsCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput> | WeekliesCreateWithoutDeliveryLocationsInput[] | WeekliesUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutDeliveryLocationsInput | WeekliesCreateOrConnectWithoutDeliveryLocationsInput[]
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type CustomersUpdateOneWithoutDeliveryLocationsNestedInput = {
    create?: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutDeliveryLocationsInput
    upsert?: CustomersUpsertWithoutDeliveryLocationsInput
    disconnect?: CustomersWhereInput | boolean
    delete?: CustomersWhereInput | boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutDeliveryLocationsInput, CustomersUpdateWithoutDeliveryLocationsInput>, CustomersUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput> | CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput | CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput | CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    set?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    disconnect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    delete?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    update?: CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput | CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput | CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: CustomerDeliveryLocationsScalarWhereInput | CustomerDeliveryLocationsScalarWhereInput[]
  }

  export type JobsUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput> | JobsCreateWithoutDeliveryLocationsInput[] | JobsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDeliveryLocationsInput | JobsCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput | JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput | JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutDeliveryLocationsInput | JobsUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput> | LoadsCreateWithoutDeliveryLocationsInput[] | LoadsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDeliveryLocationsInput | LoadsCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput | LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput | LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput | LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput> | WeekliesCreateWithoutDeliveryLocationsInput[] | WeekliesUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutDeliveryLocationsInput | WeekliesCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput | WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput | WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput | WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput> | CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput[] | CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput | CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput | CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    set?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    disconnect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    delete?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    connect?: CustomerDeliveryLocationsWhereUniqueInput | CustomerDeliveryLocationsWhereUniqueInput[]
    update?: CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput | CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput | CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: CustomerDeliveryLocationsScalarWhereInput | CustomerDeliveryLocationsScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput> | JobsCreateWithoutDeliveryLocationsInput[] | JobsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDeliveryLocationsInput | JobsCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput | JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput | JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutDeliveryLocationsInput | JobsUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput> | LoadsCreateWithoutDeliveryLocationsInput[] | LoadsUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDeliveryLocationsInput | LoadsCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput | LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput | LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput | LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput> | WeekliesCreateWithoutDeliveryLocationsInput[] | WeekliesUncheckedCreateWithoutDeliveryLocationsInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutDeliveryLocationsInput | WeekliesCreateOrConnectWithoutDeliveryLocationsInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput | WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput[]
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput | WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput | WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type StatesCreateNestedOneWithoutDriversInput = {
    create?: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
    connectOrCreate?: StatesCreateOrConnectWithoutDriversInput
    connect?: StatesWhereUniqueInput
  }

  export type DailiesCreateNestedManyWithoutDriversInput = {
    create?: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput> | DailiesCreateWithoutDriversInput[] | DailiesUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: DailiesCreateOrConnectWithoutDriversInput | DailiesCreateOrConnectWithoutDriversInput[]
    createMany?: DailiesCreateManyDriversInputEnvelope
    connect?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
  }

  export type JobsCreateNestedManyWithoutDriversInput = {
    create?: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput> | JobsCreateWithoutDriversInput[] | JobsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDriversInput | JobsCreateOrConnectWithoutDriversInput[]
    createMany?: JobsCreateManyDriversInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsCreateNestedManyWithoutDriversInput = {
    create?: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput> | LoadsCreateWithoutDriversInput[] | LoadsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDriversInput | LoadsCreateOrConnectWithoutDriversInput[]
    createMany?: LoadsCreateManyDriversInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type PayStubsCreateNestedManyWithoutDriversInput = {
    create?: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput> | PayStubsCreateWithoutDriversInput[] | PayStubsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: PayStubsCreateOrConnectWithoutDriversInput | PayStubsCreateOrConnectWithoutDriversInput[]
    createMany?: PayStubsCreateManyDriversInputEnvelope
    connect?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
  }

  export type TrucksDrivenCreateNestedManyWithoutDriversInput = {
    create?: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput> | TrucksDrivenCreateWithoutDriversInput[] | TrucksDrivenUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutDriversInput | TrucksDrivenCreateOrConnectWithoutDriversInput[]
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
  }

  export type DailiesUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput> | DailiesCreateWithoutDriversInput[] | DailiesUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: DailiesCreateOrConnectWithoutDriversInput | DailiesCreateOrConnectWithoutDriversInput[]
    createMany?: DailiesCreateManyDriversInputEnvelope
    connect?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput> | JobsCreateWithoutDriversInput[] | JobsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDriversInput | JobsCreateOrConnectWithoutDriversInput[]
    createMany?: JobsCreateManyDriversInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput> | LoadsCreateWithoutDriversInput[] | LoadsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDriversInput | LoadsCreateOrConnectWithoutDriversInput[]
    createMany?: LoadsCreateManyDriversInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type PayStubsUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput> | PayStubsCreateWithoutDriversInput[] | PayStubsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: PayStubsCreateOrConnectWithoutDriversInput | PayStubsCreateOrConnectWithoutDriversInput[]
    createMany?: PayStubsCreateManyDriversInputEnvelope
    connect?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
  }

  export type TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput> | TrucksDrivenCreateWithoutDriversInput[] | TrucksDrivenUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutDriversInput | TrucksDrivenCreateOrConnectWithoutDriversInput[]
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StatesUpdateOneWithoutDriversNestedInput = {
    create?: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
    connectOrCreate?: StatesCreateOrConnectWithoutDriversInput
    upsert?: StatesUpsertWithoutDriversInput
    disconnect?: StatesWhereInput | boolean
    delete?: StatesWhereInput | boolean
    connect?: StatesWhereUniqueInput
    update?: XOR<XOR<StatesUpdateToOneWithWhereWithoutDriversInput, StatesUpdateWithoutDriversInput>, StatesUncheckedUpdateWithoutDriversInput>
  }

  export type DailiesUpdateManyWithoutDriversNestedInput = {
    create?: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput> | DailiesCreateWithoutDriversInput[] | DailiesUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: DailiesCreateOrConnectWithoutDriversInput | DailiesCreateOrConnectWithoutDriversInput[]
    upsert?: DailiesUpsertWithWhereUniqueWithoutDriversInput | DailiesUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: DailiesCreateManyDriversInputEnvelope
    set?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    disconnect?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    delete?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    connect?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    update?: DailiesUpdateWithWhereUniqueWithoutDriversInput | DailiesUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: DailiesUpdateManyWithWhereWithoutDriversInput | DailiesUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: DailiesScalarWhereInput | DailiesScalarWhereInput[]
  }

  export type JobsUpdateManyWithoutDriversNestedInput = {
    create?: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput> | JobsCreateWithoutDriversInput[] | JobsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDriversInput | JobsCreateOrConnectWithoutDriversInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutDriversInput | JobsUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: JobsCreateManyDriversInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutDriversInput | JobsUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutDriversInput | JobsUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUpdateManyWithoutDriversNestedInput = {
    create?: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput> | LoadsCreateWithoutDriversInput[] | LoadsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDriversInput | LoadsCreateOrConnectWithoutDriversInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutDriversInput | LoadsUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: LoadsCreateManyDriversInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutDriversInput | LoadsUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutDriversInput | LoadsUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type PayStubsUpdateManyWithoutDriversNestedInput = {
    create?: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput> | PayStubsCreateWithoutDriversInput[] | PayStubsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: PayStubsCreateOrConnectWithoutDriversInput | PayStubsCreateOrConnectWithoutDriversInput[]
    upsert?: PayStubsUpsertWithWhereUniqueWithoutDriversInput | PayStubsUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: PayStubsCreateManyDriversInputEnvelope
    set?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    disconnect?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    delete?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    connect?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    update?: PayStubsUpdateWithWhereUniqueWithoutDriversInput | PayStubsUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: PayStubsUpdateManyWithWhereWithoutDriversInput | PayStubsUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: PayStubsScalarWhereInput | PayStubsScalarWhereInput[]
  }

  export type TrucksDrivenUpdateManyWithoutDriversNestedInput = {
    create?: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput> | TrucksDrivenCreateWithoutDriversInput[] | TrucksDrivenUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutDriversInput | TrucksDrivenCreateOrConnectWithoutDriversInput[]
    upsert?: TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput | TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    set?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    disconnect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    delete?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    update?: TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput | TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: TrucksDrivenUpdateManyWithWhereWithoutDriversInput | TrucksDrivenUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: TrucksDrivenScalarWhereInput | TrucksDrivenScalarWhereInput[]
  }

  export type DailiesUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput> | DailiesCreateWithoutDriversInput[] | DailiesUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: DailiesCreateOrConnectWithoutDriversInput | DailiesCreateOrConnectWithoutDriversInput[]
    upsert?: DailiesUpsertWithWhereUniqueWithoutDriversInput | DailiesUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: DailiesCreateManyDriversInputEnvelope
    set?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    disconnect?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    delete?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    connect?: DailiesWhereUniqueInput | DailiesWhereUniqueInput[]
    update?: DailiesUpdateWithWhereUniqueWithoutDriversInput | DailiesUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: DailiesUpdateManyWithWhereWithoutDriversInput | DailiesUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: DailiesScalarWhereInput | DailiesScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput> | JobsCreateWithoutDriversInput[] | JobsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDriversInput | JobsCreateOrConnectWithoutDriversInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutDriversInput | JobsUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: JobsCreateManyDriversInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutDriversInput | JobsUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutDriversInput | JobsUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput> | LoadsCreateWithoutDriversInput[] | LoadsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutDriversInput | LoadsCreateOrConnectWithoutDriversInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutDriversInput | LoadsUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: LoadsCreateManyDriversInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutDriversInput | LoadsUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutDriversInput | LoadsUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type PayStubsUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput> | PayStubsCreateWithoutDriversInput[] | PayStubsUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: PayStubsCreateOrConnectWithoutDriversInput | PayStubsCreateOrConnectWithoutDriversInput[]
    upsert?: PayStubsUpsertWithWhereUniqueWithoutDriversInput | PayStubsUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: PayStubsCreateManyDriversInputEnvelope
    set?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    disconnect?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    delete?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    connect?: PayStubsWhereUniqueInput | PayStubsWhereUniqueInput[]
    update?: PayStubsUpdateWithWhereUniqueWithoutDriversInput | PayStubsUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: PayStubsUpdateManyWithWhereWithoutDriversInput | PayStubsUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: PayStubsScalarWhereInput | PayStubsScalarWhereInput[]
  }

  export type TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput> | TrucksDrivenCreateWithoutDriversInput[] | TrucksDrivenUncheckedCreateWithoutDriversInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutDriversInput | TrucksDrivenCreateOrConnectWithoutDriversInput[]
    upsert?: TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput | TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput[]
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    set?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    disconnect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    delete?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    update?: TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput | TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput[]
    updateMany?: TrucksDrivenUpdateManyWithWhereWithoutDriversInput | TrucksDrivenUpdateManyWithWhereWithoutDriversInput[]
    deleteMany?: TrucksDrivenScalarWhereInput | TrucksDrivenScalarWhereInput[]
  }

  export type CustomersCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutInvoicesInput
    connect?: CustomersWhereUniqueInput
  }

  export type LoadsCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput> | LoadsCreateWithoutInvoicesInput[] | LoadsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutInvoicesInput | LoadsCreateOrConnectWithoutInvoicesInput[]
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput> | WeekliesCreateWithoutInvoicesInput[] | WeekliesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutInvoicesInput | WeekliesCreateOrConnectWithoutInvoicesInput[]
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type LoadsUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput> | LoadsCreateWithoutInvoicesInput[] | LoadsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutInvoicesInput | LoadsCreateOrConnectWithoutInvoicesInput[]
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput> | WeekliesCreateWithoutInvoicesInput[] | WeekliesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutInvoicesInput | WeekliesCreateOrConnectWithoutInvoicesInput[]
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomersUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutInvoicesInput
    upsert?: CustomersUpsertWithoutInvoicesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutInvoicesInput, CustomersUpdateWithoutInvoicesInput>, CustomersUncheckedUpdateWithoutInvoicesInput>
  }

  export type LoadsUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput> | LoadsCreateWithoutInvoicesInput[] | LoadsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutInvoicesInput | LoadsCreateOrConnectWithoutInvoicesInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutInvoicesInput | LoadsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutInvoicesInput | LoadsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutInvoicesInput | LoadsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput> | WeekliesCreateWithoutInvoicesInput[] | WeekliesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutInvoicesInput | WeekliesCreateOrConnectWithoutInvoicesInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutInvoicesInput | WeekliesUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutInvoicesInput | WeekliesUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutInvoicesInput | WeekliesUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type LoadsUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput> | LoadsCreateWithoutInvoicesInput[] | LoadsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutInvoicesInput | LoadsCreateOrConnectWithoutInvoicesInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutInvoicesInput | LoadsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutInvoicesInput | LoadsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutInvoicesInput | LoadsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput> | WeekliesCreateWithoutInvoicesInput[] | WeekliesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutInvoicesInput | WeekliesCreateOrConnectWithoutInvoicesInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutInvoicesInput | WeekliesUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutInvoicesInput | WeekliesUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutInvoicesInput | WeekliesUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput> | CustomerLoadTypesCreateWithoutLoadTypesInput[] | CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput | CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput[]
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
  }

  export type JobsCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput> | JobsCreateWithoutLoadTypesInput[] | JobsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutLoadTypesInput | JobsCreateOrConnectWithoutLoadTypesInput[]
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput> | LoadsCreateWithoutLoadTypesInput[] | LoadsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutLoadTypesInput | LoadsCreateOrConnectWithoutLoadTypesInput[]
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput> | WeekliesCreateWithoutLoadTypesInput[] | WeekliesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutLoadTypesInput | WeekliesCreateOrConnectWithoutLoadTypesInput[]
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput> | CustomerLoadTypesCreateWithoutLoadTypesInput[] | CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput | CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput[]
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput> | JobsCreateWithoutLoadTypesInput[] | JobsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutLoadTypesInput | JobsCreateOrConnectWithoutLoadTypesInput[]
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type LoadsUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput> | LoadsCreateWithoutLoadTypesInput[] | LoadsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutLoadTypesInput | LoadsCreateOrConnectWithoutLoadTypesInput[]
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput> | WeekliesCreateWithoutLoadTypesInput[] | WeekliesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutLoadTypesInput | WeekliesCreateOrConnectWithoutLoadTypesInput[]
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
  }

  export type CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput> | CustomerLoadTypesCreateWithoutLoadTypesInput[] | CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput | CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput[]
    upsert?: CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput | CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    set?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    disconnect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    delete?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    update?: CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput | CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput | CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: CustomerLoadTypesScalarWhereInput | CustomerLoadTypesScalarWhereInput[]
  }

  export type JobsUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput> | JobsCreateWithoutLoadTypesInput[] | JobsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutLoadTypesInput | JobsCreateOrConnectWithoutLoadTypesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutLoadTypesInput | JobsUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutLoadTypesInput | JobsUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutLoadTypesInput | JobsUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput> | LoadsCreateWithoutLoadTypesInput[] | LoadsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutLoadTypesInput | LoadsCreateOrConnectWithoutLoadTypesInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutLoadTypesInput | LoadsUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutLoadTypesInput | LoadsUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutLoadTypesInput | LoadsUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput> | WeekliesCreateWithoutLoadTypesInput[] | WeekliesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutLoadTypesInput | WeekliesCreateOrConnectWithoutLoadTypesInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput | WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput | WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutLoadTypesInput | WeekliesUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput> | CustomerLoadTypesCreateWithoutLoadTypesInput[] | CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput | CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput[]
    upsert?: CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput | CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    set?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    disconnect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    delete?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    connect?: CustomerLoadTypesWhereUniqueInput | CustomerLoadTypesWhereUniqueInput[]
    update?: CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput | CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput | CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: CustomerLoadTypesScalarWhereInput | CustomerLoadTypesScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput> | JobsCreateWithoutLoadTypesInput[] | JobsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutLoadTypesInput | JobsCreateOrConnectWithoutLoadTypesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutLoadTypesInput | JobsUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutLoadTypesInput | JobsUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutLoadTypesInput | JobsUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput> | LoadsCreateWithoutLoadTypesInput[] | LoadsUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutLoadTypesInput | LoadsCreateOrConnectWithoutLoadTypesInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutLoadTypesInput | LoadsUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutLoadTypesInput | LoadsUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutLoadTypesInput | LoadsUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput> | WeekliesCreateWithoutLoadTypesInput[] | WeekliesUncheckedCreateWithoutLoadTypesInput[]
    connectOrCreate?: WeekliesCreateOrConnectWithoutLoadTypesInput | WeekliesCreateOrConnectWithoutLoadTypesInput[]
    upsert?: WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput | WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput[]
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    set?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    disconnect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    delete?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    connect?: WeekliesWhereUniqueInput | WeekliesWhereUniqueInput[]
    update?: WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput | WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput[]
    updateMany?: WeekliesUpdateManyWithWhereWithoutLoadTypesInput | WeekliesUpdateManyWithWhereWithoutLoadTypesInput[]
    deleteMany?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
  }

  export type CustomersCreateNestedManyWithoutStatesInput = {
    create?: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput> | CustomersCreateWithoutStatesInput[] | CustomersUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStatesInput | CustomersCreateOrConnectWithoutStatesInput[]
    createMany?: CustomersCreateManyStatesInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type DriversCreateNestedManyWithoutStatesInput = {
    create?: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput> | DriversCreateWithoutStatesInput[] | DriversUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: DriversCreateOrConnectWithoutStatesInput | DriversCreateOrConnectWithoutStatesInput[]
    createMany?: DriversCreateManyStatesInputEnvelope
    connect?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
  }

  export type CustomersUncheckedCreateNestedManyWithoutStatesInput = {
    create?: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput> | CustomersCreateWithoutStatesInput[] | CustomersUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStatesInput | CustomersCreateOrConnectWithoutStatesInput[]
    createMany?: CustomersCreateManyStatesInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type DriversUncheckedCreateNestedManyWithoutStatesInput = {
    create?: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput> | DriversCreateWithoutStatesInput[] | DriversUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: DriversCreateOrConnectWithoutStatesInput | DriversCreateOrConnectWithoutStatesInput[]
    createMany?: DriversCreateManyStatesInputEnvelope
    connect?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
  }

  export type CustomersUpdateManyWithoutStatesNestedInput = {
    create?: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput> | CustomersCreateWithoutStatesInput[] | CustomersUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStatesInput | CustomersCreateOrConnectWithoutStatesInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutStatesInput | CustomersUpsertWithWhereUniqueWithoutStatesInput[]
    createMany?: CustomersCreateManyStatesInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutStatesInput | CustomersUpdateWithWhereUniqueWithoutStatesInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutStatesInput | CustomersUpdateManyWithWhereWithoutStatesInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type DriversUpdateManyWithoutStatesNestedInput = {
    create?: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput> | DriversCreateWithoutStatesInput[] | DriversUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: DriversCreateOrConnectWithoutStatesInput | DriversCreateOrConnectWithoutStatesInput[]
    upsert?: DriversUpsertWithWhereUniqueWithoutStatesInput | DriversUpsertWithWhereUniqueWithoutStatesInput[]
    createMany?: DriversCreateManyStatesInputEnvelope
    set?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    disconnect?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    delete?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    connect?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    update?: DriversUpdateWithWhereUniqueWithoutStatesInput | DriversUpdateWithWhereUniqueWithoutStatesInput[]
    updateMany?: DriversUpdateManyWithWhereWithoutStatesInput | DriversUpdateManyWithWhereWithoutStatesInput[]
    deleteMany?: DriversScalarWhereInput | DriversScalarWhereInput[]
  }

  export type CustomersUncheckedUpdateManyWithoutStatesNestedInput = {
    create?: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput> | CustomersCreateWithoutStatesInput[] | CustomersUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStatesInput | CustomersCreateOrConnectWithoutStatesInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutStatesInput | CustomersUpsertWithWhereUniqueWithoutStatesInput[]
    createMany?: CustomersCreateManyStatesInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutStatesInput | CustomersUpdateWithWhereUniqueWithoutStatesInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutStatesInput | CustomersUpdateManyWithWhereWithoutStatesInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type DriversUncheckedUpdateManyWithoutStatesNestedInput = {
    create?: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput> | DriversCreateWithoutStatesInput[] | DriversUncheckedCreateWithoutStatesInput[]
    connectOrCreate?: DriversCreateOrConnectWithoutStatesInput | DriversCreateOrConnectWithoutStatesInput[]
    upsert?: DriversUpsertWithWhereUniqueWithoutStatesInput | DriversUpsertWithWhereUniqueWithoutStatesInput[]
    createMany?: DriversCreateManyStatesInputEnvelope
    set?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    disconnect?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    delete?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    connect?: DriversWhereUniqueInput | DriversWhereUniqueInput[]
    update?: DriversUpdateWithWhereUniqueWithoutStatesInput | DriversUpdateWithWhereUniqueWithoutStatesInput[]
    updateMany?: DriversUpdateManyWithWhereWithoutStatesInput | DriversUpdateManyWithWhereWithoutStatesInput[]
    deleteMany?: DriversScalarWhereInput | DriversScalarWhereInput[]
  }

  export type LoadsCreateNestedManyWithoutTrucksInput = {
    create?: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput> | LoadsCreateWithoutTrucksInput[] | LoadsUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutTrucksInput | LoadsCreateOrConnectWithoutTrucksInput[]
    createMany?: LoadsCreateManyTrucksInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type TrucksDrivenCreateNestedManyWithoutTrucksInput = {
    create?: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput> | TrucksDrivenCreateWithoutTrucksInput[] | TrucksDrivenUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutTrucksInput | TrucksDrivenCreateOrConnectWithoutTrucksInput[]
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
  }

  export type LoadsUncheckedCreateNestedManyWithoutTrucksInput = {
    create?: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput> | LoadsCreateWithoutTrucksInput[] | LoadsUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutTrucksInput | LoadsCreateOrConnectWithoutTrucksInput[]
    createMany?: LoadsCreateManyTrucksInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type TrucksDrivenUncheckedCreateNestedManyWithoutTrucksInput = {
    create?: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput> | TrucksDrivenCreateWithoutTrucksInput[] | TrucksDrivenUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutTrucksInput | TrucksDrivenCreateOrConnectWithoutTrucksInput[]
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
  }

  export type LoadsUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput> | LoadsCreateWithoutTrucksInput[] | LoadsUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutTrucksInput | LoadsCreateOrConnectWithoutTrucksInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutTrucksInput | LoadsUpsertWithWhereUniqueWithoutTrucksInput[]
    createMany?: LoadsCreateManyTrucksInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutTrucksInput | LoadsUpdateWithWhereUniqueWithoutTrucksInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutTrucksInput | LoadsUpdateManyWithWhereWithoutTrucksInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type TrucksDrivenUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput> | TrucksDrivenCreateWithoutTrucksInput[] | TrucksDrivenUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutTrucksInput | TrucksDrivenCreateOrConnectWithoutTrucksInput[]
    upsert?: TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput | TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput[]
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    set?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    disconnect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    delete?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    update?: TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput | TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput[]
    updateMany?: TrucksDrivenUpdateManyWithWhereWithoutTrucksInput | TrucksDrivenUpdateManyWithWhereWithoutTrucksInput[]
    deleteMany?: TrucksDrivenScalarWhereInput | TrucksDrivenScalarWhereInput[]
  }

  export type LoadsUncheckedUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput> | LoadsCreateWithoutTrucksInput[] | LoadsUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutTrucksInput | LoadsCreateOrConnectWithoutTrucksInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutTrucksInput | LoadsUpsertWithWhereUniqueWithoutTrucksInput[]
    createMany?: LoadsCreateManyTrucksInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutTrucksInput | LoadsUpdateWithWhereUniqueWithoutTrucksInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutTrucksInput | LoadsUpdateManyWithWhereWithoutTrucksInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type TrucksDrivenUncheckedUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput> | TrucksDrivenCreateWithoutTrucksInput[] | TrucksDrivenUncheckedCreateWithoutTrucksInput[]
    connectOrCreate?: TrucksDrivenCreateOrConnectWithoutTrucksInput | TrucksDrivenCreateOrConnectWithoutTrucksInput[]
    upsert?: TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput | TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput[]
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    set?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    disconnect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    delete?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    connect?: TrucksDrivenWhereUniqueInput | TrucksDrivenWhereUniqueInput[]
    update?: TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput | TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput[]
    updateMany?: TrucksDrivenUpdateManyWithWhereWithoutTrucksInput | TrucksDrivenUpdateManyWithWhereWithoutTrucksInput[]
    deleteMany?: TrucksDrivenScalarWhereInput | TrucksDrivenScalarWhereInput[]
  }

  export type DriversCreateNestedOneWithoutTrucksDrivenInput = {
    create?: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: DriversCreateOrConnectWithoutTrucksDrivenInput
    connect?: DriversWhereUniqueInput
  }

  export type TrucksCreateNestedOneWithoutTrucksDrivenInput = {
    create?: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutTrucksDrivenInput
    connect?: TrucksWhereUniqueInput
  }

  export type DriversUpdateOneRequiredWithoutTrucksDrivenNestedInput = {
    create?: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: DriversCreateOrConnectWithoutTrucksDrivenInput
    upsert?: DriversUpsertWithoutTrucksDrivenInput
    connect?: DriversWhereUniqueInput
    update?: XOR<XOR<DriversUpdateToOneWithWhereWithoutTrucksDrivenInput, DriversUpdateWithoutTrucksDrivenInput>, DriversUncheckedUpdateWithoutTrucksDrivenInput>
  }

  export type TrucksUpdateOneRequiredWithoutTrucksDrivenNestedInput = {
    create?: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutTrucksDrivenInput
    upsert?: TrucksUpsertWithoutTrucksDrivenInput
    connect?: TrucksWhereUniqueInput
    update?: XOR<XOR<TrucksUpdateToOneWithWhereWithoutTrucksDrivenInput, TrucksUpdateWithoutTrucksDrivenInput>, TrucksUncheckedUpdateWithoutTrucksDrivenInput>
  }

  export type CustomersCreateNestedOneWithoutLoadsInput = {
    create?: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutLoadsInput
    connect?: CustomersWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutLoadsInput = {
    create?: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutLoadsInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type DriversCreateNestedOneWithoutLoadsInput = {
    create?: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutLoadsInput
    connect?: DriversWhereUniqueInput
  }

  export type InvoicesCreateNestedOneWithoutLoadsInput = {
    create?: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutLoadsInput
    connect?: InvoicesWhereUniqueInput
  }

  export type JobsCreateNestedOneWithoutLoadsInput = {
    create?: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: JobsCreateOrConnectWithoutLoadsInput
    connect?: JobsWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutLoadsInput = {
    create?: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutLoadsInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type TrucksCreateNestedOneWithoutLoadsInput = {
    create?: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutLoadsInput
    connect?: TrucksWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomersUpdateOneRequiredWithoutLoadsNestedInput = {
    create?: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutLoadsInput
    upsert?: CustomersUpsertWithoutLoadsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutLoadsInput, CustomersUpdateWithoutLoadsInput>, CustomersUncheckedUpdateWithoutLoadsInput>
  }

  export type DeliveryLocationsUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutLoadsInput
    upsert?: DeliveryLocationsUpsertWithoutLoadsInput
    disconnect?: DeliveryLocationsWhereInput | boolean
    delete?: DeliveryLocationsWhereInput | boolean
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<XOR<DeliveryLocationsUpdateToOneWithWhereWithoutLoadsInput, DeliveryLocationsUpdateWithoutLoadsInput>, DeliveryLocationsUncheckedUpdateWithoutLoadsInput>
  }

  export type DriversUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutLoadsInput
    upsert?: DriversUpsertWithoutLoadsInput
    disconnect?: DriversWhereInput | boolean
    delete?: DriversWhereInput | boolean
    connect?: DriversWhereUniqueInput
    update?: XOR<XOR<DriversUpdateToOneWithWhereWithoutLoadsInput, DriversUpdateWithoutLoadsInput>, DriversUncheckedUpdateWithoutLoadsInput>
  }

  export type InvoicesUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutLoadsInput
    upsert?: InvoicesUpsertWithoutLoadsInput
    disconnect?: InvoicesWhereInput | boolean
    delete?: InvoicesWhereInput | boolean
    connect?: InvoicesWhereUniqueInput
    update?: XOR<XOR<InvoicesUpdateToOneWithWhereWithoutLoadsInput, InvoicesUpdateWithoutLoadsInput>, InvoicesUncheckedUpdateWithoutLoadsInput>
  }

  export type JobsUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: JobsCreateOrConnectWithoutLoadsInput
    upsert?: JobsUpsertWithoutLoadsInput
    disconnect?: JobsWhereInput | boolean
    delete?: JobsWhereInput | boolean
    connect?: JobsWhereUniqueInput
    update?: XOR<XOR<JobsUpdateToOneWithWhereWithoutLoadsInput, JobsUpdateWithoutLoadsInput>, JobsUncheckedUpdateWithoutLoadsInput>
  }

  export type LoadTypesUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutLoadsInput
    upsert?: LoadTypesUpsertWithoutLoadsInput
    disconnect?: LoadTypesWhereInput | boolean
    delete?: LoadTypesWhereInput | boolean
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<XOR<LoadTypesUpdateToOneWithWhereWithoutLoadsInput, LoadTypesUpdateWithoutLoadsInput>, LoadTypesUncheckedUpdateWithoutLoadsInput>
  }

  export type TrucksUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutLoadsInput
    upsert?: TrucksUpsertWithoutLoadsInput
    disconnect?: TrucksWhereInput | boolean
    delete?: TrucksWhereInput | boolean
    connect?: TrucksWhereUniqueInput
    update?: XOR<XOR<TrucksUpdateToOneWithWhereWithoutLoadsInput, TrucksUpdateWithoutLoadsInput>, TrucksUncheckedUpdateWithoutLoadsInput>
  }

  export type CustomersCreateNestedOneWithoutCustomerDeliveryLocationsInput = {
    create?: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerDeliveryLocationsInput
    connect?: CustomersWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutCustomerDeliveryLocationsInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomerDeliveryLocationsInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type CustomersUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput = {
    create?: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerDeliveryLocationsInput
    upsert?: CustomersUpsertWithoutCustomerDeliveryLocationsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutCustomerDeliveryLocationsInput, CustomersUpdateWithoutCustomerDeliveryLocationsInput>, CustomersUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
  }

  export type DeliveryLocationsUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomerDeliveryLocationsInput
    upsert?: DeliveryLocationsUpsertWithoutCustomerDeliveryLocationsInput
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<XOR<DeliveryLocationsUpdateToOneWithWhereWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUpdateWithoutCustomerDeliveryLocationsInput>, DeliveryLocationsUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
  }

  export type DriversCreateNestedOneWithoutDailiesInput = {
    create?: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
    connectOrCreate?: DriversCreateOrConnectWithoutDailiesInput
    connect?: DriversWhereUniqueInput
  }

  export type JobsCreateNestedManyWithoutDailiesInput = {
    create?: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput> | JobsCreateWithoutDailiesInput[] | JobsUncheckedCreateWithoutDailiesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDailiesInput | JobsCreateOrConnectWithoutDailiesInput[]
    createMany?: JobsCreateManyDailiesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutDailiesInput = {
    create?: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput> | JobsCreateWithoutDailiesInput[] | JobsUncheckedCreateWithoutDailiesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDailiesInput | JobsCreateOrConnectWithoutDailiesInput[]
    createMany?: JobsCreateManyDailiesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type DriversUpdateOneRequiredWithoutDailiesNestedInput = {
    create?: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
    connectOrCreate?: DriversCreateOrConnectWithoutDailiesInput
    upsert?: DriversUpsertWithoutDailiesInput
    connect?: DriversWhereUniqueInput
    update?: XOR<XOR<DriversUpdateToOneWithWhereWithoutDailiesInput, DriversUpdateWithoutDailiesInput>, DriversUncheckedUpdateWithoutDailiesInput>
  }

  export type JobsUpdateManyWithoutDailiesNestedInput = {
    create?: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput> | JobsCreateWithoutDailiesInput[] | JobsUncheckedCreateWithoutDailiesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDailiesInput | JobsCreateOrConnectWithoutDailiesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutDailiesInput | JobsUpsertWithWhereUniqueWithoutDailiesInput[]
    createMany?: JobsCreateManyDailiesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutDailiesInput | JobsUpdateWithWhereUniqueWithoutDailiesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutDailiesInput | JobsUpdateManyWithWhereWithoutDailiesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutDailiesNestedInput = {
    create?: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput> | JobsCreateWithoutDailiesInput[] | JobsUncheckedCreateWithoutDailiesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutDailiesInput | JobsCreateOrConnectWithoutDailiesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutDailiesInput | JobsUpsertWithWhereUniqueWithoutDailiesInput[]
    createMany?: JobsCreateManyDailiesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutDailiesInput | JobsUpdateWithWhereUniqueWithoutDailiesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutDailiesInput | JobsUpdateManyWithWhereWithoutDailiesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type CustomersCreateNestedOneWithoutJobsInput = {
    create?: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutJobsInput
    connect?: CustomersWhereUniqueInput
  }

  export type DailiesCreateNestedOneWithoutJobsInput = {
    create?: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DailiesCreateOrConnectWithoutJobsInput
    connect?: DailiesWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutJobsInput = {
    create?: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutJobsInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type DriversCreateNestedOneWithoutJobsInput = {
    create?: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutJobsInput
    connect?: DriversWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutJobsInput = {
    create?: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutJobsInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type PayStubsCreateNestedOneWithoutJobsInput = {
    create?: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayStubsCreateOrConnectWithoutJobsInput
    connect?: PayStubsWhereUniqueInput
  }

  export type WeekliesCreateNestedOneWithoutJobsInput = {
    create?: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: WeekliesCreateOrConnectWithoutJobsInput
    connect?: WeekliesWhereUniqueInput
  }

  export type LoadsCreateNestedManyWithoutJobsInput = {
    create?: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput> | LoadsCreateWithoutJobsInput[] | LoadsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutJobsInput | LoadsCreateOrConnectWithoutJobsInput[]
    createMany?: LoadsCreateManyJobsInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type LoadsUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput> | LoadsCreateWithoutJobsInput[] | LoadsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutJobsInput | LoadsCreateOrConnectWithoutJobsInput[]
    createMany?: LoadsCreateManyJobsInputEnvelope
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
  }

  export type CustomersUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutJobsInput
    upsert?: CustomersUpsertWithoutJobsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutJobsInput, CustomersUpdateWithoutJobsInput>, CustomersUncheckedUpdateWithoutJobsInput>
  }

  export type DailiesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DailiesCreateOrConnectWithoutJobsInput
    upsert?: DailiesUpsertWithoutJobsInput
    connect?: DailiesWhereUniqueInput
    update?: XOR<XOR<DailiesUpdateToOneWithWhereWithoutJobsInput, DailiesUpdateWithoutJobsInput>, DailiesUncheckedUpdateWithoutJobsInput>
  }

  export type DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutJobsInput
    upsert?: DeliveryLocationsUpsertWithoutJobsInput
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<XOR<DeliveryLocationsUpdateToOneWithWhereWithoutJobsInput, DeliveryLocationsUpdateWithoutJobsInput>, DeliveryLocationsUncheckedUpdateWithoutJobsInput>
  }

  export type DriversUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutJobsInput
    upsert?: DriversUpsertWithoutJobsInput
    connect?: DriversWhereUniqueInput
    update?: XOR<XOR<DriversUpdateToOneWithWhereWithoutJobsInput, DriversUpdateWithoutJobsInput>, DriversUncheckedUpdateWithoutJobsInput>
  }

  export type LoadTypesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutJobsInput
    upsert?: LoadTypesUpsertWithoutJobsInput
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<XOR<LoadTypesUpdateToOneWithWhereWithoutJobsInput, LoadTypesUpdateWithoutJobsInput>, LoadTypesUncheckedUpdateWithoutJobsInput>
  }

  export type PayStubsUpdateOneWithoutJobsNestedInput = {
    create?: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayStubsCreateOrConnectWithoutJobsInput
    upsert?: PayStubsUpsertWithoutJobsInput
    disconnect?: PayStubsWhereInput | boolean
    delete?: PayStubsWhereInput | boolean
    connect?: PayStubsWhereUniqueInput
    update?: XOR<XOR<PayStubsUpdateToOneWithWhereWithoutJobsInput, PayStubsUpdateWithoutJobsInput>, PayStubsUncheckedUpdateWithoutJobsInput>
  }

  export type WeekliesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: WeekliesCreateOrConnectWithoutJobsInput
    upsert?: WeekliesUpsertWithoutJobsInput
    connect?: WeekliesWhereUniqueInput
    update?: XOR<XOR<WeekliesUpdateToOneWithWhereWithoutJobsInput, WeekliesUpdateWithoutJobsInput>, WeekliesUncheckedUpdateWithoutJobsInput>
  }

  export type LoadsUpdateManyWithoutJobsNestedInput = {
    create?: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput> | LoadsCreateWithoutJobsInput[] | LoadsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutJobsInput | LoadsCreateOrConnectWithoutJobsInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutJobsInput | LoadsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: LoadsCreateManyJobsInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutJobsInput | LoadsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutJobsInput | LoadsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type LoadsUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput> | LoadsCreateWithoutJobsInput[] | LoadsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: LoadsCreateOrConnectWithoutJobsInput | LoadsCreateOrConnectWithoutJobsInput[]
    upsert?: LoadsUpsertWithWhereUniqueWithoutJobsInput | LoadsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: LoadsCreateManyJobsInputEnvelope
    set?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    disconnect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    delete?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    connect?: LoadsWhereUniqueInput | LoadsWhereUniqueInput[]
    update?: LoadsUpdateWithWhereUniqueWithoutJobsInput | LoadsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: LoadsUpdateManyWithWhereWithoutJobsInput | LoadsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
  }

  export type CustomersCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutWeekliesInput
    connect?: CustomersWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutWeekliesInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type InvoicesCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutWeekliesInput
    connect?: InvoicesWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutWeekliesInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type JobsCreateNestedManyWithoutWeekliesInput = {
    create?: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput> | JobsCreateWithoutWeekliesInput[] | JobsUncheckedCreateWithoutWeekliesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutWeekliesInput | JobsCreateOrConnectWithoutWeekliesInput[]
    createMany?: JobsCreateManyWeekliesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutWeekliesInput = {
    create?: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput> | JobsCreateWithoutWeekliesInput[] | JobsUncheckedCreateWithoutWeekliesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutWeekliesInput | JobsCreateOrConnectWithoutWeekliesInput[]
    createMany?: JobsCreateManyWeekliesInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type CustomersUpdateOneRequiredWithoutWeekliesNestedInput = {
    create?: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutWeekliesInput
    upsert?: CustomersUpsertWithoutWeekliesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutWeekliesInput, CustomersUpdateWithoutWeekliesInput>, CustomersUncheckedUpdateWithoutWeekliesInput>
  }

  export type DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutWeekliesInput
    upsert?: DeliveryLocationsUpsertWithoutWeekliesInput
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<XOR<DeliveryLocationsUpdateToOneWithWhereWithoutWeekliesInput, DeliveryLocationsUpdateWithoutWeekliesInput>, DeliveryLocationsUncheckedUpdateWithoutWeekliesInput>
  }

  export type InvoicesUpdateOneWithoutWeekliesNestedInput = {
    create?: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutWeekliesInput
    upsert?: InvoicesUpsertWithoutWeekliesInput
    disconnect?: InvoicesWhereInput | boolean
    delete?: InvoicesWhereInput | boolean
    connect?: InvoicesWhereUniqueInput
    update?: XOR<XOR<InvoicesUpdateToOneWithWhereWithoutWeekliesInput, InvoicesUpdateWithoutWeekliesInput>, InvoicesUncheckedUpdateWithoutWeekliesInput>
  }

  export type LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput = {
    create?: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutWeekliesInput
    upsert?: LoadTypesUpsertWithoutWeekliesInput
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<XOR<LoadTypesUpdateToOneWithWhereWithoutWeekliesInput, LoadTypesUpdateWithoutWeekliesInput>, LoadTypesUncheckedUpdateWithoutWeekliesInput>
  }

  export type JobsUpdateManyWithoutWeekliesNestedInput = {
    create?: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput> | JobsCreateWithoutWeekliesInput[] | JobsUncheckedCreateWithoutWeekliesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutWeekliesInput | JobsCreateOrConnectWithoutWeekliesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutWeekliesInput | JobsUpsertWithWhereUniqueWithoutWeekliesInput[]
    createMany?: JobsCreateManyWeekliesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutWeekliesInput | JobsUpdateWithWhereUniqueWithoutWeekliesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutWeekliesInput | JobsUpdateManyWithWhereWithoutWeekliesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutWeekliesNestedInput = {
    create?: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput> | JobsCreateWithoutWeekliesInput[] | JobsUncheckedCreateWithoutWeekliesInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutWeekliesInput | JobsCreateOrConnectWithoutWeekliesInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutWeekliesInput | JobsUpsertWithWhereUniqueWithoutWeekliesInput[]
    createMany?: JobsCreateManyWeekliesInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutWeekliesInput | JobsUpdateWithWhereUniqueWithoutWeekliesInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutWeekliesInput | JobsUpdateManyWithWhereWithoutWeekliesInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type DriversCreateNestedOneWithoutPayStubsInput = {
    create?: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutPayStubsInput
    connect?: DriversWhereUniqueInput
  }

  export type JobsCreateNestedManyWithoutPayStubsInput = {
    create?: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput> | JobsCreateWithoutPayStubsInput[] | JobsUncheckedCreateWithoutPayStubsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutPayStubsInput | JobsCreateOrConnectWithoutPayStubsInput[]
    createMany?: JobsCreateManyPayStubsInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutPayStubsInput = {
    create?: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput> | JobsCreateWithoutPayStubsInput[] | JobsUncheckedCreateWithoutPayStubsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutPayStubsInput | JobsCreateOrConnectWithoutPayStubsInput[]
    createMany?: JobsCreateManyPayStubsInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type DriversUpdateOneRequiredWithoutPayStubsNestedInput = {
    create?: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutPayStubsInput
    upsert?: DriversUpsertWithoutPayStubsInput
    connect?: DriversWhereUniqueInput
    update?: XOR<XOR<DriversUpdateToOneWithWhereWithoutPayStubsInput, DriversUpdateWithoutPayStubsInput>, DriversUncheckedUpdateWithoutPayStubsInput>
  }

  export type JobsUpdateManyWithoutPayStubsNestedInput = {
    create?: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput> | JobsCreateWithoutPayStubsInput[] | JobsUncheckedCreateWithoutPayStubsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutPayStubsInput | JobsCreateOrConnectWithoutPayStubsInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutPayStubsInput | JobsUpsertWithWhereUniqueWithoutPayStubsInput[]
    createMany?: JobsCreateManyPayStubsInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutPayStubsInput | JobsUpdateWithWhereUniqueWithoutPayStubsInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutPayStubsInput | JobsUpdateManyWithWhereWithoutPayStubsInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutPayStubsNestedInput = {
    create?: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput> | JobsCreateWithoutPayStubsInput[] | JobsUncheckedCreateWithoutPayStubsInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutPayStubsInput | JobsCreateOrConnectWithoutPayStubsInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutPayStubsInput | JobsUpsertWithWhereUniqueWithoutPayStubsInput[]
    createMany?: JobsCreateManyPayStubsInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutPayStubsInput | JobsUpdateWithWhereUniqueWithoutPayStubsInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutPayStubsInput | JobsUpdateManyWithWhereWithoutPayStubsInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CustomersCreateWithoutCustomerLoadTypesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutCustomerLoadTypesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutCustomerLoadTypesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
  }

  export type LoadTypesCreateWithoutCustomerLoadTypesInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutCustomerLoadTypesInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
  }

  export type CustomersUpsertWithoutCustomerLoadTypesInput = {
    update: XOR<CustomersUpdateWithoutCustomerLoadTypesInput, CustomersUncheckedUpdateWithoutCustomerLoadTypesInput>
    create: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutCustomerLoadTypesInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutCustomerLoadTypesInput, CustomersUncheckedUpdateWithoutCustomerLoadTypesInput>
  }

  export type CustomersUpdateWithoutCustomerLoadTypesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type LoadTypesUpsertWithoutCustomerLoadTypesInput = {
    update: XOR<LoadTypesUpdateWithoutCustomerLoadTypesInput, LoadTypesUncheckedUpdateWithoutCustomerLoadTypesInput>
    create: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
    where?: LoadTypesWhereInput
  }

  export type LoadTypesUpdateToOneWithWhereWithoutCustomerLoadTypesInput = {
    where?: LoadTypesWhereInput
    data: XOR<LoadTypesUpdateWithoutCustomerLoadTypesInput, LoadTypesUncheckedUpdateWithoutCustomerLoadTypesInput>
  }

  export type LoadTypesUpdateWithoutCustomerLoadTypesInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutCustomerLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type StatesCreateWithoutCustomersInput = {
    Name: string
    Abbreviation: string
    Drivers?: DriversCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    Name: string
    Abbreviation: string
    Drivers?: DriversUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesCreateOrConnectWithoutCustomersInput = {
    where: StatesWhereUniqueInput
    create: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsCreateWithoutCustomersInput = {
    DateUsed: Date | string
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutCustomerDeliveryLocationsInput
  }

  export type CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    create: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsCreateManyCustomersInputEnvelope = {
    data: CustomerDeliveryLocationsCreateManyCustomersInput | CustomerDeliveryLocationsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type CustomerLoadTypesCreateWithoutCustomersInput = {
    DateDelivered: Date | string
    LoadTypes: LoadTypesCreateNestedOneWithoutCustomerLoadTypesInput
  }

  export type CustomerLoadTypesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesCreateOrConnectWithoutCustomersInput = {
    where: CustomerLoadTypesWhereUniqueInput
    create: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerLoadTypesCreateManyCustomersInputEnvelope = {
    data: CustomerLoadTypesCreateManyCustomersInput | CustomerLoadTypesCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryLocationsCreateWithoutCustomersInput = {
    Description: string
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutCustomersInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type DeliveryLocationsCreateManyCustomersInputEnvelope = {
    data: DeliveryLocationsCreateManyCustomersInput | DeliveryLocationsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type InvoicesCreateWithoutCustomersInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesCreateOrConnectWithoutCustomersInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput>
  }

  export type InvoicesCreateManyCustomersInputEnvelope = {
    data: InvoicesCreateManyCustomersInput | InvoicesCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutCustomersInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutCustomersInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput>
  }

  export type JobsCreateManyCustomersInputEnvelope = {
    data: JobsCreateManyCustomersInput | JobsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutCustomersInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutCustomersInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput>
  }

  export type LoadsCreateManyCustomersInputEnvelope = {
    data: LoadsCreateManyCustomersInput | LoadsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutCustomersInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    Week: string
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutCustomersInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput>
  }

  export type WeekliesCreateManyCustomersInputEnvelope = {
    data: WeekliesCreateManyCustomersInput | WeekliesCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type StatesUpsertWithoutCustomersInput = {
    update: XOR<StatesUpdateWithoutCustomersInput, StatesUncheckedUpdateWithoutCustomersInput>
    create: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
    where?: StatesWhereInput
  }

  export type StatesUpdateToOneWithWhereWithoutCustomersInput = {
    where?: StatesWhereInput
    data: XOR<StatesUpdateWithoutCustomersInput, StatesUncheckedUpdateWithoutCustomersInput>
  }

  export type StatesUpdateWithoutCustomersInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Drivers?: DriversUpdateManyWithoutStatesNestedInput
  }

  export type StatesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Drivers?: DriversUncheckedUpdateManyWithoutStatesNestedInput
  }

  export type CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    update: XOR<CustomerDeliveryLocationsUpdateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    data: XOR<CustomerDeliveryLocationsUpdateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerDeliveryLocationsScalarWhereInput
    data: XOR<CustomerDeliveryLocationsUpdateManyMutationInput, CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsScalarWhereInput = {
    AND?: CustomerDeliveryLocationsScalarWhereInput | CustomerDeliveryLocationsScalarWhereInput[]
    OR?: CustomerDeliveryLocationsScalarWhereInput[]
    NOT?: CustomerDeliveryLocationsScalarWhereInput | CustomerDeliveryLocationsScalarWhereInput[]
    ID?: IntFilter<"CustomerDeliveryLocations"> | number
    CustomerID?: IntFilter<"CustomerDeliveryLocations"> | number
    DeliveryLocationID?: IntFilter<"CustomerDeliveryLocations"> | number
    DateUsed?: DateTimeFilter<"CustomerDeliveryLocations"> | Date | string
  }

  export type CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerLoadTypesWhereUniqueInput
    update: XOR<CustomerLoadTypesUpdateWithoutCustomersInput, CustomerLoadTypesUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerLoadTypesWhereUniqueInput
    data: XOR<CustomerLoadTypesUpdateWithoutCustomersInput, CustomerLoadTypesUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerLoadTypesScalarWhereInput
    data: XOR<CustomerLoadTypesUpdateManyMutationInput, CustomerLoadTypesUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CustomerLoadTypesScalarWhereInput = {
    AND?: CustomerLoadTypesScalarWhereInput | CustomerLoadTypesScalarWhereInput[]
    OR?: CustomerLoadTypesScalarWhereInput[]
    NOT?: CustomerLoadTypesScalarWhereInput | CustomerLoadTypesScalarWhereInput[]
    ID?: IntFilter<"CustomerLoadTypes"> | number
    CustomerID?: IntFilter<"CustomerLoadTypes"> | number
    LoadTypeID?: IntFilter<"CustomerLoadTypes"> | number
    DateDelivered?: DateTimeFilter<"CustomerLoadTypes"> | Date | string
  }

  export type DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: DeliveryLocationsWhereUniqueInput
    update: XOR<DeliveryLocationsUpdateWithoutCustomersInput, DeliveryLocationsUncheckedUpdateWithoutCustomersInput>
    create: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: DeliveryLocationsWhereUniqueInput
    data: XOR<DeliveryLocationsUpdateWithoutCustomersInput, DeliveryLocationsUncheckedUpdateWithoutCustomersInput>
  }

  export type DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput = {
    where: DeliveryLocationsScalarWhereInput
    data: XOR<DeliveryLocationsUpdateManyMutationInput, DeliveryLocationsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type DeliveryLocationsScalarWhereInput = {
    AND?: DeliveryLocationsScalarWhereInput | DeliveryLocationsScalarWhereInput[]
    OR?: DeliveryLocationsScalarWhereInput[]
    NOT?: DeliveryLocationsScalarWhereInput | DeliveryLocationsScalarWhereInput[]
    ID?: IntFilter<"DeliveryLocations"> | number
    Description?: StringFilter<"DeliveryLocations"> | string
    Deleted?: BoolNullableFilter<"DeliveryLocations"> | boolean | null
    CustomerID?: IntNullableFilter<"DeliveryLocations"> | number | null
  }

  export type InvoicesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: InvoicesWhereUniqueInput
    update: XOR<InvoicesUpdateWithoutCustomersInput, InvoicesUncheckedUpdateWithoutCustomersInput>
    create: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput>
  }

  export type InvoicesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: InvoicesWhereUniqueInput
    data: XOR<InvoicesUpdateWithoutCustomersInput, InvoicesUncheckedUpdateWithoutCustomersInput>
  }

  export type InvoicesUpdateManyWithWhereWithoutCustomersInput = {
    where: InvoicesScalarWhereInput
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyWithoutCustomersInput>
  }

  export type InvoicesScalarWhereInput = {
    AND?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
    OR?: InvoicesScalarWhereInput[]
    NOT?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
    ID?: IntFilter<"Invoices"> | number
    InvoiceDate?: DateTimeFilter<"Invoices"> | Date | string
    Number?: IntNullableFilter<"Invoices"> | number | null
    CustomerID?: IntFilter<"Invoices"> | number
    TotalAmount?: FloatFilter<"Invoices"> | number
    PaidDate?: DateTimeNullableFilter<"Invoices"> | Date | string | null
    CheckNumber?: StringNullableFilter<"Invoices"> | string | null
    Paid?: BoolNullableFilter<"Invoices"> | boolean | null
    Printed?: BoolNullableFilter<"Invoices"> | boolean | null
    Deleted?: BoolNullableFilter<"Invoices"> | boolean | null
    PaymentType?: StringNullableFilter<"Invoices"> | string | null
    Consolidated?: BoolNullableFilter<"Invoices"> | boolean | null
    ConsolidatedID?: IntNullableFilter<"Invoices"> | number | null
  }

  export type JobsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutCustomersInput, JobsUncheckedUpdateWithoutCustomersInput>
    create: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutCustomersInput, JobsUncheckedUpdateWithoutCustomersInput>
  }

  export type JobsUpdateManyWithWhereWithoutCustomersInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type JobsScalarWhereInput = {
    AND?: JobsScalarWhereInput | JobsScalarWhereInput[]
    OR?: JobsScalarWhereInput[]
    NOT?: JobsScalarWhereInput | JobsScalarWhereInput[]
    ID?: IntFilter<"Jobs"> | number
    DriverID?: IntFilter<"Jobs"> | number
    LoadTypeID?: IntFilter<"Jobs"> | number
    CustomerID?: IntFilter<"Jobs"> | number
    PaidOut?: BoolFilter<"Jobs"> | boolean
    TruckingRevenue?: FloatNullableFilter<"Jobs"> | number | null
    CompanyRevenue?: FloatNullableFilter<"Jobs"> | number | null
    TruckingRate?: FloatFilter<"Jobs"> | number
    CompanyRate?: FloatFilter<"Jobs"> | number
    DeliveryLocationID?: IntFilter<"Jobs"> | number
    WeeklyID?: IntFilter<"Jobs"> | number
    DailyID?: IntFilter<"Jobs"> | number
    MaterialRate?: FloatFilter<"Jobs"> | number
    DriverRate?: FloatFilter<"Jobs"> | number
    PayStubID?: IntNullableFilter<"Jobs"> | number | null
  }

  export type LoadsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutCustomersInput, LoadsUncheckedUpdateWithoutCustomersInput>
    create: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutCustomersInput, LoadsUncheckedUpdateWithoutCustomersInput>
  }

  export type LoadsUpdateManyWithWhereWithoutCustomersInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type LoadsScalarWhereInput = {
    AND?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
    OR?: LoadsScalarWhereInput[]
    NOT?: LoadsScalarWhereInput | LoadsScalarWhereInput[]
    ID?: IntFilter<"Loads"> | number
    StartDate?: DateTimeFilter<"Loads"> | Date | string
    Created?: DateTimeFilter<"Loads"> | Date | string
    Weight?: FloatNullableFilter<"Loads"> | number | null
    Hours?: FloatNullableFilter<"Loads"> | number | null
    TotalRate?: FloatNullableFilter<"Loads"> | number | null
    TotalAmount?: FloatNullableFilter<"Loads"> | number | null
    TruckRate?: FloatNullableFilter<"Loads"> | number | null
    MaterialRate?: FloatNullableFilter<"Loads"> | number | null
    Received?: StringNullableFilter<"Loads"> | string | null
    Notes?: StringNullableFilter<"Loads"> | string | null
    TicketNumber?: IntFilter<"Loads"> | number
    Invoiced?: BoolNullableFilter<"Loads"> | boolean | null
    CustomerID?: IntFilter<"Loads"> | number
    InvoiceID?: IntNullableFilter<"Loads"> | number | null
    LoadTypeID?: IntNullableFilter<"Loads"> | number | null
    DeliveryLocationID?: IntNullableFilter<"Loads"> | number | null
    TruckID?: IntNullableFilter<"Loads"> | number | null
    DriverID?: IntNullableFilter<"Loads"> | number | null
    Deleted?: BoolNullableFilter<"Loads"> | boolean | null
    JobID?: IntNullableFilter<"Loads"> | number | null
    Week?: StringFilter<"Loads"> | string
    DriverRate?: FloatNullableFilter<"Loads"> | number | null
  }

  export type WeekliesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutCustomersInput, WeekliesUncheckedUpdateWithoutCustomersInput>
    create: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutCustomersInput, WeekliesUncheckedUpdateWithoutCustomersInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutCustomersInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutCustomersInput>
  }

  export type WeekliesScalarWhereInput = {
    AND?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
    OR?: WeekliesScalarWhereInput[]
    NOT?: WeekliesScalarWhereInput | WeekliesScalarWhereInput[]
    ID?: IntFilter<"Weeklies"> | number
    Week?: StringFilter<"Weeklies"> | string
    CustomerID?: IntFilter<"Weeklies"> | number
    InvoiceID?: IntNullableFilter<"Weeklies"> | number | null
    CompanyRate?: FloatNullableFilter<"Weeklies"> | number | null
    Revenue?: FloatNullableFilter<"Weeklies"> | number | null
    LoadTypeID?: IntFilter<"Weeklies"> | number
    DeliveryLocationID?: IntFilter<"Weeklies"> | number
    LastPrinted?: DateTimeNullableFilter<"Weeklies"> | Date | string | null
    TotalWeight?: FloatNullableFilter<"Weeklies"> | number | null
  }

  export type CustomersCreateWithoutDeliveryLocationsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutDeliveryLocationsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput = {
    DateUsed: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerDeliveryLocationsInput
  }

  export type CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    CustomerID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    create: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope = {
    data: CustomerDeliveryLocationsCreateManyDeliveryLocationsInput | CustomerDeliveryLocationsCreateManyDeliveryLocationsInput[]
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutDeliveryLocationsInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutDeliveryLocationsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type JobsCreateManyDeliveryLocationsInputEnvelope = {
    data: JobsCreateManyDeliveryLocationsInput | JobsCreateManyDeliveryLocationsInput[]
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutDeliveryLocationsInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutDeliveryLocationsInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type LoadsCreateManyDeliveryLocationsInputEnvelope = {
    data: LoadsCreateManyDeliveryLocationsInput | LoadsCreateManyDeliveryLocationsInput[]
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutDeliveryLocationsInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutDeliveryLocationsInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type WeekliesCreateManyDeliveryLocationsInputEnvelope = {
    data: WeekliesCreateManyDeliveryLocationsInput | WeekliesCreateManyDeliveryLocationsInput[]
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutDeliveryLocationsInput = {
    update: XOR<CustomersUpdateWithoutDeliveryLocationsInput, CustomersUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutDeliveryLocationsInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutDeliveryLocationsInput, CustomersUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type CustomersUpdateWithoutDeliveryLocationsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    update: XOR<CustomerDeliveryLocationsUpdateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    data: XOR<CustomerDeliveryLocationsUpdateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsScalarWhereInput
    data: XOR<CustomerDeliveryLocationsUpdateManyMutationInput, CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsInput>
  }

  export type JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutDeliveryLocationsInput, JobsUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutDeliveryLocationsInput, JobsUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type JobsUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutDeliveryLocationsInput>
  }

  export type LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutDeliveryLocationsInput, LoadsUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutDeliveryLocationsInput, LoadsUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutDeliveryLocationsInput>
  }

  export type WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutDeliveryLocationsInput, WeekliesUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutDeliveryLocationsInput, WeekliesUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutDeliveryLocationsInput>
  }

  export type StatesCreateWithoutDriversInput = {
    Name: string
    Abbreviation: string
    Customers?: CustomersCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateWithoutDriversInput = {
    ID?: number
    Name: string
    Abbreviation: string
    Customers?: CustomersUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesCreateOrConnectWithoutDriversInput = {
    where: StatesWhereUniqueInput
    create: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
  }

  export type DailiesCreateWithoutDriversInput = {
    Week: string
    LastPrinted?: Date | string | null
    Jobs?: JobsCreateNestedManyWithoutDailiesInput
  }

  export type DailiesUncheckedCreateWithoutDriversInput = {
    ID?: number
    Week: string
    LastPrinted?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutDailiesInput
  }

  export type DailiesCreateOrConnectWithoutDriversInput = {
    where: DailiesWhereUniqueInput
    create: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput>
  }

  export type DailiesCreateManyDriversInputEnvelope = {
    data: DailiesCreateManyDriversInput | DailiesCreateManyDriversInput[]
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutDriversInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutDriversInput = {
    ID?: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutDriversInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput>
  }

  export type JobsCreateManyDriversInputEnvelope = {
    data: JobsCreateManyDriversInput | JobsCreateManyDriversInput[]
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutDriversInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutDriversInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutDriversInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput>
  }

  export type LoadsCreateManyDriversInputEnvelope = {
    data: LoadsCreateManyDriversInput | LoadsCreateManyDriversInput[]
    skipDuplicates?: boolean
  }

  export type PayStubsCreateWithoutDriversInput = {
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Jobs?: JobsCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsUncheckedCreateWithoutDriversInput = {
    ID?: number
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsCreateOrConnectWithoutDriversInput = {
    where: PayStubsWhereUniqueInput
    create: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput>
  }

  export type PayStubsCreateManyDriversInputEnvelope = {
    data: PayStubsCreateManyDriversInput | PayStubsCreateManyDriversInput[]
    skipDuplicates?: boolean
  }

  export type TrucksDrivenCreateWithoutDriversInput = {
    DateDriven: Date | string
    Trucks: TrucksCreateNestedOneWithoutTrucksDrivenInput
  }

  export type TrucksDrivenUncheckedCreateWithoutDriversInput = {
    ID?: number
    TruckID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenCreateOrConnectWithoutDriversInput = {
    where: TrucksDrivenWhereUniqueInput
    create: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput>
  }

  export type TrucksDrivenCreateManyDriversInputEnvelope = {
    data: TrucksDrivenCreateManyDriversInput | TrucksDrivenCreateManyDriversInput[]
    skipDuplicates?: boolean
  }

  export type StatesUpsertWithoutDriversInput = {
    update: XOR<StatesUpdateWithoutDriversInput, StatesUncheckedUpdateWithoutDriversInput>
    create: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
    where?: StatesWhereInput
  }

  export type StatesUpdateToOneWithWhereWithoutDriversInput = {
    where?: StatesWhereInput
    data: XOR<StatesUpdateWithoutDriversInput, StatesUncheckedUpdateWithoutDriversInput>
  }

  export type StatesUpdateWithoutDriversInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUpdateManyWithoutStatesNestedInput
  }

  export type StatesUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUncheckedUpdateManyWithoutStatesNestedInput
  }

  export type DailiesUpsertWithWhereUniqueWithoutDriversInput = {
    where: DailiesWhereUniqueInput
    update: XOR<DailiesUpdateWithoutDriversInput, DailiesUncheckedUpdateWithoutDriversInput>
    create: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput>
  }

  export type DailiesUpdateWithWhereUniqueWithoutDriversInput = {
    where: DailiesWhereUniqueInput
    data: XOR<DailiesUpdateWithoutDriversInput, DailiesUncheckedUpdateWithoutDriversInput>
  }

  export type DailiesUpdateManyWithWhereWithoutDriversInput = {
    where: DailiesScalarWhereInput
    data: XOR<DailiesUpdateManyMutationInput, DailiesUncheckedUpdateManyWithoutDriversInput>
  }

  export type DailiesScalarWhereInput = {
    AND?: DailiesScalarWhereInput | DailiesScalarWhereInput[]
    OR?: DailiesScalarWhereInput[]
    NOT?: DailiesScalarWhereInput | DailiesScalarWhereInput[]
    ID?: IntFilter<"Dailies"> | number
    DriverID?: IntFilter<"Dailies"> | number
    Week?: StringFilter<"Dailies"> | string
    LastPrinted?: DateTimeNullableFilter<"Dailies"> | Date | string | null
  }

  export type JobsUpsertWithWhereUniqueWithoutDriversInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutDriversInput, JobsUncheckedUpdateWithoutDriversInput>
    create: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutDriversInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutDriversInput, JobsUncheckedUpdateWithoutDriversInput>
  }

  export type JobsUpdateManyWithWhereWithoutDriversInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutDriversInput>
  }

  export type LoadsUpsertWithWhereUniqueWithoutDriversInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutDriversInput, LoadsUncheckedUpdateWithoutDriversInput>
    create: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutDriversInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutDriversInput, LoadsUncheckedUpdateWithoutDriversInput>
  }

  export type LoadsUpdateManyWithWhereWithoutDriversInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutDriversInput>
  }

  export type PayStubsUpsertWithWhereUniqueWithoutDriversInput = {
    where: PayStubsWhereUniqueInput
    update: XOR<PayStubsUpdateWithoutDriversInput, PayStubsUncheckedUpdateWithoutDriversInput>
    create: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput>
  }

  export type PayStubsUpdateWithWhereUniqueWithoutDriversInput = {
    where: PayStubsWhereUniqueInput
    data: XOR<PayStubsUpdateWithoutDriversInput, PayStubsUncheckedUpdateWithoutDriversInput>
  }

  export type PayStubsUpdateManyWithWhereWithoutDriversInput = {
    where: PayStubsScalarWhereInput
    data: XOR<PayStubsUpdateManyMutationInput, PayStubsUncheckedUpdateManyWithoutDriversInput>
  }

  export type PayStubsScalarWhereInput = {
    AND?: PayStubsScalarWhereInput | PayStubsScalarWhereInput[]
    OR?: PayStubsScalarWhereInput[]
    NOT?: PayStubsScalarWhereInput | PayStubsScalarWhereInput[]
    ID?: IntFilter<"PayStubs"> | number
    Created?: DateTimeFilter<"PayStubs"> | Date | string
    DriverID?: IntFilter<"PayStubs"> | number
    CheckNumber?: StringFilter<"PayStubs"> | string
    Gross?: FloatFilter<"PayStubs"> | number
    Percentage?: FloatFilter<"PayStubs"> | number
    NetTotal?: FloatFilter<"PayStubs"> | number
    LastPrinted?: DateTimeNullableFilter<"PayStubs"> | Date | string | null
    TakeHome?: FloatFilter<"PayStubs"> | number
    Deductions?: FloatFilter<"PayStubs"> | number
    Additions?: FloatFilter<"PayStubs"> | number
    Notes?: StringNullableFilter<"PayStubs"> | string | null
    DepositDate?: DateTimeNullableFilter<"PayStubs"> | Date | string | null
  }

  export type TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput = {
    where: TrucksDrivenWhereUniqueInput
    update: XOR<TrucksDrivenUpdateWithoutDriversInput, TrucksDrivenUncheckedUpdateWithoutDriversInput>
    create: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput>
  }

  export type TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput = {
    where: TrucksDrivenWhereUniqueInput
    data: XOR<TrucksDrivenUpdateWithoutDriversInput, TrucksDrivenUncheckedUpdateWithoutDriversInput>
  }

  export type TrucksDrivenUpdateManyWithWhereWithoutDriversInput = {
    where: TrucksDrivenScalarWhereInput
    data: XOR<TrucksDrivenUpdateManyMutationInput, TrucksDrivenUncheckedUpdateManyWithoutDriversInput>
  }

  export type TrucksDrivenScalarWhereInput = {
    AND?: TrucksDrivenScalarWhereInput | TrucksDrivenScalarWhereInput[]
    OR?: TrucksDrivenScalarWhereInput[]
    NOT?: TrucksDrivenScalarWhereInput | TrucksDrivenScalarWhereInput[]
    ID?: IntFilter<"TrucksDriven"> | number
    TruckID?: IntFilter<"TrucksDriven"> | number
    DriverID?: IntFilter<"TrucksDriven"> | number
    DateDriven?: DateTimeFilter<"TrucksDriven"> | Date | string
  }

  export type CustomersCreateWithoutInvoicesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutInvoicesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutInvoicesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
  }

  export type LoadsCreateWithoutInvoicesInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutInvoicesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutInvoicesInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput>
  }

  export type LoadsCreateManyInvoicesInputEnvelope = {
    data: LoadsCreateManyInvoicesInput | LoadsCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutInvoicesInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutInvoicesInput = {
    ID?: number
    Week: string
    CustomerID: number
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutInvoicesInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput>
  }

  export type WeekliesCreateManyInvoicesInputEnvelope = {
    data: WeekliesCreateManyInvoicesInput | WeekliesCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutInvoicesInput = {
    update: XOR<CustomersUpdateWithoutInvoicesInput, CustomersUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutInvoicesInput, CustomersUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomersUpdateWithoutInvoicesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type LoadsUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutInvoicesInput, LoadsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutInvoicesInput, LoadsUncheckedUpdateWithoutInvoicesInput>
  }

  export type LoadsUpdateManyWithWhereWithoutInvoicesInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type WeekliesUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutInvoicesInput, WeekliesUncheckedUpdateWithoutInvoicesInput>
    create: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutInvoicesInput, WeekliesUncheckedUpdateWithoutInvoicesInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutInvoicesInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type CustomerLoadTypesCreateWithoutLoadTypesInput = {
    DateDelivered: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerLoadTypesInput
  }

  export type CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    CustomerID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput = {
    where: CustomerLoadTypesWhereUniqueInput
    create: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>
  }

  export type CustomerLoadTypesCreateManyLoadTypesInputEnvelope = {
    data: CustomerLoadTypesCreateManyLoadTypesInput | CustomerLoadTypesCreateManyLoadTypesInput[]
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutLoadTypesInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    DriverID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutLoadTypesInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput>
  }

  export type JobsCreateManyLoadTypesInputEnvelope = {
    data: JobsCreateManyLoadTypesInput | JobsCreateManyLoadTypesInput[]
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutLoadTypesInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutLoadTypesInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput>
  }

  export type LoadsCreateManyLoadTypesInputEnvelope = {
    data: LoadsCreateManyLoadTypesInput | LoadsCreateManyLoadTypesInput[]
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutLoadTypesInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutLoadTypesInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput>
  }

  export type WeekliesCreateManyLoadTypesInputEnvelope = {
    data: WeekliesCreateManyLoadTypesInput | WeekliesCreateManyLoadTypesInput[]
    skipDuplicates?: boolean
  }

  export type CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: CustomerLoadTypesWhereUniqueInput
    update: XOR<CustomerLoadTypesUpdateWithoutLoadTypesInput, CustomerLoadTypesUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>
  }

  export type CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: CustomerLoadTypesWhereUniqueInput
    data: XOR<CustomerLoadTypesUpdateWithoutLoadTypesInput, CustomerLoadTypesUncheckedUpdateWithoutLoadTypesInput>
  }

  export type CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput = {
    where: CustomerLoadTypesScalarWhereInput
    data: XOR<CustomerLoadTypesUpdateManyMutationInput, CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesInput>
  }

  export type JobsUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutLoadTypesInput, JobsUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutLoadTypesInput, JobsUncheckedUpdateWithoutLoadTypesInput>
  }

  export type JobsUpdateManyWithWhereWithoutLoadTypesInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutLoadTypesInput>
  }

  export type LoadsUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutLoadTypesInput, LoadsUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutLoadTypesInput, LoadsUncheckedUpdateWithoutLoadTypesInput>
  }

  export type LoadsUpdateManyWithWhereWithoutLoadTypesInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadTypesInput>
  }

  export type WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutLoadTypesInput, WeekliesUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutLoadTypesInput, WeekliesUncheckedUpdateWithoutLoadTypesInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutLoadTypesInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutLoadTypesInput>
  }

  export type CustomersCreateWithoutStatesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutStatesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutStatesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput>
  }

  export type CustomersCreateManyStatesInputEnvelope = {
    data: CustomersCreateManyStatesInput | CustomersCreateManyStatesInput[]
    skipDuplicates?: boolean
  }

  export type DriversCreateWithoutStatesInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutStatesInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutStatesInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput>
  }

  export type DriversCreateManyStatesInputEnvelope = {
    data: DriversCreateManyStatesInput | DriversCreateManyStatesInput[]
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithWhereUniqueWithoutStatesInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutStatesInput, CustomersUncheckedUpdateWithoutStatesInput>
    create: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutStatesInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutStatesInput, CustomersUncheckedUpdateWithoutStatesInput>
  }

  export type CustomersUpdateManyWithWhereWithoutStatesInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutStatesInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    OR?: CustomersScalarWhereInput[]
    NOT?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    ID?: IntFilter<"Customers"> | number
    Name?: StringFilter<"Customers"> | string
    Street?: StringFilter<"Customers"> | string
    City?: StringFilter<"Customers"> | string
    State?: IntFilter<"Customers"> | number
    ZIP?: StringFilter<"Customers"> | string
    Phone?: StringNullableFilter<"Customers"> | string | null
    Email?: StringNullableFilter<"Customers"> | string | null
    Notes?: StringNullableFilter<"Customers"> | string | null
    MainContact?: StringNullableFilter<"Customers"> | string | null
    Deleted?: BoolNullableFilter<"Customers"> | boolean | null
  }

  export type DriversUpsertWithWhereUniqueWithoutStatesInput = {
    where: DriversWhereUniqueInput
    update: XOR<DriversUpdateWithoutStatesInput, DriversUncheckedUpdateWithoutStatesInput>
    create: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput>
  }

  export type DriversUpdateWithWhereUniqueWithoutStatesInput = {
    where: DriversWhereUniqueInput
    data: XOR<DriversUpdateWithoutStatesInput, DriversUncheckedUpdateWithoutStatesInput>
  }

  export type DriversUpdateManyWithWhereWithoutStatesInput = {
    where: DriversScalarWhereInput
    data: XOR<DriversUpdateManyMutationInput, DriversUncheckedUpdateManyWithoutStatesInput>
  }

  export type DriversScalarWhereInput = {
    AND?: DriversScalarWhereInput | DriversScalarWhereInput[]
    OR?: DriversScalarWhereInput[]
    NOT?: DriversScalarWhereInput | DriversScalarWhereInput[]
    ID?: IntFilter<"Drivers"> | number
    FirstName?: StringFilter<"Drivers"> | string
    MiddleName?: StringNullableFilter<"Drivers"> | string | null
    LastName?: StringFilter<"Drivers"> | string
    Street?: StringNullableFilter<"Drivers"> | string | null
    City?: StringNullableFilter<"Drivers"> | string | null
    State?: IntNullableFilter<"Drivers"> | number | null
    ZIP?: StringNullableFilter<"Drivers"> | string | null
    DOB?: DateTimeNullableFilter<"Drivers"> | Date | string | null
    License?: StringNullableFilter<"Drivers"> | string | null
    Email?: StringNullableFilter<"Drivers"> | string | null
    Phone?: StringNullableFilter<"Drivers"> | string | null
    Notes?: StringNullableFilter<"Drivers"> | string | null
    Deleted?: BoolNullableFilter<"Drivers"> | boolean | null
    HireDate?: StringNullableFilter<"Drivers"> | string | null
    OwnerOperator?: BoolFilter<"Drivers"> | boolean
  }

  export type LoadsCreateWithoutTrucksInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutTrucksInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutTrucksInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput>
  }

  export type LoadsCreateManyTrucksInputEnvelope = {
    data: LoadsCreateManyTrucksInput | LoadsCreateManyTrucksInput[]
    skipDuplicates?: boolean
  }

  export type TrucksDrivenCreateWithoutTrucksInput = {
    DateDriven: Date | string
    Drivers: DriversCreateNestedOneWithoutTrucksDrivenInput
  }

  export type TrucksDrivenUncheckedCreateWithoutTrucksInput = {
    ID?: number
    DriverID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenCreateOrConnectWithoutTrucksInput = {
    where: TrucksDrivenWhereUniqueInput
    create: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput>
  }

  export type TrucksDrivenCreateManyTrucksInputEnvelope = {
    data: TrucksDrivenCreateManyTrucksInput | TrucksDrivenCreateManyTrucksInput[]
    skipDuplicates?: boolean
  }

  export type LoadsUpsertWithWhereUniqueWithoutTrucksInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutTrucksInput, LoadsUncheckedUpdateWithoutTrucksInput>
    create: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutTrucksInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutTrucksInput, LoadsUncheckedUpdateWithoutTrucksInput>
  }

  export type LoadsUpdateManyWithWhereWithoutTrucksInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutTrucksInput>
  }

  export type TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput = {
    where: TrucksDrivenWhereUniqueInput
    update: XOR<TrucksDrivenUpdateWithoutTrucksInput, TrucksDrivenUncheckedUpdateWithoutTrucksInput>
    create: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput>
  }

  export type TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput = {
    where: TrucksDrivenWhereUniqueInput
    data: XOR<TrucksDrivenUpdateWithoutTrucksInput, TrucksDrivenUncheckedUpdateWithoutTrucksInput>
  }

  export type TrucksDrivenUpdateManyWithWhereWithoutTrucksInput = {
    where: TrucksDrivenScalarWhereInput
    data: XOR<TrucksDrivenUpdateManyMutationInput, TrucksDrivenUncheckedUpdateManyWithoutTrucksInput>
  }

  export type DriversCreateWithoutTrucksDrivenInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutTrucksDrivenInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutTrucksDrivenInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
  }

  export type TrucksCreateWithoutTrucksDrivenInput = {
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUncheckedCreateWithoutTrucksDrivenInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutTrucksInput
  }

  export type TrucksCreateOrConnectWithoutTrucksDrivenInput = {
    where: TrucksWhereUniqueInput
    create: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
  }

  export type DriversUpsertWithoutTrucksDrivenInput = {
    update: XOR<DriversUpdateWithoutTrucksDrivenInput, DriversUncheckedUpdateWithoutTrucksDrivenInput>
    create: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
    where?: DriversWhereInput
  }

  export type DriversUpdateToOneWithWhereWithoutTrucksDrivenInput = {
    where?: DriversWhereInput
    data: XOR<DriversUpdateWithoutTrucksDrivenInput, DriversUncheckedUpdateWithoutTrucksDrivenInput>
  }

  export type DriversUpdateWithoutTrucksDrivenInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutTrucksDrivenInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type TrucksUpsertWithoutTrucksDrivenInput = {
    update: XOR<TrucksUpdateWithoutTrucksDrivenInput, TrucksUncheckedUpdateWithoutTrucksDrivenInput>
    create: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
    where?: TrucksWhereInput
  }

  export type TrucksUpdateToOneWithWhereWithoutTrucksDrivenInput = {
    where?: TrucksWhereInput
    data: XOR<TrucksUpdateWithoutTrucksDrivenInput, TrucksUncheckedUpdateWithoutTrucksDrivenInput>
  }

  export type TrucksUpdateWithoutTrucksDrivenInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksUncheckedUpdateWithoutTrucksDrivenInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUncheckedUpdateManyWithoutTrucksNestedInput
  }

  export type CustomersCreateWithoutLoadsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutLoadsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
  }

  export type DeliveryLocationsCreateWithoutLoadsInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutLoadsInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
  }

  export type DriversCreateWithoutLoadsInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutLoadsInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutLoadsInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
  }

  export type InvoicesCreateWithoutLoadsInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Customers: CustomersCreateNestedOneWithoutInvoicesInput
    Weeklies?: WeekliesCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateWithoutLoadsInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesCreateOrConnectWithoutLoadsInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
  }

  export type JobsCreateWithoutLoadsInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutLoadsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsCreateOrConnectWithoutLoadsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
  }

  export type LoadTypesCreateWithoutLoadsInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutLoadsInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
  }

  export type TrucksCreateWithoutLoadsInput = {
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutTrucksInput
  }

  export type TrucksCreateOrConnectWithoutLoadsInput = {
    where: TrucksWhereUniqueInput
    create: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
  }

  export type CustomersUpsertWithoutLoadsInput = {
    update: XOR<CustomersUpdateWithoutLoadsInput, CustomersUncheckedUpdateWithoutLoadsInput>
    create: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutLoadsInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutLoadsInput, CustomersUncheckedUpdateWithoutLoadsInput>
  }

  export type CustomersUpdateWithoutLoadsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DeliveryLocationsUpsertWithoutLoadsInput = {
    update: XOR<DeliveryLocationsUpdateWithoutLoadsInput, DeliveryLocationsUncheckedUpdateWithoutLoadsInput>
    create: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
    where?: DeliveryLocationsWhereInput
  }

  export type DeliveryLocationsUpdateToOneWithWhereWithoutLoadsInput = {
    where?: DeliveryLocationsWhereInput
    data: XOR<DeliveryLocationsUpdateWithoutLoadsInput, DeliveryLocationsUncheckedUpdateWithoutLoadsInput>
  }

  export type DeliveryLocationsUpdateWithoutLoadsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DriversUpsertWithoutLoadsInput = {
    update: XOR<DriversUpdateWithoutLoadsInput, DriversUncheckedUpdateWithoutLoadsInput>
    create: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
    where?: DriversWhereInput
  }

  export type DriversUpdateToOneWithWhereWithoutLoadsInput = {
    where?: DriversWhereInput
    data: XOR<DriversUpdateWithoutLoadsInput, DriversUncheckedUpdateWithoutLoadsInput>
  }

  export type DriversUpdateWithoutLoadsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type InvoicesUpsertWithoutLoadsInput = {
    update: XOR<InvoicesUpdateWithoutLoadsInput, InvoicesUncheckedUpdateWithoutLoadsInput>
    create: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
    where?: InvoicesWhereInput
  }

  export type InvoicesUpdateToOneWithWhereWithoutLoadsInput = {
    where?: InvoicesWhereInput
    data: XOR<InvoicesUpdateWithoutLoadsInput, InvoicesUncheckedUpdateWithoutLoadsInput>
  }

  export type InvoicesUpdateWithoutLoadsInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutInvoicesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Weeklies?: WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type JobsUpsertWithoutLoadsInput = {
    update: XOR<JobsUpdateWithoutLoadsInput, JobsUncheckedUpdateWithoutLoadsInput>
    create: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
    where?: JobsWhereInput
  }

  export type JobsUpdateToOneWithWhereWithoutLoadsInput = {
    where?: JobsWhereInput
    data: XOR<JobsUpdateWithoutLoadsInput, JobsUncheckedUpdateWithoutLoadsInput>
  }

  export type JobsUpdateWithoutLoadsInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadTypesUpsertWithoutLoadsInput = {
    update: XOR<LoadTypesUpdateWithoutLoadsInput, LoadTypesUncheckedUpdateWithoutLoadsInput>
    create: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
    where?: LoadTypesWhereInput
  }

  export type LoadTypesUpdateToOneWithWhereWithoutLoadsInput = {
    where?: LoadTypesWhereInput
    data: XOR<LoadTypesUpdateWithoutLoadsInput, LoadTypesUncheckedUpdateWithoutLoadsInput>
  }

  export type LoadTypesUpdateWithoutLoadsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type TrucksUpsertWithoutLoadsInput = {
    update: XOR<TrucksUpdateWithoutLoadsInput, TrucksUncheckedUpdateWithoutLoadsInput>
    create: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
    where?: TrucksWhereInput
  }

  export type TrucksUpdateToOneWithWhereWithoutLoadsInput = {
    where?: TrucksWhereInput
    data: XOR<TrucksUpdateWithoutLoadsInput, TrucksUncheckedUpdateWithoutLoadsInput>
  }

  export type TrucksUpdateWithoutLoadsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TrucksDriven?: TrucksDrivenUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutTrucksNestedInput
  }

  export type CustomersCreateWithoutCustomerDeliveryLocationsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutCustomerDeliveryLocationsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
  }

  export type DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutCustomerDeliveryLocationsInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
  }

  export type CustomersUpsertWithoutCustomerDeliveryLocationsInput = {
    update: XOR<CustomersUpdateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
    create: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutCustomerDeliveryLocationsInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
  }

  export type CustomersUpdateWithoutCustomerDeliveryLocationsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DeliveryLocationsUpsertWithoutCustomerDeliveryLocationsInput = {
    update: XOR<DeliveryLocationsUpdateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
    create: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    where?: DeliveryLocationsWhereInput
  }

  export type DeliveryLocationsUpdateToOneWithWhereWithoutCustomerDeliveryLocationsInput = {
    where?: DeliveryLocationsWhereInput
    data: XOR<DeliveryLocationsUpdateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
  }

  export type DeliveryLocationsUpdateWithoutCustomerDeliveryLocationsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutCustomerDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DriversCreateWithoutDailiesInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutDailiesInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutDailiesInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
  }

  export type JobsCreateWithoutDailiesInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutDailiesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutDailiesInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput>
  }

  export type JobsCreateManyDailiesInputEnvelope = {
    data: JobsCreateManyDailiesInput | JobsCreateManyDailiesInput[]
    skipDuplicates?: boolean
  }

  export type DriversUpsertWithoutDailiesInput = {
    update: XOR<DriversUpdateWithoutDailiesInput, DriversUncheckedUpdateWithoutDailiesInput>
    create: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
    where?: DriversWhereInput
  }

  export type DriversUpdateToOneWithWhereWithoutDailiesInput = {
    where?: DriversWhereInput
    data: XOR<DriversUpdateWithoutDailiesInput, DriversUncheckedUpdateWithoutDailiesInput>
  }

  export type DriversUpdateWithoutDailiesInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutDailiesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type JobsUpsertWithWhereUniqueWithoutDailiesInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutDailiesInput, JobsUncheckedUpdateWithoutDailiesInput>
    create: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutDailiesInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutDailiesInput, JobsUncheckedUpdateWithoutDailiesInput>
  }

  export type JobsUpdateManyWithWhereWithoutDailiesInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutDailiesInput>
  }

  export type CustomersCreateWithoutJobsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutJobsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutJobsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
  }

  export type DailiesCreateWithoutJobsInput = {
    Week: string
    LastPrinted?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutDailiesInput
  }

  export type DailiesUncheckedCreateWithoutJobsInput = {
    ID?: number
    DriverID: number
    Week: string
    LastPrinted?: Date | string | null
  }

  export type DailiesCreateOrConnectWithoutJobsInput = {
    where: DailiesWhereUniqueInput
    create: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
  }

  export type DeliveryLocationsCreateWithoutJobsInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutJobsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutJobsInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
  }

  export type DriversCreateWithoutJobsInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutJobsInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutJobsInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
  }

  export type LoadTypesCreateWithoutJobsInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutJobsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutJobsInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
  }

  export type PayStubsCreateWithoutJobsInput = {
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutPayStubsInput
  }

  export type PayStubsUncheckedCreateWithoutJobsInput = {
    ID?: number
    Created?: Date | string
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
  }

  export type PayStubsCreateOrConnectWithoutJobsInput = {
    where: PayStubsWhereUniqueInput
    create: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
  }

  export type WeekliesCreateWithoutJobsInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutJobsInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type WeekliesCreateOrConnectWithoutJobsInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
  }

  export type LoadsCreateWithoutJobsInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutJobsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutJobsInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput>
  }

  export type LoadsCreateManyJobsInputEnvelope = {
    data: LoadsCreateManyJobsInput | LoadsCreateManyJobsInput[]
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutJobsInput = {
    update: XOR<CustomersUpdateWithoutJobsInput, CustomersUncheckedUpdateWithoutJobsInput>
    create: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutJobsInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutJobsInput, CustomersUncheckedUpdateWithoutJobsInput>
  }

  export type CustomersUpdateWithoutJobsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DailiesUpsertWithoutJobsInput = {
    update: XOR<DailiesUpdateWithoutJobsInput, DailiesUncheckedUpdateWithoutJobsInput>
    create: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
    where?: DailiesWhereInput
  }

  export type DailiesUpdateToOneWithWhereWithoutJobsInput = {
    where?: DailiesWhereInput
    data: XOR<DailiesUpdateWithoutJobsInput, DailiesUncheckedUpdateWithoutJobsInput>
  }

  export type DailiesUpdateWithoutJobsInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryLocationsUpsertWithoutJobsInput = {
    update: XOR<DeliveryLocationsUpdateWithoutJobsInput, DeliveryLocationsUncheckedUpdateWithoutJobsInput>
    create: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
    where?: DeliveryLocationsWhereInput
  }

  export type DeliveryLocationsUpdateToOneWithWhereWithoutJobsInput = {
    where?: DeliveryLocationsWhereInput
    data: XOR<DeliveryLocationsUpdateWithoutJobsInput, DeliveryLocationsUncheckedUpdateWithoutJobsInput>
  }

  export type DeliveryLocationsUpdateWithoutJobsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DriversUpsertWithoutJobsInput = {
    update: XOR<DriversUpdateWithoutJobsInput, DriversUncheckedUpdateWithoutJobsInput>
    create: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
    where?: DriversWhereInput
  }

  export type DriversUpdateToOneWithWhereWithoutJobsInput = {
    where?: DriversWhereInput
    data: XOR<DriversUpdateWithoutJobsInput, DriversUncheckedUpdateWithoutJobsInput>
  }

  export type DriversUpdateWithoutJobsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type LoadTypesUpsertWithoutJobsInput = {
    update: XOR<LoadTypesUpdateWithoutJobsInput, LoadTypesUncheckedUpdateWithoutJobsInput>
    create: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
    where?: LoadTypesWhereInput
  }

  export type LoadTypesUpdateToOneWithWhereWithoutJobsInput = {
    where?: LoadTypesWhereInput
    data: XOR<LoadTypesUpdateWithoutJobsInput, LoadTypesUncheckedUpdateWithoutJobsInput>
  }

  export type LoadTypesUpdateWithoutJobsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type PayStubsUpsertWithoutJobsInput = {
    update: XOR<PayStubsUpdateWithoutJobsInput, PayStubsUncheckedUpdateWithoutJobsInput>
    create: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
    where?: PayStubsWhereInput
  }

  export type PayStubsUpdateToOneWithWhereWithoutJobsInput = {
    where?: PayStubsWhereInput
    data: XOR<PayStubsUpdateWithoutJobsInput, PayStubsUncheckedUpdateWithoutJobsInput>
  }

  export type PayStubsUpdateWithoutJobsInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverID?: IntFieldUpdateOperationsInput | number
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WeekliesUpsertWithoutJobsInput = {
    update: XOR<WeekliesUpdateWithoutJobsInput, WeekliesUncheckedUpdateWithoutJobsInput>
    create: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
    where?: WeekliesWhereInput
  }

  export type WeekliesUpdateToOneWithWhereWithoutJobsInput = {
    where?: WeekliesWhereInput
    data: XOR<WeekliesUpdateWithoutJobsInput, WeekliesUncheckedUpdateWithoutJobsInput>
  }

  export type WeekliesUpdateWithoutJobsInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUpsertWithWhereUniqueWithoutJobsInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutJobsInput, LoadsUncheckedUpdateWithoutJobsInput>
    create: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutJobsInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutJobsInput, LoadsUncheckedUpdateWithoutJobsInput>
  }

  export type LoadsUpdateManyWithWhereWithoutJobsInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutJobsInput>
  }

  export type CustomersCreateWithoutWeekliesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutWeekliesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
  }

  export type DeliveryLocationsCreateWithoutWeekliesInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutWeekliesInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
  }

  export type InvoicesCreateWithoutWeekliesInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Customers: CustomersCreateNestedOneWithoutInvoicesInput
    Loads?: LoadsCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesCreateOrConnectWithoutWeekliesInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
  }

  export type LoadTypesCreateWithoutWeekliesInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutWeekliesInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
  }

  export type JobsCreateWithoutWeekliesInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutWeekliesInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput>
  }

  export type JobsCreateManyWeekliesInputEnvelope = {
    data: JobsCreateManyWeekliesInput | JobsCreateManyWeekliesInput[]
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutWeekliesInput = {
    update: XOR<CustomersUpdateWithoutWeekliesInput, CustomersUncheckedUpdateWithoutWeekliesInput>
    create: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutWeekliesInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutWeekliesInput, CustomersUncheckedUpdateWithoutWeekliesInput>
  }

  export type CustomersUpdateWithoutWeekliesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DeliveryLocationsUpsertWithoutWeekliesInput = {
    update: XOR<DeliveryLocationsUpdateWithoutWeekliesInput, DeliveryLocationsUncheckedUpdateWithoutWeekliesInput>
    create: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
    where?: DeliveryLocationsWhereInput
  }

  export type DeliveryLocationsUpdateToOneWithWhereWithoutWeekliesInput = {
    where?: DeliveryLocationsWhereInput
    data: XOR<DeliveryLocationsUpdateWithoutWeekliesInput, DeliveryLocationsUncheckedUpdateWithoutWeekliesInput>
  }

  export type DeliveryLocationsUpdateWithoutWeekliesInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type InvoicesUpsertWithoutWeekliesInput = {
    update: XOR<InvoicesUpdateWithoutWeekliesInput, InvoicesUncheckedUpdateWithoutWeekliesInput>
    create: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
    where?: InvoicesWhereInput
  }

  export type InvoicesUpdateToOneWithWhereWithoutWeekliesInput = {
    where?: InvoicesWhereInput
    data: XOR<InvoicesUpdateWithoutWeekliesInput, InvoicesUncheckedUpdateWithoutWeekliesInput>
  }

  export type InvoicesUpdateWithoutWeekliesInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutInvoicesNestedInput
    Loads?: LoadsUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type LoadTypesUpsertWithoutWeekliesInput = {
    update: XOR<LoadTypesUpdateWithoutWeekliesInput, LoadTypesUncheckedUpdateWithoutWeekliesInput>
    create: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
    where?: LoadTypesWhereInput
  }

  export type LoadTypesUpdateToOneWithWhereWithoutWeekliesInput = {
    where?: LoadTypesWhereInput
    data: XOR<LoadTypesUpdateWithoutWeekliesInput, LoadTypesUncheckedUpdateWithoutWeekliesInput>
  }

  export type LoadTypesUpdateWithoutWeekliesInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type JobsUpsertWithWhereUniqueWithoutWeekliesInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutWeekliesInput, JobsUncheckedUpdateWithoutWeekliesInput>
    create: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutWeekliesInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutWeekliesInput, JobsUncheckedUpdateWithoutWeekliesInput>
  }

  export type JobsUpdateManyWithWhereWithoutWeekliesInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutWeekliesInput>
  }

  export type DriversCreateWithoutPayStubsInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutPayStubsInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutPayStubsInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
  }

  export type JobsCreateWithoutPayStubsInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutPayStubsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutPayStubsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput>
  }

  export type JobsCreateManyPayStubsInputEnvelope = {
    data: JobsCreateManyPayStubsInput | JobsCreateManyPayStubsInput[]
    skipDuplicates?: boolean
  }

  export type DriversUpsertWithoutPayStubsInput = {
    update: XOR<DriversUpdateWithoutPayStubsInput, DriversUncheckedUpdateWithoutPayStubsInput>
    create: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
    where?: DriversWhereInput
  }

  export type DriversUpdateToOneWithWhereWithoutPayStubsInput = {
    where?: DriversWhereInput
    data: XOR<DriversUpdateWithoutPayStubsInput, DriversUncheckedUpdateWithoutPayStubsInput>
  }

  export type DriversUpdateWithoutPayStubsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutPayStubsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type JobsUpsertWithWhereUniqueWithoutPayStubsInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutPayStubsInput, JobsUncheckedUpdateWithoutPayStubsInput>
    create: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutPayStubsInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutPayStubsInput, JobsUncheckedUpdateWithoutPayStubsInput>
  }

  export type JobsUpdateManyWithWhereWithoutPayStubsInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutPayStubsInput>
  }

  export type CustomerDeliveryLocationsCreateManyCustomersInput = {
    ID?: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerLoadTypesCreateManyCustomersInput = {
    ID?: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type DeliveryLocationsCreateManyCustomersInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
  }

  export type InvoicesCreateManyCustomersInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
  }

  export type JobsCreateManyCustomersInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyCustomersInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyCustomersInput = {
    ID?: number
    Week: string
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type CustomerDeliveryLocationsUpdateWithoutCustomersInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
  }

  export type CustomerDeliveryLocationsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesUpdateWithoutCustomersInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
  }

  export type CustomerLoadTypesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLocationsUpdateWithoutCustomersInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InvoicesUpdateWithoutCustomersInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JobsUpdateWithoutCustomersInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadsUpdateWithoutCustomersInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutCustomersInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerDeliveryLocationsCreateManyDeliveryLocationsInput = {
    ID?: number
    CustomerID: number
    DateUsed: Date | string
  }

  export type JobsCreateManyDeliveryLocationsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyDeliveryLocationsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyDeliveryLocationsInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type CustomerDeliveryLocationsUpdateWithoutDeliveryLocationsInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
  }

  export type CustomerDeliveryLocationsUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsUpdateWithoutDeliveryLocationsInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadsUpdateWithoutDeliveryLocationsInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutDeliveryLocationsInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateManyWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DailiesCreateManyDriversInput = {
    ID?: number
    Week: string
    LastPrinted?: Date | string | null
  }

  export type JobsCreateManyDriversInput = {
    ID?: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyDriversInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type PayStubsCreateManyDriversInput = {
    ID?: number
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
  }

  export type TrucksDrivenCreateManyDriversInput = {
    ID?: number
    TruckID: number
    DateDriven: Date | string
  }

  export type DailiesUpdateWithoutDriversInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateManyWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobsUpdateWithoutDriversInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadsUpdateWithoutDriversInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PayStubsUpdateWithoutDriversInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateManyWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrucksDrivenUpdateWithoutDriversInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
    Trucks?: TrucksUpdateOneRequiredWithoutTrucksDrivenNestedInput
  }

  export type TrucksDrivenUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrucksDrivenUncheckedUpdateManyWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoadsCreateManyInvoicesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyInvoicesInput = {
    ID?: number
    Week: string
    CustomerID: number
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type LoadsUpdateWithoutInvoicesInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutInvoicesInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateManyWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerLoadTypesCreateManyLoadTypesInput = {
    ID?: number
    CustomerID: number
    DateDelivered: Date | string
  }

  export type JobsCreateManyLoadTypesInput = {
    ID?: number
    DriverID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyLoadTypesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyLoadTypesInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type CustomerLoadTypesUpdateWithoutLoadTypesInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
  }

  export type CustomerLoadTypesUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsUpdateWithoutLoadTypesInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadsUpdateWithoutLoadTypesInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutLoadTypesInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateManyWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomersCreateManyStatesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
  }

  export type DriversCreateManyStatesInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
  }

  export type CustomersUpdateWithoutStatesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutStatesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateManyWithoutStatesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DriversUpdateWithoutStatesInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutStatesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateManyWithoutStatesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LoadsCreateManyTrucksInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type TrucksDrivenCreateManyTrucksInput = {
    ID?: number
    DriverID: number
    DateDriven: Date | string
  }

  export type LoadsUpdateWithoutTrucksInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutTrucksInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutTrucksInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TrucksDrivenUpdateWithoutTrucksInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
    Drivers?: DriversUpdateOneRequiredWithoutTrucksDrivenNestedInput
  }

  export type TrucksDrivenUncheckedUpdateWithoutTrucksInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrucksDrivenUncheckedUpdateManyWithoutTrucksInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsCreateManyDailiesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsUpdateWithoutDailiesInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutDailiesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutDailiesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadsCreateManyJobsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsUpdateWithoutJobsInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobsCreateManyWeekliesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsUpdateWithoutWeekliesInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JobsCreateManyPayStubsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
  }

  export type JobsUpdateWithoutPayStubsInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutPayStubsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutPayStubsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}