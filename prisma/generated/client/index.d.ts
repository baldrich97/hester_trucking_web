
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  email: string
  organization: string
  password: string
  username: string
}

/**
 * Model CustomerLoadTypes
 * 
 */
export type CustomerLoadTypes = {
  ID: number
  CustomerID: number
  LoadTypeID: number
  /**
   * @zod.custom(z.coerce.date())
   */
  DateDelivered: Date
}

/**
 * Model Customers
 * 
 */
export type Customers = {
  ID: number
  /**
   * @zod.min(1)
   */
  Name: string
  /**
   * @zod.min(1)
   */
  Street: string
  /**
   * @zod.min(1)
   */
  City: string
  /**
   * @zod.min(1)
   */
  State: number
  /**
   * @zod.min(1)
   */
  ZIP: string
  Phone: string | null
  Email: string | null
  Notes: string | null
  MainContact: string | null
  Deleted: boolean | null
}

/**
 * Model DeliveryLocations
 * 
 */
export type DeliveryLocations = {
  ID: number
  Description: string
  Deleted: boolean | null
  CustomerID: number | null
}

/**
 * Model Drivers
 * 
 */
export type Drivers = {
  ID: number
  /**
   * @zod.min(1)
   */
  FirstName: string
  MiddleName: string | null
  /**
   * @zod.min(1)
   */
  LastName: string
  Street: string | null
  City: string | null
  State: number | null
  ZIP: string | null
  DOB: Date | null
  License: string | null
  Email: string | null
  Phone: string | null
  Notes: string | null
  Deleted: boolean | null
  HireDate: string | null
  OwnerOperator: boolean
}

/**
 * Model Invoices
 * 
 */
export type Invoices = {
  ID: number
  /**
   * @zod.custom(z.coerce.date())
   */
  InvoiceDate: Date
  Number: number | null
  /**
   * @zod.min(1)
   */
  CustomerID: number
  /**
   * @zod.min(1)
   */
  TotalAmount: number
  /**
   * @zod.custom(z.coerce.date())
   */
  PaidDate: Date | null
  CheckNumber: string | null
  Paid: boolean | null
  Printed: boolean | null
  Deleted: boolean | null
  PaymentType: string | null
  Consolidated: boolean | null
  ConsolidatedID: number | null
}

/**
 * Model LoadTypes
 * 
 */
export type LoadTypes = {
  ID: number
  /**
   * @zod.min(1)
   */
  Description: string
  Deleted: boolean | null
  SourceID: number | null
  Notes: string | null
}

/**
 * Model States
 * 
 */
export type States = {
  ID: number
  Name: string
  Abbreviation: string
}

/**
 * Model Trucks
 * 
 */
export type Trucks = {
  ID: number
  /**
   * @zod.min(1)
   */
  Name: string
  VIN: string | null
  Deleted: boolean | null
  Notes: string | null
}

/**
 * Model TrucksDriven
 * 
 */
export type TrucksDriven = {
  ID: number
  TruckID: number
  DriverID: number
  /**
   * @zod.custom(z.coerce.date())
   */
  DateDriven: Date
}

/**
 * Model Loads
 * 
 */
export type Loads = {
  ID: number
  /**
   * @zod.custom(z.coerce.date())
   */
  StartDate: Date
  /**
   * @zod.custom(z.coerce.date())
   */
  Created: Date
  /**
   * @zod.custom(z.coerce.number())
   */
  Weight: number | null
  /**
   * @zod.custom(z.coerce.number())
   */
  Hours: number | null
  /**
   * @zod.custom(z.coerce.number())
   */
  TotalRate: number | null
  /**
   * @zod.custom(z.coerce.number())
   */
  TotalAmount: number | null
  /**
   * @zod.custom(z.coerce.number())
   */
  TruckRate: number | null
  /**
   * @zod.custom(z.coerce.number())
   */
  MaterialRate: number | null
  Received: string | null
  Notes: string | null
  TicketNumber: number
  Invoiced: boolean | null
  /**
   * @zod.min(1)
   */
  CustomerID: number
  /**
   * @zod.min(1)
   */
  InvoiceID: number | null
  /**
   * @zod.min(1)
   */
  LoadTypeID: number | null
  DeliveryLocationID: number | null
  TruckID: number | null
  DriverID: number | null
  Deleted: boolean | null
  JobID: number | null
  Week: string
  DriverRate: number | null
}

/**
 * Model CustomerDeliveryLocations
 * 
 */
export type CustomerDeliveryLocations = {
  ID: number
  CustomerID: number
  DeliveryLocationID: number
  /**
   * @zod.custom(z.coerce.date())
   */
  DateUsed: Date
}

/**
 * Model Dailies
 * 
 */
export type Dailies = {
  ID: number
  DriverID: number
  Week: string
  LastPrinted: Date | null
}

/**
 * Model Jobs
 * 
 */
export type Jobs = {
  ID: number
  DriverID: number
  LoadTypeID: number
  CustomerID: number
  PaidOut: boolean
  TruckingRevenue: number | null
  CompanyRevenue: number | null
  TruckingRate: number
  CompanyRate: number
  DeliveryLocationID: number
  WeeklyID: number
  DailyID: number
  MaterialRate: number
  DriverRate: number
  PayStubID: number | null
}

/**
 * Model Weeklies
 * 
 */
export type Weeklies = {
  ID: number
  Week: string
  CustomerID: number
  InvoiceID: number | null
  CompanyRate: number | null
  Revenue: number | null
  LoadTypeID: number
  DeliveryLocationID: number
  LastPrinted: Date | null
  TotalWeight: number | null
}

/**
 * Model PayStubs
 * 
 */
export type PayStubs = {
  ID: number
  /**
   * @zod.custom(z.coerce.date())
   */
  Created: Date
  DriverID: number
  CheckNumber: string
  /**
   * @zod.custom(z.coerce.number())
   */
  Gross: number
  /**
   * @zod.custom(z.coerce.number())
   */
  Percentage: number
  /**
   * @zod.custom(z.coerce.number())
   */
  NetTotal: number
  /**
   * @zod.custom(z.coerce.date())
   */
  LastPrinted: Date | null
  /**
   * @zod.custom(z.coerce.number())
   */
  TakeHome: number
  Deductions: number
  Additions: number
  Notes: string | null
  /**
   * @zod.custom(z.coerce.date())
   */
  DepositDate: Date | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.customerLoadTypes`: Exposes CRUD operations for the **CustomerLoadTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerLoadTypes
    * const customerLoadTypes = await prisma.customerLoadTypes.findMany()
    * ```
    */
  get customerLoadTypes(): Prisma.CustomerLoadTypesDelegate<GlobalReject>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<GlobalReject>;

  /**
   * `prisma.deliveryLocations`: Exposes CRUD operations for the **DeliveryLocations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryLocations
    * const deliveryLocations = await prisma.deliveryLocations.findMany()
    * ```
    */
  get deliveryLocations(): Prisma.DeliveryLocationsDelegate<GlobalReject>;

  /**
   * `prisma.drivers`: Exposes CRUD operations for the **Drivers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.drivers.findMany()
    * ```
    */
  get drivers(): Prisma.DriversDelegate<GlobalReject>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **Invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoices.findMany()
    * ```
    */
  get invoices(): Prisma.InvoicesDelegate<GlobalReject>;

  /**
   * `prisma.loadTypes`: Exposes CRUD operations for the **LoadTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoadTypes
    * const loadTypes = await prisma.loadTypes.findMany()
    * ```
    */
  get loadTypes(): Prisma.LoadTypesDelegate<GlobalReject>;

  /**
   * `prisma.states`: Exposes CRUD operations for the **States** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.states.findMany()
    * ```
    */
  get states(): Prisma.StatesDelegate<GlobalReject>;

  /**
   * `prisma.trucks`: Exposes CRUD operations for the **Trucks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trucks
    * const trucks = await prisma.trucks.findMany()
    * ```
    */
  get trucks(): Prisma.TrucksDelegate<GlobalReject>;

  /**
   * `prisma.trucksDriven`: Exposes CRUD operations for the **TrucksDriven** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrucksDrivens
    * const trucksDrivens = await prisma.trucksDriven.findMany()
    * ```
    */
  get trucksDriven(): Prisma.TrucksDrivenDelegate<GlobalReject>;

  /**
   * `prisma.loads`: Exposes CRUD operations for the **Loads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loads
    * const loads = await prisma.loads.findMany()
    * ```
    */
  get loads(): Prisma.LoadsDelegate<GlobalReject>;

  /**
   * `prisma.customerDeliveryLocations`: Exposes CRUD operations for the **CustomerDeliveryLocations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerDeliveryLocations
    * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findMany()
    * ```
    */
  get customerDeliveryLocations(): Prisma.CustomerDeliveryLocationsDelegate<GlobalReject>;

  /**
   * `prisma.dailies`: Exposes CRUD operations for the **Dailies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dailies
    * const dailies = await prisma.dailies.findMany()
    * ```
    */
  get dailies(): Prisma.DailiesDelegate<GlobalReject>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.JobsDelegate<GlobalReject>;

  /**
   * `prisma.weeklies`: Exposes CRUD operations for the **Weeklies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weeklies
    * const weeklies = await prisma.weeklies.findMany()
    * ```
    */
  get weeklies(): Prisma.WeekliesDelegate<GlobalReject>;

  /**
   * `prisma.payStubs`: Exposes CRUD operations for the **PayStubs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayStubs
    * const payStubs = await prisma.payStubs.findMany()
    * ```
    */
  get payStubs(): Prisma.PayStubsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.3.0
   * Query Engine version: c875e43600dfe042452e0b868f7a48b817b9640b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    CustomerLoadTypes: 'CustomerLoadTypes',
    Customers: 'Customers',
    DeliveryLocations: 'DeliveryLocations',
    Drivers: 'Drivers',
    Invoices: 'Invoices',
    LoadTypes: 'LoadTypes',
    States: 'States',
    Trucks: 'Trucks',
    TrucksDriven: 'TrucksDriven',
    Loads: 'Loads',
    CustomerDeliveryLocations: 'CustomerDeliveryLocations',
    Dailies: 'Dailies',
    Jobs: 'Jobs',
    Weeklies: 'Weeklies',
    PayStubs: 'PayStubs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;


  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomersCountOutputType
   */


  export type CustomersCountOutputType = {
    CustomerDeliveryLocations: number
    CustomerLoadTypes: number
    DeliveryLocations: number
    Invoices: number
    Jobs: number
    Loads: number
    Weeklies: number
  }

  export type CustomersCountOutputTypeSelect = {
    CustomerDeliveryLocations?: boolean
    CustomerLoadTypes?: boolean
    DeliveryLocations?: boolean
    Invoices?: boolean
    Jobs?: boolean
    Loads?: boolean
    Weeklies?: boolean
  }

  export type CustomersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CustomersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CustomersCountOutputType
    : S extends undefined
    ? never
    : S extends CustomersCountOutputTypeArgs
    ?'include' extends U
    ? CustomersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CustomersCountOutputType ? CustomersCountOutputType[P] : never
  } 
    : CustomersCountOutputType
  : CustomersCountOutputType




  // Custom InputTypes

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     * 
    **/
    select?: CustomersCountOutputTypeSelect | null
  }



  /**
   * Count Type DeliveryLocationsCountOutputType
   */


  export type DeliveryLocationsCountOutputType = {
    CustomerDeliveryLocations: number
    Jobs: number
    Loads: number
    Weeklies: number
  }

  export type DeliveryLocationsCountOutputTypeSelect = {
    CustomerDeliveryLocations?: boolean
    Jobs?: boolean
    Loads?: boolean
    Weeklies?: boolean
  }

  export type DeliveryLocationsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DeliveryLocationsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DeliveryLocationsCountOutputType
    : S extends undefined
    ? never
    : S extends DeliveryLocationsCountOutputTypeArgs
    ?'include' extends U
    ? DeliveryLocationsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DeliveryLocationsCountOutputType ? DeliveryLocationsCountOutputType[P] : never
  } 
    : DeliveryLocationsCountOutputType
  : DeliveryLocationsCountOutputType




  // Custom InputTypes

  /**
   * DeliveryLocationsCountOutputType without action
   */
  export type DeliveryLocationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeliveryLocationsCountOutputType
     * 
    **/
    select?: DeliveryLocationsCountOutputTypeSelect | null
  }



  /**
   * Count Type DriversCountOutputType
   */


  export type DriversCountOutputType = {
    Dailies: number
    Jobs: number
    Loads: number
    PayStubs: number
    TrucksDriven: number
  }

  export type DriversCountOutputTypeSelect = {
    Dailies?: boolean
    Jobs?: boolean
    Loads?: boolean
    PayStubs?: boolean
    TrucksDriven?: boolean
  }

  export type DriversCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DriversCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DriversCountOutputType
    : S extends undefined
    ? never
    : S extends DriversCountOutputTypeArgs
    ?'include' extends U
    ? DriversCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DriversCountOutputType ? DriversCountOutputType[P] : never
  } 
    : DriversCountOutputType
  : DriversCountOutputType




  // Custom InputTypes

  /**
   * DriversCountOutputType without action
   */
  export type DriversCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DriversCountOutputType
     * 
    **/
    select?: DriversCountOutputTypeSelect | null
  }



  /**
   * Count Type InvoicesCountOutputType
   */


  export type InvoicesCountOutputType = {
    Loads: number
    Weeklies: number
  }

  export type InvoicesCountOutputTypeSelect = {
    Loads?: boolean
    Weeklies?: boolean
  }

  export type InvoicesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InvoicesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InvoicesCountOutputType
    : S extends undefined
    ? never
    : S extends InvoicesCountOutputTypeArgs
    ?'include' extends U
    ? InvoicesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InvoicesCountOutputType ? InvoicesCountOutputType[P] : never
  } 
    : InvoicesCountOutputType
  : InvoicesCountOutputType




  // Custom InputTypes

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InvoicesCountOutputType
     * 
    **/
    select?: InvoicesCountOutputTypeSelect | null
  }



  /**
   * Count Type LoadTypesCountOutputType
   */


  export type LoadTypesCountOutputType = {
    CustomerLoadTypes: number
    Jobs: number
    Loads: number
    Weeklies: number
  }

  export type LoadTypesCountOutputTypeSelect = {
    CustomerLoadTypes?: boolean
    Jobs?: boolean
    Loads?: boolean
    Weeklies?: boolean
  }

  export type LoadTypesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LoadTypesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LoadTypesCountOutputType
    : S extends undefined
    ? never
    : S extends LoadTypesCountOutputTypeArgs
    ?'include' extends U
    ? LoadTypesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LoadTypesCountOutputType ? LoadTypesCountOutputType[P] : never
  } 
    : LoadTypesCountOutputType
  : LoadTypesCountOutputType




  // Custom InputTypes

  /**
   * LoadTypesCountOutputType without action
   */
  export type LoadTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LoadTypesCountOutputType
     * 
    **/
    select?: LoadTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type StatesCountOutputType
   */


  export type StatesCountOutputType = {
    Customers: number
    Drivers: number
  }

  export type StatesCountOutputTypeSelect = {
    Customers?: boolean
    Drivers?: boolean
  }

  export type StatesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StatesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StatesCountOutputType
    : S extends undefined
    ? never
    : S extends StatesCountOutputTypeArgs
    ?'include' extends U
    ? StatesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StatesCountOutputType ? StatesCountOutputType[P] : never
  } 
    : StatesCountOutputType
  : StatesCountOutputType




  // Custom InputTypes

  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StatesCountOutputType
     * 
    **/
    select?: StatesCountOutputTypeSelect | null
  }



  /**
   * Count Type TrucksCountOutputType
   */


  export type TrucksCountOutputType = {
    Loads: number
    TrucksDriven: number
  }

  export type TrucksCountOutputTypeSelect = {
    Loads?: boolean
    TrucksDriven?: boolean
  }

  export type TrucksCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TrucksCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TrucksCountOutputType
    : S extends undefined
    ? never
    : S extends TrucksCountOutputTypeArgs
    ?'include' extends U
    ? TrucksCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TrucksCountOutputType ? TrucksCountOutputType[P] : never
  } 
    : TrucksCountOutputType
  : TrucksCountOutputType




  // Custom InputTypes

  /**
   * TrucksCountOutputType without action
   */
  export type TrucksCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TrucksCountOutputType
     * 
    **/
    select?: TrucksCountOutputTypeSelect | null
  }



  /**
   * Count Type DailiesCountOutputType
   */


  export type DailiesCountOutputType = {
    Jobs: number
  }

  export type DailiesCountOutputTypeSelect = {
    Jobs?: boolean
  }

  export type DailiesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DailiesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DailiesCountOutputType
    : S extends undefined
    ? never
    : S extends DailiesCountOutputTypeArgs
    ?'include' extends U
    ? DailiesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DailiesCountOutputType ? DailiesCountOutputType[P] : never
  } 
    : DailiesCountOutputType
  : DailiesCountOutputType




  // Custom InputTypes

  /**
   * DailiesCountOutputType without action
   */
  export type DailiesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DailiesCountOutputType
     * 
    **/
    select?: DailiesCountOutputTypeSelect | null
  }



  /**
   * Count Type JobsCountOutputType
   */


  export type JobsCountOutputType = {
    Loads: number
  }

  export type JobsCountOutputTypeSelect = {
    Loads?: boolean
  }

  export type JobsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | JobsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? JobsCountOutputType
    : S extends undefined
    ? never
    : S extends JobsCountOutputTypeArgs
    ?'include' extends U
    ? JobsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof JobsCountOutputType ? JobsCountOutputType[P] : never
  } 
    : JobsCountOutputType
  : JobsCountOutputType




  // Custom InputTypes

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the JobsCountOutputType
     * 
    **/
    select?: JobsCountOutputTypeSelect | null
  }



  /**
   * Count Type WeekliesCountOutputType
   */


  export type WeekliesCountOutputType = {
    Jobs: number
  }

  export type WeekliesCountOutputTypeSelect = {
    Jobs?: boolean
  }

  export type WeekliesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WeekliesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WeekliesCountOutputType
    : S extends undefined
    ? never
    : S extends WeekliesCountOutputTypeArgs
    ?'include' extends U
    ? WeekliesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WeekliesCountOutputType ? WeekliesCountOutputType[P] : never
  } 
    : WeekliesCountOutputType
  : WeekliesCountOutputType




  // Custom InputTypes

  /**
   * WeekliesCountOutputType without action
   */
  export type WeekliesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WeekliesCountOutputType
     * 
    **/
    select?: WeekliesCountOutputTypeSelect | null
  }



  /**
   * Count Type PayStubsCountOutputType
   */


  export type PayStubsCountOutputType = {
    Jobs: number
  }

  export type PayStubsCountOutputTypeSelect = {
    Jobs?: boolean
  }

  export type PayStubsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PayStubsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PayStubsCountOutputType
    : S extends undefined
    ? never
    : S extends PayStubsCountOutputTypeArgs
    ?'include' extends U
    ? PayStubsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PayStubsCountOutputType ? PayStubsCountOutputType[P] : never
  } 
    : PayStubsCountOutputType
  : PayStubsCountOutputType




  // Custom InputTypes

  /**
   * PayStubsCountOutputType without action
   */
  export type PayStubsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PayStubsCountOutputType
     * 
    **/
    select?: PayStubsCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    organization: string | null
    password: string | null
    username: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    organization: string | null
    password: string | null
    username: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    organization: number
    password: number
    username: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    organization?: true
    password?: true
    username?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    organization?: true
    password?: true
    username?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    organization?: true
    password?: true
    username?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    organization: string
    password: string
    username: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    organization?: boolean
    password?: boolean
    username?: boolean
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
  }



  /**
   * Model CustomerLoadTypes
   */


  export type AggregateCustomerLoadTypes = {
    _count: CustomerLoadTypesCountAggregateOutputType | null
    _avg: CustomerLoadTypesAvgAggregateOutputType | null
    _sum: CustomerLoadTypesSumAggregateOutputType | null
    _min: CustomerLoadTypesMinAggregateOutputType | null
    _max: CustomerLoadTypesMaxAggregateOutputType | null
  }

  export type CustomerLoadTypesAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
  }

  export type CustomerLoadTypesSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
  }

  export type CustomerLoadTypesMinAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
    DateDelivered: Date | null
  }

  export type CustomerLoadTypesMaxAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    LoadTypeID: number | null
    DateDelivered: Date | null
  }

  export type CustomerLoadTypesCountAggregateOutputType = {
    ID: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: number
    _all: number
  }


  export type CustomerLoadTypesAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
  }

  export type CustomerLoadTypesSumAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
  }

  export type CustomerLoadTypesMinAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
    DateDelivered?: true
  }

  export type CustomerLoadTypesMaxAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
    DateDelivered?: true
  }

  export type CustomerLoadTypesCountAggregateInputType = {
    ID?: true
    CustomerID?: true
    LoadTypeID?: true
    DateDelivered?: true
    _all?: true
  }

  export type CustomerLoadTypesAggregateArgs = {
    /**
     * Filter which CustomerLoadTypes to aggregate.
     * 
    **/
    where?: CustomerLoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLoadTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerLoadTypesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerLoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLoadTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLoadTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerLoadTypes
    **/
    _count?: true | CustomerLoadTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerLoadTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerLoadTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerLoadTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerLoadTypesMaxAggregateInputType
  }

  export type GetCustomerLoadTypesAggregateType<T extends CustomerLoadTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerLoadTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerLoadTypes[P]>
      : GetScalarType<T[P], AggregateCustomerLoadTypes[P]>
  }




  export type CustomerLoadTypesGroupByArgs = {
    where?: CustomerLoadTypesWhereInput
    orderBy?: Enumerable<CustomerLoadTypesOrderByWithAggregationInput>
    by: Array<CustomerLoadTypesScalarFieldEnum>
    having?: CustomerLoadTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerLoadTypesCountAggregateInputType | true
    _avg?: CustomerLoadTypesAvgAggregateInputType
    _sum?: CustomerLoadTypesSumAggregateInputType
    _min?: CustomerLoadTypesMinAggregateInputType
    _max?: CustomerLoadTypesMaxAggregateInputType
  }


  export type CustomerLoadTypesGroupByOutputType = {
    ID: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: Date
    _count: CustomerLoadTypesCountAggregateOutputType | null
    _avg: CustomerLoadTypesAvgAggregateOutputType | null
    _sum: CustomerLoadTypesSumAggregateOutputType | null
    _min: CustomerLoadTypesMinAggregateOutputType | null
    _max: CustomerLoadTypesMaxAggregateOutputType | null
  }

  type GetCustomerLoadTypesGroupByPayload<T extends CustomerLoadTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerLoadTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerLoadTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerLoadTypesGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerLoadTypesGroupByOutputType[P]>
        }
      >
    >


  export type CustomerLoadTypesSelect = {
    ID?: boolean
    CustomerID?: boolean
    LoadTypeID?: boolean
    DateDelivered?: boolean
    Customers?: boolean | CustomersArgs
    LoadTypes?: boolean | LoadTypesArgs
  }

  export type CustomerLoadTypesInclude = {
    Customers?: boolean | CustomersArgs
    LoadTypes?: boolean | LoadTypesArgs
  }

  export type CustomerLoadTypesGetPayload<
    S extends boolean | null | undefined | CustomerLoadTypesArgs,
    U = keyof S
      > = S extends true
        ? CustomerLoadTypes
    : S extends undefined
    ? never
    : S extends CustomerLoadTypesArgs | CustomerLoadTypesFindManyArgs
    ?'include' extends U
    ? CustomerLoadTypes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? CustomersGetPayload<S['include'][P]> :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? CustomersGetPayload<S['select'][P]> :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['select'][P]> :  P extends keyof CustomerLoadTypes ? CustomerLoadTypes[P] : never
  } 
    : CustomerLoadTypes
  : CustomerLoadTypes


  type CustomerLoadTypesCountArgs = Merge<
    Omit<CustomerLoadTypesFindManyArgs, 'select' | 'include'> & {
      select?: CustomerLoadTypesCountAggregateInputType | true
    }
  >

  export interface CustomerLoadTypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CustomerLoadTypes that matches the filter.
     * @param {CustomerLoadTypesFindUniqueArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerLoadTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerLoadTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerLoadTypes'> extends True ? CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>> : CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes | null >, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T> | null >>

    /**
     * Find the first CustomerLoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesFindFirstArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerLoadTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerLoadTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerLoadTypes'> extends True ? CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>> : CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes | null >, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T> | null >>

    /**
     * Find zero or more CustomerLoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findMany()
     * 
     * // Get first 10 CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const customerLoadTypesWithIDOnly = await prisma.customerLoadTypes.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends CustomerLoadTypesFindManyArgs>(
      args?: SelectSubset<T, CustomerLoadTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CustomerLoadTypes>>, PrismaPromise<Array<CustomerLoadTypesGetPayload<T>>>>

    /**
     * Create a CustomerLoadTypes.
     * @param {CustomerLoadTypesCreateArgs} args - Arguments to create a CustomerLoadTypes.
     * @example
     * // Create one CustomerLoadTypes
     * const CustomerLoadTypes = await prisma.customerLoadTypes.create({
     *   data: {
     *     // ... data to create a CustomerLoadTypes
     *   }
     * })
     * 
    **/
    create<T extends CustomerLoadTypesCreateArgs>(
      args: SelectSubset<T, CustomerLoadTypesCreateArgs>
    ): CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>>

    /**
     * Create many CustomerLoadTypes.
     *     @param {CustomerLoadTypesCreateManyArgs} args - Arguments to create many CustomerLoadTypes.
     *     @example
     *     // Create many CustomerLoadTypes
     *     const customerLoadTypes = await prisma.customerLoadTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerLoadTypesCreateManyArgs>(
      args?: SelectSubset<T, CustomerLoadTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerLoadTypes.
     * @param {CustomerLoadTypesDeleteArgs} args - Arguments to delete one CustomerLoadTypes.
     * @example
     * // Delete one CustomerLoadTypes
     * const CustomerLoadTypes = await prisma.customerLoadTypes.delete({
     *   where: {
     *     // ... filter to delete one CustomerLoadTypes
     *   }
     * })
     * 
    **/
    delete<T extends CustomerLoadTypesDeleteArgs>(
      args: SelectSubset<T, CustomerLoadTypesDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>>

    /**
     * Update one CustomerLoadTypes.
     * @param {CustomerLoadTypesUpdateArgs} args - Arguments to update one CustomerLoadTypes.
     * @example
     * // Update one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerLoadTypesUpdateArgs>(
      args: SelectSubset<T, CustomerLoadTypesUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>>

    /**
     * Delete zero or more CustomerLoadTypes.
     * @param {CustomerLoadTypesDeleteManyArgs} args - Arguments to filter CustomerLoadTypes to delete.
     * @example
     * // Delete a few CustomerLoadTypes
     * const { count } = await prisma.customerLoadTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerLoadTypesDeleteManyArgs>(
      args?: SelectSubset<T, CustomerLoadTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerLoadTypesUpdateManyArgs>(
      args: SelectSubset<T, CustomerLoadTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerLoadTypes.
     * @param {CustomerLoadTypesUpsertArgs} args - Arguments to update or create a CustomerLoadTypes.
     * @example
     * // Update or create a CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.upsert({
     *   create: {
     *     // ... data to create a CustomerLoadTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerLoadTypes we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerLoadTypesUpsertArgs>(
      args: SelectSubset<T, CustomerLoadTypesUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>>

    /**
     * Find one CustomerLoadTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CustomerLoadTypesFindUniqueOrThrowArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerLoadTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerLoadTypesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>>

    /**
     * Find the first CustomerLoadTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesFindFirstOrThrowArgs} args - Arguments to find a CustomerLoadTypes
     * @example
     * // Get one CustomerLoadTypes
     * const customerLoadTypes = await prisma.customerLoadTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerLoadTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerLoadTypesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerLoadTypesClient<CustomerLoadTypes>, Prisma__CustomerLoadTypesClient<CustomerLoadTypesGetPayload<T>>>

    /**
     * Count the number of CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesCountArgs} args - Arguments to filter CustomerLoadTypes to count.
     * @example
     * // Count the number of CustomerLoadTypes
     * const count = await prisma.customerLoadTypes.count({
     *   where: {
     *     // ... the filter for the CustomerLoadTypes we want to count
     *   }
     * })
    **/
    count<T extends CustomerLoadTypesCountArgs>(
      args?: Subset<T, CustomerLoadTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerLoadTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerLoadTypesAggregateArgs>(args: Subset<T, CustomerLoadTypesAggregateArgs>): PrismaPromise<GetCustomerLoadTypesAggregateType<T>>

    /**
     * Group by CustomerLoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLoadTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerLoadTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerLoadTypesGroupByArgs['orderBy'] }
        : { orderBy?: CustomerLoadTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerLoadTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerLoadTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerLoadTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerLoadTypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    LoadTypes<T extends LoadTypesArgs = {}>(args?: Subset<T, LoadTypesArgs>): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes | null >, Prisma__LoadTypesClient<LoadTypesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerLoadTypes base type for findUnique actions
   */
  export type CustomerLoadTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     * 
    **/
    where: CustomerLoadTypesWhereUniqueInput
  }

  /**
   * CustomerLoadTypes: findUnique
   */
  export interface CustomerLoadTypesFindUniqueArgs extends CustomerLoadTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerLoadTypes base type for findFirst actions
   */
  export type CustomerLoadTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     * 
    **/
    where?: CustomerLoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLoadTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerLoadTypesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerLoadTypes.
     * 
    **/
    cursor?: CustomerLoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLoadTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLoadTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerLoadTypes.
     * 
    **/
    distinct?: Enumerable<CustomerLoadTypesScalarFieldEnum>
  }

  /**
   * CustomerLoadTypes: findFirst
   */
  export interface CustomerLoadTypesFindFirstArgs extends CustomerLoadTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerLoadTypes findMany
   */
  export type CustomerLoadTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
    /**
     * Filter, which CustomerLoadTypes to fetch.
     * 
    **/
    where?: CustomerLoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLoadTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerLoadTypesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerLoadTypes.
     * 
    **/
    cursor?: CustomerLoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLoadTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLoadTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerLoadTypesScalarFieldEnum>
  }


  /**
   * CustomerLoadTypes create
   */
  export type CustomerLoadTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
    /**
     * The data needed to create a CustomerLoadTypes.
     * 
    **/
    data: XOR<CustomerLoadTypesCreateInput, CustomerLoadTypesUncheckedCreateInput>
  }


  /**
   * CustomerLoadTypes createMany
   */
  export type CustomerLoadTypesCreateManyArgs = {
    /**
     * The data used to create many CustomerLoadTypes.
     * 
    **/
    data: Enumerable<CustomerLoadTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerLoadTypes update
   */
  export type CustomerLoadTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
    /**
     * The data needed to update a CustomerLoadTypes.
     * 
    **/
    data: XOR<CustomerLoadTypesUpdateInput, CustomerLoadTypesUncheckedUpdateInput>
    /**
     * Choose, which CustomerLoadTypes to update.
     * 
    **/
    where: CustomerLoadTypesWhereUniqueInput
  }


  /**
   * CustomerLoadTypes updateMany
   */
  export type CustomerLoadTypesUpdateManyArgs = {
    /**
     * The data used to update CustomerLoadTypes.
     * 
    **/
    data: XOR<CustomerLoadTypesUpdateManyMutationInput, CustomerLoadTypesUncheckedUpdateManyInput>
    /**
     * Filter which CustomerLoadTypes to update
     * 
    **/
    where?: CustomerLoadTypesWhereInput
  }


  /**
   * CustomerLoadTypes upsert
   */
  export type CustomerLoadTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
    /**
     * The filter to search for the CustomerLoadTypes to update in case it exists.
     * 
    **/
    where: CustomerLoadTypesWhereUniqueInput
    /**
     * In case the CustomerLoadTypes found by the `where` argument doesn't exist, create a new CustomerLoadTypes with this data.
     * 
    **/
    create: XOR<CustomerLoadTypesCreateInput, CustomerLoadTypesUncheckedCreateInput>
    /**
     * In case the CustomerLoadTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerLoadTypesUpdateInput, CustomerLoadTypesUncheckedUpdateInput>
  }


  /**
   * CustomerLoadTypes delete
   */
  export type CustomerLoadTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
    /**
     * Filter which CustomerLoadTypes to delete.
     * 
    **/
    where: CustomerLoadTypesWhereUniqueInput
  }


  /**
   * CustomerLoadTypes deleteMany
   */
  export type CustomerLoadTypesDeleteManyArgs = {
    /**
     * Filter which CustomerLoadTypes to delete
     * 
    **/
    where?: CustomerLoadTypesWhereInput
  }


  /**
   * CustomerLoadTypes: findUniqueOrThrow
   */
  export type CustomerLoadTypesFindUniqueOrThrowArgs = CustomerLoadTypesFindUniqueArgsBase
      

  /**
   * CustomerLoadTypes: findFirstOrThrow
   */
  export type CustomerLoadTypesFindFirstOrThrowArgs = CustomerLoadTypesFindFirstArgsBase
      

  /**
   * CustomerLoadTypes without action
   */
  export type CustomerLoadTypesArgs = {
    /**
     * Select specific fields to fetch from the CustomerLoadTypes
     * 
    **/
    select?: CustomerLoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerLoadTypesInclude | null
  }



  /**
   * Model Customers
   */


  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type CustomersSumAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type CustomersMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    Phone: string | null
    Email: string | null
    Notes: string | null
    MainContact: string | null
    Deleted: boolean | null
  }

  export type CustomersMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    Phone: string | null
    Email: string | null
    Notes: string | null
    MainContact: string | null
    Deleted: boolean | null
  }

  export type CustomersCountAggregateOutputType = {
    ID: number
    Name: number
    Street: number
    City: number
    State: number
    ZIP: number
    Phone: number
    Email: number
    Notes: number
    MainContact: number
    Deleted: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    ID?: true
    State?: true
  }

  export type CustomersSumAggregateInputType = {
    ID?: true
    State?: true
  }

  export type CustomersMinAggregateInputType = {
    ID?: true
    Name?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    Phone?: true
    Email?: true
    Notes?: true
    MainContact?: true
    Deleted?: true
  }

  export type CustomersMaxAggregateInputType = {
    ID?: true
    Name?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    Phone?: true
    Email?: true
    Notes?: true
    MainContact?: true
    Deleted?: true
  }

  export type CustomersCountAggregateInputType = {
    ID?: true
    Name?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    Phone?: true
    Email?: true
    Notes?: true
    MainContact?: true
    Deleted?: true
    _all?: true
  }

  export type CustomersAggregateArgs = {
    /**
     * Filter which Customers to aggregate.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs = {
    where?: CustomersWhereInput
    orderBy?: Enumerable<CustomersOrderByWithAggregationInput>
    by: Array<CustomersScalarFieldEnum>
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }


  export type CustomersGroupByOutputType = {
    ID: number
    Name: string
    Street: string
    City: string
    State: number
    ZIP: string
    Phone: string | null
    Email: string | null
    Notes: string | null
    MainContact: string | null
    Deleted: boolean | null
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect = {
    ID?: boolean
    Name?: boolean
    Street?: boolean
    City?: boolean
    State?: boolean
    ZIP?: boolean
    Phone?: boolean
    Email?: boolean
    Notes?: boolean
    MainContact?: boolean
    Deleted?: boolean
    States?: boolean | StatesArgs
    CustomerDeliveryLocations?: boolean | CustomerDeliveryLocationsFindManyArgs
    CustomerLoadTypes?: boolean | CustomerLoadTypesFindManyArgs
    DeliveryLocations?: boolean | DeliveryLocationsFindManyArgs
    Invoices?: boolean | InvoicesFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | CustomersCountOutputTypeArgs
  }

  export type CustomersInclude = {
    States?: boolean | StatesArgs
    CustomerDeliveryLocations?: boolean | CustomerDeliveryLocationsFindManyArgs
    CustomerLoadTypes?: boolean | CustomerLoadTypesFindManyArgs
    DeliveryLocations?: boolean | DeliveryLocationsFindManyArgs
    Invoices?: boolean | InvoicesFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | CustomersCountOutputTypeArgs
  }

  export type CustomersGetPayload<
    S extends boolean | null | undefined | CustomersArgs,
    U = keyof S
      > = S extends true
        ? Customers
    : S extends undefined
    ? never
    : S extends CustomersArgs | CustomersFindManyArgs
    ?'include' extends U
    ? Customers  & {
    [P in TrueKeys<S['include']>]:
        P extends 'States' ? StatesGetPayload<S['include'][P]> :
        P extends 'CustomerDeliveryLocations' ? Array < CustomerDeliveryLocationsGetPayload<S['include'][P]>>  :
        P extends 'CustomerLoadTypes' ? Array < CustomerLoadTypesGetPayload<S['include'][P]>>  :
        P extends 'DeliveryLocations' ? Array < DeliveryLocationsGetPayload<S['include'][P]>>  :
        P extends 'Invoices' ? Array < InvoicesGetPayload<S['include'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['include'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['include'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'States' ? StatesGetPayload<S['select'][P]> :
        P extends 'CustomerDeliveryLocations' ? Array < CustomerDeliveryLocationsGetPayload<S['select'][P]>>  :
        P extends 'CustomerLoadTypes' ? Array < CustomerLoadTypesGetPayload<S['select'][P]>>  :
        P extends 'DeliveryLocations' ? Array < DeliveryLocationsGetPayload<S['select'][P]>>  :
        P extends 'Invoices' ? Array < InvoicesGetPayload<S['select'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['select'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['select'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Customers ? Customers[P] : never
  } 
    : Customers
  : Customers


  type CustomersCountArgs = Merge<
    Omit<CustomersFindManyArgs, 'select' | 'include'> & {
      select?: CustomersCountAggregateInputType | true
    }
  >

  export interface CustomersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customers'> extends True ? CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>> : CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customers'> extends True ? CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>> : CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const customersWithIDOnly = await prisma.customers.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends CustomersFindManyArgs>(
      args?: SelectSubset<T, CustomersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Customers>>, PrismaPromise<Array<CustomersGetPayload<T>>>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
    **/
    create<T extends CustomersCreateArgs>(
      args: SelectSubset<T, CustomersCreateArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Create many Customers.
     *     @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customers = await prisma.customers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomersCreateManyArgs>(
      args?: SelectSubset<T, CustomersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
    **/
    delete<T extends CustomersDeleteArgs>(
      args: SelectSubset<T, CustomersDeleteArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomersUpdateArgs>(
      args: SelectSubset<T, CustomersUpdateArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomersDeleteManyArgs>(
      args?: SelectSubset<T, CustomersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomersUpdateManyArgs>(
      args: SelectSubset<T, CustomersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
    **/
    upsert<T extends CustomersUpsertArgs>(
      args: SelectSubset<T, CustomersUpsertArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Find one Customers that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Find the first Customers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    States<T extends StatesArgs = {}>(args?: Subset<T, StatesArgs>): CheckSelect<T, Prisma__StatesClient<States | null >, Prisma__StatesClient<StatesGetPayload<T> | null >>;

    CustomerDeliveryLocations<T extends CustomerDeliveryLocationsFindManyArgs = {}>(args?: Subset<T, CustomerDeliveryLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerDeliveryLocations>>, PrismaPromise<Array<CustomerDeliveryLocationsGetPayload<T>>>>;

    CustomerLoadTypes<T extends CustomerLoadTypesFindManyArgs = {}>(args?: Subset<T, CustomerLoadTypesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerLoadTypes>>, PrismaPromise<Array<CustomerLoadTypesGetPayload<T>>>>;

    DeliveryLocations<T extends DeliveryLocationsFindManyArgs = {}>(args?: Subset<T, DeliveryLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeliveryLocations>>, PrismaPromise<Array<DeliveryLocationsGetPayload<T>>>>;

    Invoices<T extends InvoicesFindManyArgs = {}>(args?: Subset<T, InvoicesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Invoices>>, PrismaPromise<Array<InvoicesGetPayload<T>>>>;

    Jobs<T extends JobsFindManyArgs = {}>(args?: Subset<T, JobsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>;

    Loads<T extends LoadsFindManyArgs = {}>(args?: Subset<T, LoadsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>;

    Weeklies<T extends WeekliesFindManyArgs = {}>(args?: Subset<T, WeekliesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Weeklies>>, PrismaPromise<Array<WeekliesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customers base type for findUnique actions
   */
  export type CustomersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers: findUnique
   */
  export interface CustomersFindUniqueArgs extends CustomersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customers base type for findFirst actions
   */
  export type CustomersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }

  /**
   * Customers: findFirst
   */
  export interface CustomersFindFirstArgs extends CustomersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * Customers create
   */
  export type CustomersCreateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The data needed to create a Customers.
     * 
    **/
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }


  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs = {
    /**
     * The data used to create many Customers.
     * 
    **/
    data: Enumerable<CustomersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customers update
   */
  export type CustomersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The data needed to update a Customers.
     * 
    **/
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     * 
    **/
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs = {
    /**
     * The data used to update Customers.
     * 
    **/
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     * 
    **/
    where?: CustomersWhereInput
  }


  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The filter to search for the Customers to update in case it exists.
     * 
    **/
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     * 
    **/
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }


  /**
   * Customers delete
   */
  export type CustomersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter which Customers to delete.
     * 
    **/
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     * 
    **/
    where?: CustomersWhereInput
  }


  /**
   * Customers: findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs = CustomersFindUniqueArgsBase
      

  /**
   * Customers: findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs = CustomersFindFirstArgsBase
      

  /**
   * Customers without action
   */
  export type CustomersArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
  }



  /**
   * Model DeliveryLocations
   */


  export type AggregateDeliveryLocations = {
    _count: DeliveryLocationsCountAggregateOutputType | null
    _avg: DeliveryLocationsAvgAggregateOutputType | null
    _sum: DeliveryLocationsSumAggregateOutputType | null
    _min: DeliveryLocationsMinAggregateOutputType | null
    _max: DeliveryLocationsMaxAggregateOutputType | null
  }

  export type DeliveryLocationsAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
  }

  export type DeliveryLocationsSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
  }

  export type DeliveryLocationsMinAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    CustomerID: number | null
  }

  export type DeliveryLocationsMaxAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    CustomerID: number | null
  }

  export type DeliveryLocationsCountAggregateOutputType = {
    ID: number
    Description: number
    Deleted: number
    CustomerID: number
    _all: number
  }


  export type DeliveryLocationsAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
  }

  export type DeliveryLocationsSumAggregateInputType = {
    ID?: true
    CustomerID?: true
  }

  export type DeliveryLocationsMinAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    CustomerID?: true
  }

  export type DeliveryLocationsMaxAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    CustomerID?: true
  }

  export type DeliveryLocationsCountAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    CustomerID?: true
    _all?: true
  }

  export type DeliveryLocationsAggregateArgs = {
    /**
     * Filter which DeliveryLocations to aggregate.
     * 
    **/
    where?: DeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryLocations
    **/
    _count?: true | DeliveryLocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryLocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryLocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryLocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryLocationsMaxAggregateInputType
  }

  export type GetDeliveryLocationsAggregateType<T extends DeliveryLocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryLocations[P]>
      : GetScalarType<T[P], AggregateDeliveryLocations[P]>
  }




  export type DeliveryLocationsGroupByArgs = {
    where?: DeliveryLocationsWhereInput
    orderBy?: Enumerable<DeliveryLocationsOrderByWithAggregationInput>
    by: Array<DeliveryLocationsScalarFieldEnum>
    having?: DeliveryLocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryLocationsCountAggregateInputType | true
    _avg?: DeliveryLocationsAvgAggregateInputType
    _sum?: DeliveryLocationsSumAggregateInputType
    _min?: DeliveryLocationsMinAggregateInputType
    _max?: DeliveryLocationsMaxAggregateInputType
  }


  export type DeliveryLocationsGroupByOutputType = {
    ID: number
    Description: string
    Deleted: boolean | null
    CustomerID: number | null
    _count: DeliveryLocationsCountAggregateOutputType | null
    _avg: DeliveryLocationsAvgAggregateOutputType | null
    _sum: DeliveryLocationsSumAggregateOutputType | null
    _min: DeliveryLocationsMinAggregateOutputType | null
    _max: DeliveryLocationsMaxAggregateOutputType | null
  }

  type GetDeliveryLocationsGroupByPayload<T extends DeliveryLocationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeliveryLocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryLocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryLocationsGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryLocationsGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryLocationsSelect = {
    ID?: boolean
    Description?: boolean
    Deleted?: boolean
    CustomerID?: boolean
    Customers?: boolean | CustomersArgs
    CustomerDeliveryLocations?: boolean | CustomerDeliveryLocationsFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | DeliveryLocationsCountOutputTypeArgs
  }

  export type DeliveryLocationsInclude = {
    Customers?: boolean | CustomersArgs
    CustomerDeliveryLocations?: boolean | CustomerDeliveryLocationsFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | DeliveryLocationsCountOutputTypeArgs
  }

  export type DeliveryLocationsGetPayload<
    S extends boolean | null | undefined | DeliveryLocationsArgs,
    U = keyof S
      > = S extends true
        ? DeliveryLocations
    : S extends undefined
    ? never
    : S extends DeliveryLocationsArgs | DeliveryLocationsFindManyArgs
    ?'include' extends U
    ? DeliveryLocations  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? CustomersGetPayload<S['include'][P]> | null :
        P extends 'CustomerDeliveryLocations' ? Array < CustomerDeliveryLocationsGetPayload<S['include'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['include'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['include'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['include'][P]>>  :
        P extends '_count' ? DeliveryLocationsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? CustomersGetPayload<S['select'][P]> | null :
        P extends 'CustomerDeliveryLocations' ? Array < CustomerDeliveryLocationsGetPayload<S['select'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['select'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['select'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['select'][P]>>  :
        P extends '_count' ? DeliveryLocationsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DeliveryLocations ? DeliveryLocations[P] : never
  } 
    : DeliveryLocations
  : DeliveryLocations


  type DeliveryLocationsCountArgs = Merge<
    Omit<DeliveryLocationsFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryLocationsCountAggregateInputType | true
    }
  >

  export interface DeliveryLocationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DeliveryLocations that matches the filter.
     * @param {DeliveryLocationsFindUniqueArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryLocationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeliveryLocationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeliveryLocations'> extends True ? CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>> : CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations | null >, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T> | null >>

    /**
     * Find the first DeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsFindFirstArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryLocationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeliveryLocationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeliveryLocations'> extends True ? CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>> : CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations | null >, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T> | null >>

    /**
     * Find zero or more DeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findMany()
     * 
     * // Get first 10 DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const deliveryLocationsWithIDOnly = await prisma.deliveryLocations.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends DeliveryLocationsFindManyArgs>(
      args?: SelectSubset<T, DeliveryLocationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DeliveryLocations>>, PrismaPromise<Array<DeliveryLocationsGetPayload<T>>>>

    /**
     * Create a DeliveryLocations.
     * @param {DeliveryLocationsCreateArgs} args - Arguments to create a DeliveryLocations.
     * @example
     * // Create one DeliveryLocations
     * const DeliveryLocations = await prisma.deliveryLocations.create({
     *   data: {
     *     // ... data to create a DeliveryLocations
     *   }
     * })
     * 
    **/
    create<T extends DeliveryLocationsCreateArgs>(
      args: SelectSubset<T, DeliveryLocationsCreateArgs>
    ): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>>

    /**
     * Create many DeliveryLocations.
     *     @param {DeliveryLocationsCreateManyArgs} args - Arguments to create many DeliveryLocations.
     *     @example
     *     // Create many DeliveryLocations
     *     const deliveryLocations = await prisma.deliveryLocations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryLocationsCreateManyArgs>(
      args?: SelectSubset<T, DeliveryLocationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeliveryLocations.
     * @param {DeliveryLocationsDeleteArgs} args - Arguments to delete one DeliveryLocations.
     * @example
     * // Delete one DeliveryLocations
     * const DeliveryLocations = await prisma.deliveryLocations.delete({
     *   where: {
     *     // ... filter to delete one DeliveryLocations
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryLocationsDeleteArgs>(
      args: SelectSubset<T, DeliveryLocationsDeleteArgs>
    ): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>>

    /**
     * Update one DeliveryLocations.
     * @param {DeliveryLocationsUpdateArgs} args - Arguments to update one DeliveryLocations.
     * @example
     * // Update one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryLocationsUpdateArgs>(
      args: SelectSubset<T, DeliveryLocationsUpdateArgs>
    ): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>>

    /**
     * Delete zero or more DeliveryLocations.
     * @param {DeliveryLocationsDeleteManyArgs} args - Arguments to filter DeliveryLocations to delete.
     * @example
     * // Delete a few DeliveryLocations
     * const { count } = await prisma.deliveryLocations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryLocationsDeleteManyArgs>(
      args?: SelectSubset<T, DeliveryLocationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryLocationsUpdateManyArgs>(
      args: SelectSubset<T, DeliveryLocationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryLocations.
     * @param {DeliveryLocationsUpsertArgs} args - Arguments to update or create a DeliveryLocations.
     * @example
     * // Update or create a DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.upsert({
     *   create: {
     *     // ... data to create a DeliveryLocations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryLocations we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryLocationsUpsertArgs>(
      args: SelectSubset<T, DeliveryLocationsUpsertArgs>
    ): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>>

    /**
     * Find one DeliveryLocations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeliveryLocationsFindUniqueOrThrowArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryLocationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeliveryLocationsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>>

    /**
     * Find the first DeliveryLocations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsFindFirstOrThrowArgs} args - Arguments to find a DeliveryLocations
     * @example
     * // Get one DeliveryLocations
     * const deliveryLocations = await prisma.deliveryLocations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryLocationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeliveryLocationsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations>, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T>>>

    /**
     * Count the number of DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsCountArgs} args - Arguments to filter DeliveryLocations to count.
     * @example
     * // Count the number of DeliveryLocations
     * const count = await prisma.deliveryLocations.count({
     *   where: {
     *     // ... the filter for the DeliveryLocations we want to count
     *   }
     * })
    **/
    count<T extends DeliveryLocationsCountArgs>(
      args?: Subset<T, DeliveryLocationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryLocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryLocationsAggregateArgs>(args: Subset<T, DeliveryLocationsAggregateArgs>): PrismaPromise<GetDeliveryLocationsAggregateType<T>>

    /**
     * Group by DeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryLocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryLocationsGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryLocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryLocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryLocationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryLocations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeliveryLocationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    CustomerDeliveryLocations<T extends CustomerDeliveryLocationsFindManyArgs = {}>(args?: Subset<T, CustomerDeliveryLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerDeliveryLocations>>, PrismaPromise<Array<CustomerDeliveryLocationsGetPayload<T>>>>;

    Jobs<T extends JobsFindManyArgs = {}>(args?: Subset<T, JobsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>;

    Loads<T extends LoadsFindManyArgs = {}>(args?: Subset<T, LoadsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>;

    Weeklies<T extends WeekliesFindManyArgs = {}>(args?: Subset<T, WeekliesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Weeklies>>, PrismaPromise<Array<WeekliesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeliveryLocations base type for findUnique actions
   */
  export type DeliveryLocationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
    /**
     * Filter, which DeliveryLocations to fetch.
     * 
    **/
    where: DeliveryLocationsWhereUniqueInput
  }

  /**
   * DeliveryLocations: findUnique
   */
  export interface DeliveryLocationsFindUniqueArgs extends DeliveryLocationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeliveryLocations base type for findFirst actions
   */
  export type DeliveryLocationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
    /**
     * Filter, which DeliveryLocations to fetch.
     * 
    **/
    where?: DeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLocations.
     * 
    **/
    cursor?: DeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLocations.
     * 
    **/
    distinct?: Enumerable<DeliveryLocationsScalarFieldEnum>
  }

  /**
   * DeliveryLocations: findFirst
   */
  export interface DeliveryLocationsFindFirstArgs extends DeliveryLocationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeliveryLocations findMany
   */
  export type DeliveryLocationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
    /**
     * Filter, which DeliveryLocations to fetch.
     * 
    **/
    where?: DeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryLocations.
     * 
    **/
    cursor?: DeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLocations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeliveryLocationsScalarFieldEnum>
  }


  /**
   * DeliveryLocations create
   */
  export type DeliveryLocationsCreateArgs = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
    /**
     * The data needed to create a DeliveryLocations.
     * 
    **/
    data: XOR<DeliveryLocationsCreateInput, DeliveryLocationsUncheckedCreateInput>
  }


  /**
   * DeliveryLocations createMany
   */
  export type DeliveryLocationsCreateManyArgs = {
    /**
     * The data used to create many DeliveryLocations.
     * 
    **/
    data: Enumerable<DeliveryLocationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeliveryLocations update
   */
  export type DeliveryLocationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
    /**
     * The data needed to update a DeliveryLocations.
     * 
    **/
    data: XOR<DeliveryLocationsUpdateInput, DeliveryLocationsUncheckedUpdateInput>
    /**
     * Choose, which DeliveryLocations to update.
     * 
    **/
    where: DeliveryLocationsWhereUniqueInput
  }


  /**
   * DeliveryLocations updateMany
   */
  export type DeliveryLocationsUpdateManyArgs = {
    /**
     * The data used to update DeliveryLocations.
     * 
    **/
    data: XOR<DeliveryLocationsUpdateManyMutationInput, DeliveryLocationsUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLocations to update
     * 
    **/
    where?: DeliveryLocationsWhereInput
  }


  /**
   * DeliveryLocations upsert
   */
  export type DeliveryLocationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
    /**
     * The filter to search for the DeliveryLocations to update in case it exists.
     * 
    **/
    where: DeliveryLocationsWhereUniqueInput
    /**
     * In case the DeliveryLocations found by the `where` argument doesn't exist, create a new DeliveryLocations with this data.
     * 
    **/
    create: XOR<DeliveryLocationsCreateInput, DeliveryLocationsUncheckedCreateInput>
    /**
     * In case the DeliveryLocations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeliveryLocationsUpdateInput, DeliveryLocationsUncheckedUpdateInput>
  }


  /**
   * DeliveryLocations delete
   */
  export type DeliveryLocationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
    /**
     * Filter which DeliveryLocations to delete.
     * 
    **/
    where: DeliveryLocationsWhereUniqueInput
  }


  /**
   * DeliveryLocations deleteMany
   */
  export type DeliveryLocationsDeleteManyArgs = {
    /**
     * Filter which DeliveryLocations to delete
     * 
    **/
    where?: DeliveryLocationsWhereInput
  }


  /**
   * DeliveryLocations: findUniqueOrThrow
   */
  export type DeliveryLocationsFindUniqueOrThrowArgs = DeliveryLocationsFindUniqueArgsBase
      

  /**
   * DeliveryLocations: findFirstOrThrow
   */
  export type DeliveryLocationsFindFirstOrThrowArgs = DeliveryLocationsFindFirstArgsBase
      

  /**
   * DeliveryLocations without action
   */
  export type DeliveryLocationsArgs = {
    /**
     * Select specific fields to fetch from the DeliveryLocations
     * 
    **/
    select?: DeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryLocationsInclude | null
  }



  /**
   * Model Drivers
   */


  export type AggregateDrivers = {
    _count: DriversCountAggregateOutputType | null
    _avg: DriversAvgAggregateOutputType | null
    _sum: DriversSumAggregateOutputType | null
    _min: DriversMinAggregateOutputType | null
    _max: DriversMaxAggregateOutputType | null
  }

  export type DriversAvgAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type DriversSumAggregateOutputType = {
    ID: number | null
    State: number | null
  }

  export type DriversMinAggregateOutputType = {
    ID: number | null
    FirstName: string | null
    MiddleName: string | null
    LastName: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    DOB: Date | null
    License: string | null
    Email: string | null
    Phone: string | null
    Notes: string | null
    Deleted: boolean | null
    HireDate: string | null
    OwnerOperator: boolean | null
  }

  export type DriversMaxAggregateOutputType = {
    ID: number | null
    FirstName: string | null
    MiddleName: string | null
    LastName: string | null
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    DOB: Date | null
    License: string | null
    Email: string | null
    Phone: string | null
    Notes: string | null
    Deleted: boolean | null
    HireDate: string | null
    OwnerOperator: boolean | null
  }

  export type DriversCountAggregateOutputType = {
    ID: number
    FirstName: number
    MiddleName: number
    LastName: number
    Street: number
    City: number
    State: number
    ZIP: number
    DOB: number
    License: number
    Email: number
    Phone: number
    Notes: number
    Deleted: number
    HireDate: number
    OwnerOperator: number
    _all: number
  }


  export type DriversAvgAggregateInputType = {
    ID?: true
    State?: true
  }

  export type DriversSumAggregateInputType = {
    ID?: true
    State?: true
  }

  export type DriversMinAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    DOB?: true
    License?: true
    Email?: true
    Phone?: true
    Notes?: true
    Deleted?: true
    HireDate?: true
    OwnerOperator?: true
  }

  export type DriversMaxAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    DOB?: true
    License?: true
    Email?: true
    Phone?: true
    Notes?: true
    Deleted?: true
    HireDate?: true
    OwnerOperator?: true
  }

  export type DriversCountAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    City?: true
    State?: true
    ZIP?: true
    DOB?: true
    License?: true
    Email?: true
    Phone?: true
    Notes?: true
    Deleted?: true
    HireDate?: true
    OwnerOperator?: true
    _all?: true
  }

  export type DriversAggregateArgs = {
    /**
     * Filter which Drivers to aggregate.
     * 
    **/
    where?: DriversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     * 
    **/
    orderBy?: Enumerable<DriversOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DriversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriversMaxAggregateInputType
  }

  export type GetDriversAggregateType<T extends DriversAggregateArgs> = {
        [P in keyof T & keyof AggregateDrivers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrivers[P]>
      : GetScalarType<T[P], AggregateDrivers[P]>
  }




  export type DriversGroupByArgs = {
    where?: DriversWhereInput
    orderBy?: Enumerable<DriversOrderByWithAggregationInput>
    by: Array<DriversScalarFieldEnum>
    having?: DriversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriversCountAggregateInputType | true
    _avg?: DriversAvgAggregateInputType
    _sum?: DriversSumAggregateInputType
    _min?: DriversMinAggregateInputType
    _max?: DriversMaxAggregateInputType
  }


  export type DriversGroupByOutputType = {
    ID: number
    FirstName: string
    MiddleName: string | null
    LastName: string
    Street: string | null
    City: string | null
    State: number | null
    ZIP: string | null
    DOB: Date | null
    License: string | null
    Email: string | null
    Phone: string | null
    Notes: string | null
    Deleted: boolean | null
    HireDate: string | null
    OwnerOperator: boolean
    _count: DriversCountAggregateOutputType | null
    _avg: DriversAvgAggregateOutputType | null
    _sum: DriversSumAggregateOutputType | null
    _min: DriversMinAggregateOutputType | null
    _max: DriversMaxAggregateOutputType | null
  }

  type GetDriversGroupByPayload<T extends DriversGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DriversGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriversGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriversGroupByOutputType[P]>
            : GetScalarType<T[P], DriversGroupByOutputType[P]>
        }
      >
    >


  export type DriversSelect = {
    ID?: boolean
    FirstName?: boolean
    MiddleName?: boolean
    LastName?: boolean
    Street?: boolean
    City?: boolean
    State?: boolean
    ZIP?: boolean
    DOB?: boolean
    License?: boolean
    Email?: boolean
    Phone?: boolean
    Notes?: boolean
    Deleted?: boolean
    HireDate?: boolean
    OwnerOperator?: boolean
    States?: boolean | StatesArgs
    Dailies?: boolean | DailiesFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    PayStubs?: boolean | PayStubsFindManyArgs
    TrucksDriven?: boolean | TrucksDrivenFindManyArgs
    _count?: boolean | DriversCountOutputTypeArgs
  }

  export type DriversInclude = {
    States?: boolean | StatesArgs
    Dailies?: boolean | DailiesFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    PayStubs?: boolean | PayStubsFindManyArgs
    TrucksDriven?: boolean | TrucksDrivenFindManyArgs
    _count?: boolean | DriversCountOutputTypeArgs
  }

  export type DriversGetPayload<
    S extends boolean | null | undefined | DriversArgs,
    U = keyof S
      > = S extends true
        ? Drivers
    : S extends undefined
    ? never
    : S extends DriversArgs | DriversFindManyArgs
    ?'include' extends U
    ? Drivers  & {
    [P in TrueKeys<S['include']>]:
        P extends 'States' ? StatesGetPayload<S['include'][P]> | null :
        P extends 'Dailies' ? Array < DailiesGetPayload<S['include'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['include'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['include'][P]>>  :
        P extends 'PayStubs' ? Array < PayStubsGetPayload<S['include'][P]>>  :
        P extends 'TrucksDriven' ? Array < TrucksDrivenGetPayload<S['include'][P]>>  :
        P extends '_count' ? DriversCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'States' ? StatesGetPayload<S['select'][P]> | null :
        P extends 'Dailies' ? Array < DailiesGetPayload<S['select'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['select'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['select'][P]>>  :
        P extends 'PayStubs' ? Array < PayStubsGetPayload<S['select'][P]>>  :
        P extends 'TrucksDriven' ? Array < TrucksDrivenGetPayload<S['select'][P]>>  :
        P extends '_count' ? DriversCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Drivers ? Drivers[P] : never
  } 
    : Drivers
  : Drivers


  type DriversCountArgs = Merge<
    Omit<DriversFindManyArgs, 'select' | 'include'> & {
      select?: DriversCountAggregateInputType | true
    }
  >

  export interface DriversDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Drivers that matches the filter.
     * @param {DriversFindUniqueArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DriversFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DriversFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Drivers'> extends True ? CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>> : CheckSelect<T, Prisma__DriversClient<Drivers | null >, Prisma__DriversClient<DriversGetPayload<T> | null >>

    /**
     * Find the first Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversFindFirstArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DriversFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DriversFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Drivers'> extends True ? CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>> : CheckSelect<T, Prisma__DriversClient<Drivers | null >, Prisma__DriversClient<DriversGetPayload<T> | null >>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.drivers.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.drivers.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const driversWithIDOnly = await prisma.drivers.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends DriversFindManyArgs>(
      args?: SelectSubset<T, DriversFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Drivers>>, PrismaPromise<Array<DriversGetPayload<T>>>>

    /**
     * Create a Drivers.
     * @param {DriversCreateArgs} args - Arguments to create a Drivers.
     * @example
     * // Create one Drivers
     * const Drivers = await prisma.drivers.create({
     *   data: {
     *     // ... data to create a Drivers
     *   }
     * })
     * 
    **/
    create<T extends DriversCreateArgs>(
      args: SelectSubset<T, DriversCreateArgs>
    ): CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>>

    /**
     * Create many Drivers.
     *     @param {DriversCreateManyArgs} args - Arguments to create many Drivers.
     *     @example
     *     // Create many Drivers
     *     const drivers = await prisma.drivers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DriversCreateManyArgs>(
      args?: SelectSubset<T, DriversCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Drivers.
     * @param {DriversDeleteArgs} args - Arguments to delete one Drivers.
     * @example
     * // Delete one Drivers
     * const Drivers = await prisma.drivers.delete({
     *   where: {
     *     // ... filter to delete one Drivers
     *   }
     * })
     * 
    **/
    delete<T extends DriversDeleteArgs>(
      args: SelectSubset<T, DriversDeleteArgs>
    ): CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>>

    /**
     * Update one Drivers.
     * @param {DriversUpdateArgs} args - Arguments to update one Drivers.
     * @example
     * // Update one Drivers
     * const drivers = await prisma.drivers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DriversUpdateArgs>(
      args: SelectSubset<T, DriversUpdateArgs>
    ): CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>>

    /**
     * Delete zero or more Drivers.
     * @param {DriversDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.drivers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DriversDeleteManyArgs>(
      args?: SelectSubset<T, DriversDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const drivers = await prisma.drivers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DriversUpdateManyArgs>(
      args: SelectSubset<T, DriversUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Drivers.
     * @param {DriversUpsertArgs} args - Arguments to update or create a Drivers.
     * @example
     * // Update or create a Drivers
     * const drivers = await prisma.drivers.upsert({
     *   create: {
     *     // ... data to create a Drivers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drivers we want to update
     *   }
     * })
    **/
    upsert<T extends DriversUpsertArgs>(
      args: SelectSubset<T, DriversUpsertArgs>
    ): CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>>

    /**
     * Find one Drivers that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DriversFindUniqueOrThrowArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DriversFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DriversFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>>

    /**
     * Find the first Drivers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversFindFirstOrThrowArgs} args - Arguments to find a Drivers
     * @example
     * // Get one Drivers
     * const drivers = await prisma.drivers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DriversFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DriversFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DriversClient<Drivers>, Prisma__DriversClient<DriversGetPayload<T>>>

    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.drivers.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriversCountArgs>(
      args?: Subset<T, DriversCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriversAggregateArgs>(args: Subset<T, DriversAggregateArgs>): PrismaPromise<GetDriversAggregateType<T>>

    /**
     * Group by Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriversGroupByArgs['orderBy'] }
        : { orderBy?: DriversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriversGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Drivers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DriversClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    States<T extends StatesArgs = {}>(args?: Subset<T, StatesArgs>): CheckSelect<T, Prisma__StatesClient<States | null >, Prisma__StatesClient<StatesGetPayload<T> | null >>;

    Dailies<T extends DailiesFindManyArgs = {}>(args?: Subset<T, DailiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Dailies>>, PrismaPromise<Array<DailiesGetPayload<T>>>>;

    Jobs<T extends JobsFindManyArgs = {}>(args?: Subset<T, JobsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>;

    Loads<T extends LoadsFindManyArgs = {}>(args?: Subset<T, LoadsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>;

    PayStubs<T extends PayStubsFindManyArgs = {}>(args?: Subset<T, PayStubsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PayStubs>>, PrismaPromise<Array<PayStubsGetPayload<T>>>>;

    TrucksDriven<T extends TrucksDrivenFindManyArgs = {}>(args?: Subset<T, TrucksDrivenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TrucksDriven>>, PrismaPromise<Array<TrucksDrivenGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Drivers base type for findUnique actions
   */
  export type DriversFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
    /**
     * Filter, which Drivers to fetch.
     * 
    **/
    where: DriversWhereUniqueInput
  }

  /**
   * Drivers: findUnique
   */
  export interface DriversFindUniqueArgs extends DriversFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Drivers base type for findFirst actions
   */
  export type DriversFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
    /**
     * Filter, which Drivers to fetch.
     * 
    **/
    where?: DriversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     * 
    **/
    orderBy?: Enumerable<DriversOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     * 
    **/
    cursor?: DriversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     * 
    **/
    distinct?: Enumerable<DriversScalarFieldEnum>
  }

  /**
   * Drivers: findFirst
   */
  export interface DriversFindFirstArgs extends DriversFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Drivers findMany
   */
  export type DriversFindManyArgs = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
    /**
     * Filter, which Drivers to fetch.
     * 
    **/
    where?: DriversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     * 
    **/
    orderBy?: Enumerable<DriversOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     * 
    **/
    cursor?: DriversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DriversScalarFieldEnum>
  }


  /**
   * Drivers create
   */
  export type DriversCreateArgs = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
    /**
     * The data needed to create a Drivers.
     * 
    **/
    data: XOR<DriversCreateInput, DriversUncheckedCreateInput>
  }


  /**
   * Drivers createMany
   */
  export type DriversCreateManyArgs = {
    /**
     * The data used to create many Drivers.
     * 
    **/
    data: Enumerable<DriversCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Drivers update
   */
  export type DriversUpdateArgs = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
    /**
     * The data needed to update a Drivers.
     * 
    **/
    data: XOR<DriversUpdateInput, DriversUncheckedUpdateInput>
    /**
     * Choose, which Drivers to update.
     * 
    **/
    where: DriversWhereUniqueInput
  }


  /**
   * Drivers updateMany
   */
  export type DriversUpdateManyArgs = {
    /**
     * The data used to update Drivers.
     * 
    **/
    data: XOR<DriversUpdateManyMutationInput, DriversUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     * 
    **/
    where?: DriversWhereInput
  }


  /**
   * Drivers upsert
   */
  export type DriversUpsertArgs = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
    /**
     * The filter to search for the Drivers to update in case it exists.
     * 
    **/
    where: DriversWhereUniqueInput
    /**
     * In case the Drivers found by the `where` argument doesn't exist, create a new Drivers with this data.
     * 
    **/
    create: XOR<DriversCreateInput, DriversUncheckedCreateInput>
    /**
     * In case the Drivers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DriversUpdateInput, DriversUncheckedUpdateInput>
  }


  /**
   * Drivers delete
   */
  export type DriversDeleteArgs = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
    /**
     * Filter which Drivers to delete.
     * 
    **/
    where: DriversWhereUniqueInput
  }


  /**
   * Drivers deleteMany
   */
  export type DriversDeleteManyArgs = {
    /**
     * Filter which Drivers to delete
     * 
    **/
    where?: DriversWhereInput
  }


  /**
   * Drivers: findUniqueOrThrow
   */
  export type DriversFindUniqueOrThrowArgs = DriversFindUniqueArgsBase
      

  /**
   * Drivers: findFirstOrThrow
   */
  export type DriversFindFirstOrThrowArgs = DriversFindFirstArgsBase
      

  /**
   * Drivers without action
   */
  export type DriversArgs = {
    /**
     * Select specific fields to fetch from the Drivers
     * 
    **/
    select?: DriversSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DriversInclude | null
  }



  /**
   * Model Invoices
   */


  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  export type InvoicesAvgAggregateOutputType = {
    ID: number | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    ConsolidatedID: number | null
  }

  export type InvoicesSumAggregateOutputType = {
    ID: number | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    ConsolidatedID: number | null
  }

  export type InvoicesMinAggregateOutputType = {
    ID: number | null
    InvoiceDate: Date | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    PaidDate: Date | null
    CheckNumber: string | null
    Paid: boolean | null
    Printed: boolean | null
    Deleted: boolean | null
    PaymentType: string | null
    Consolidated: boolean | null
    ConsolidatedID: number | null
  }

  export type InvoicesMaxAggregateOutputType = {
    ID: number | null
    InvoiceDate: Date | null
    Number: number | null
    CustomerID: number | null
    TotalAmount: number | null
    PaidDate: Date | null
    CheckNumber: string | null
    Paid: boolean | null
    Printed: boolean | null
    Deleted: boolean | null
    PaymentType: string | null
    Consolidated: boolean | null
    ConsolidatedID: number | null
  }

  export type InvoicesCountAggregateOutputType = {
    ID: number
    InvoiceDate: number
    Number: number
    CustomerID: number
    TotalAmount: number
    PaidDate: number
    CheckNumber: number
    Paid: number
    Printed: number
    Deleted: number
    PaymentType: number
    Consolidated: number
    ConsolidatedID: number
    _all: number
  }


  export type InvoicesAvgAggregateInputType = {
    ID?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    ConsolidatedID?: true
  }

  export type InvoicesSumAggregateInputType = {
    ID?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    ConsolidatedID?: true
  }

  export type InvoicesMinAggregateInputType = {
    ID?: true
    InvoiceDate?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    PaidDate?: true
    CheckNumber?: true
    Paid?: true
    Printed?: true
    Deleted?: true
    PaymentType?: true
    Consolidated?: true
    ConsolidatedID?: true
  }

  export type InvoicesMaxAggregateInputType = {
    ID?: true
    InvoiceDate?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    PaidDate?: true
    CheckNumber?: true
    Paid?: true
    Printed?: true
    Deleted?: true
    PaymentType?: true
    Consolidated?: true
    ConsolidatedID?: true
  }

  export type InvoicesCountAggregateInputType = {
    ID?: true
    InvoiceDate?: true
    Number?: true
    CustomerID?: true
    TotalAmount?: true
    PaidDate?: true
    CheckNumber?: true
    Paid?: true
    Printed?: true
    Deleted?: true
    PaymentType?: true
    Consolidated?: true
    ConsolidatedID?: true
    _all?: true
  }

  export type InvoicesAggregateArgs = {
    /**
     * Filter which Invoices to aggregate.
     * 
    **/
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoicesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicesMaxAggregateInputType
  }

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>
  }




  export type InvoicesGroupByArgs = {
    where?: InvoicesWhereInput
    orderBy?: Enumerable<InvoicesOrderByWithAggregationInput>
    by: Array<InvoicesScalarFieldEnum>
    having?: InvoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicesCountAggregateInputType | true
    _avg?: InvoicesAvgAggregateInputType
    _sum?: InvoicesSumAggregateInputType
    _min?: InvoicesMinAggregateInputType
    _max?: InvoicesMaxAggregateInputType
  }


  export type InvoicesGroupByOutputType = {
    ID: number
    InvoiceDate: Date
    Number: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate: Date | null
    CheckNumber: string | null
    Paid: boolean | null
    Printed: boolean | null
    Deleted: boolean | null
    PaymentType: string | null
    Consolidated: boolean | null
    ConsolidatedID: number | null
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  type GetInvoicesGroupByPayload<T extends InvoicesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
        }
      >
    >


  export type InvoicesSelect = {
    ID?: boolean
    InvoiceDate?: boolean
    Number?: boolean
    CustomerID?: boolean
    TotalAmount?: boolean
    PaidDate?: boolean
    CheckNumber?: boolean
    Paid?: boolean
    Printed?: boolean
    Deleted?: boolean
    PaymentType?: boolean
    Consolidated?: boolean
    ConsolidatedID?: boolean
    Customers?: boolean | CustomersArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | InvoicesCountOutputTypeArgs
  }

  export type InvoicesInclude = {
    Customers?: boolean | CustomersArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | InvoicesCountOutputTypeArgs
  }

  export type InvoicesGetPayload<
    S extends boolean | null | undefined | InvoicesArgs,
    U = keyof S
      > = S extends true
        ? Invoices
    : S extends undefined
    ? never
    : S extends InvoicesArgs | InvoicesFindManyArgs
    ?'include' extends U
    ? Invoices  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? CustomersGetPayload<S['include'][P]> :
        P extends 'Loads' ? Array < LoadsGetPayload<S['include'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['include'][P]>>  :
        P extends '_count' ? InvoicesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? CustomersGetPayload<S['select'][P]> :
        P extends 'Loads' ? Array < LoadsGetPayload<S['select'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['select'][P]>>  :
        P extends '_count' ? InvoicesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Invoices ? Invoices[P] : never
  } 
    : Invoices
  : Invoices


  type InvoicesCountArgs = Merge<
    Omit<InvoicesFindManyArgs, 'select' | 'include'> & {
      select?: InvoicesCountAggregateInputType | true
    }
  >

  export interface InvoicesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {InvoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invoices'> extends True ? CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>> : CheckSelect<T, Prisma__InvoicesClient<Invoices | null >, Prisma__InvoicesClient<InvoicesGetPayload<T> | null >>

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invoices'> extends True ? CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>> : CheckSelect<T, Prisma__InvoicesClient<Invoices | null >, Prisma__InvoicesClient<InvoicesGetPayload<T> | null >>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const invoicesWithIDOnly = await prisma.invoices.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends InvoicesFindManyArgs>(
      args?: SelectSubset<T, InvoicesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Invoices>>, PrismaPromise<Array<InvoicesGetPayload<T>>>>

    /**
     * Create a Invoices.
     * @param {InvoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     * 
    **/
    create<T extends InvoicesCreateArgs>(
      args: SelectSubset<T, InvoicesCreateArgs>
    ): CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>>

    /**
     * Create many Invoices.
     *     @param {InvoicesCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoices = await prisma.invoices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoicesCreateManyArgs>(
      args?: SelectSubset<T, InvoicesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Invoices.
     * @param {InvoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     * 
    **/
    delete<T extends InvoicesDeleteArgs>(
      args: SelectSubset<T, InvoicesDeleteArgs>
    ): CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>>

    /**
     * Update one Invoices.
     * @param {InvoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoicesUpdateArgs>(
      args: SelectSubset<T, InvoicesUpdateArgs>
    ): CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>>

    /**
     * Delete zero or more Invoices.
     * @param {InvoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoicesDeleteManyArgs>(
      args?: SelectSubset<T, InvoicesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoicesUpdateManyArgs>(
      args: SelectSubset<T, InvoicesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoices.
     * @param {InvoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
    **/
    upsert<T extends InvoicesUpsertArgs>(
      args: SelectSubset<T, InvoicesUpsertArgs>
    ): CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>>

    /**
     * Find one Invoices that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InvoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InvoicesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>>

    /**
     * Find the first Invoices that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InvoicesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InvoicesClient<Invoices>, Prisma__InvoicesClient<InvoicesGetPayload<T>>>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoicesCountArgs>(
      args?: Subset<T, InvoicesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicesAggregateArgs>(args: Subset<T, InvoicesAggregateArgs>): PrismaPromise<GetInvoicesAggregateType<T>>

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicesGroupByArgs['orderBy'] }
        : { orderBy?: InvoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoicesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    Loads<T extends LoadsFindManyArgs = {}>(args?: Subset<T, LoadsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>;

    Weeklies<T extends WeekliesFindManyArgs = {}>(args?: Subset<T, WeekliesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Weeklies>>, PrismaPromise<Array<WeekliesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invoices base type for findUnique actions
   */
  export type InvoicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
    /**
     * Filter, which Invoices to fetch.
     * 
    **/
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices: findUnique
   */
  export interface InvoicesFindUniqueArgs extends InvoicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoices base type for findFirst actions
   */
  export type InvoicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
    /**
     * Filter, which Invoices to fetch.
     * 
    **/
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoicesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     * 
    **/
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     * 
    **/
    distinct?: Enumerable<InvoicesScalarFieldEnum>
  }

  /**
   * Invoices: findFirst
   */
  export interface InvoicesFindFirstArgs extends InvoicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoices findMany
   */
  export type InvoicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
    /**
     * Filter, which Invoices to fetch.
     * 
    **/
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoicesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     * 
    **/
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvoicesScalarFieldEnum>
  }


  /**
   * Invoices create
   */
  export type InvoicesCreateArgs = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
    /**
     * The data needed to create a Invoices.
     * 
    **/
    data: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
  }


  /**
   * Invoices createMany
   */
  export type InvoicesCreateManyArgs = {
    /**
     * The data used to create many Invoices.
     * 
    **/
    data: Enumerable<InvoicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invoices update
   */
  export type InvoicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
    /**
     * The data needed to update a Invoices.
     * 
    **/
    data: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
    /**
     * Choose, which Invoices to update.
     * 
    **/
    where: InvoicesWhereUniqueInput
  }


  /**
   * Invoices updateMany
   */
  export type InvoicesUpdateManyArgs = {
    /**
     * The data used to update Invoices.
     * 
    **/
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     * 
    **/
    where?: InvoicesWhereInput
  }


  /**
   * Invoices upsert
   */
  export type InvoicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
    /**
     * The filter to search for the Invoices to update in case it exists.
     * 
    **/
    where: InvoicesWhereUniqueInput
    /**
     * In case the Invoices found by the `where` argument doesn't exist, create a new Invoices with this data.
     * 
    **/
    create: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
    /**
     * In case the Invoices was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
  }


  /**
   * Invoices delete
   */
  export type InvoicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
    /**
     * Filter which Invoices to delete.
     * 
    **/
    where: InvoicesWhereUniqueInput
  }


  /**
   * Invoices deleteMany
   */
  export type InvoicesDeleteManyArgs = {
    /**
     * Filter which Invoices to delete
     * 
    **/
    where?: InvoicesWhereInput
  }


  /**
   * Invoices: findUniqueOrThrow
   */
  export type InvoicesFindUniqueOrThrowArgs = InvoicesFindUniqueArgsBase
      

  /**
   * Invoices: findFirstOrThrow
   */
  export type InvoicesFindFirstOrThrowArgs = InvoicesFindFirstArgsBase
      

  /**
   * Invoices without action
   */
  export type InvoicesArgs = {
    /**
     * Select specific fields to fetch from the Invoices
     * 
    **/
    select?: InvoicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoicesInclude | null
  }



  /**
   * Model LoadTypes
   */


  export type AggregateLoadTypes = {
    _count: LoadTypesCountAggregateOutputType | null
    _avg: LoadTypesAvgAggregateOutputType | null
    _sum: LoadTypesSumAggregateOutputType | null
    _min: LoadTypesMinAggregateOutputType | null
    _max: LoadTypesMaxAggregateOutputType | null
  }

  export type LoadTypesAvgAggregateOutputType = {
    ID: number | null
    SourceID: number | null
  }

  export type LoadTypesSumAggregateOutputType = {
    ID: number | null
    SourceID: number | null
  }

  export type LoadTypesMinAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    SourceID: number | null
    Notes: string | null
  }

  export type LoadTypesMaxAggregateOutputType = {
    ID: number | null
    Description: string | null
    Deleted: boolean | null
    SourceID: number | null
    Notes: string | null
  }

  export type LoadTypesCountAggregateOutputType = {
    ID: number
    Description: number
    Deleted: number
    SourceID: number
    Notes: number
    _all: number
  }


  export type LoadTypesAvgAggregateInputType = {
    ID?: true
    SourceID?: true
  }

  export type LoadTypesSumAggregateInputType = {
    ID?: true
    SourceID?: true
  }

  export type LoadTypesMinAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    SourceID?: true
    Notes?: true
  }

  export type LoadTypesMaxAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    SourceID?: true
    Notes?: true
  }

  export type LoadTypesCountAggregateInputType = {
    ID?: true
    Description?: true
    Deleted?: true
    SourceID?: true
    Notes?: true
    _all?: true
  }

  export type LoadTypesAggregateArgs = {
    /**
     * Filter which LoadTypes to aggregate.
     * 
    **/
    where?: LoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoadTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LoadTypesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoadTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoadTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoadTypes
    **/
    _count?: true | LoadTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoadTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoadTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoadTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoadTypesMaxAggregateInputType
  }

  export type GetLoadTypesAggregateType<T extends LoadTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateLoadTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoadTypes[P]>
      : GetScalarType<T[P], AggregateLoadTypes[P]>
  }




  export type LoadTypesGroupByArgs = {
    where?: LoadTypesWhereInput
    orderBy?: Enumerable<LoadTypesOrderByWithAggregationInput>
    by: Array<LoadTypesScalarFieldEnum>
    having?: LoadTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoadTypesCountAggregateInputType | true
    _avg?: LoadTypesAvgAggregateInputType
    _sum?: LoadTypesSumAggregateInputType
    _min?: LoadTypesMinAggregateInputType
    _max?: LoadTypesMaxAggregateInputType
  }


  export type LoadTypesGroupByOutputType = {
    ID: number
    Description: string
    Deleted: boolean | null
    SourceID: number | null
    Notes: string | null
    _count: LoadTypesCountAggregateOutputType | null
    _avg: LoadTypesAvgAggregateOutputType | null
    _sum: LoadTypesSumAggregateOutputType | null
    _min: LoadTypesMinAggregateOutputType | null
    _max: LoadTypesMaxAggregateOutputType | null
  }

  type GetLoadTypesGroupByPayload<T extends LoadTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LoadTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoadTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoadTypesGroupByOutputType[P]>
            : GetScalarType<T[P], LoadTypesGroupByOutputType[P]>
        }
      >
    >


  export type LoadTypesSelect = {
    ID?: boolean
    Description?: boolean
    Deleted?: boolean
    SourceID?: boolean
    Notes?: boolean
    CustomerLoadTypes?: boolean | CustomerLoadTypesFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | LoadTypesCountOutputTypeArgs
  }

  export type LoadTypesInclude = {
    CustomerLoadTypes?: boolean | CustomerLoadTypesFindManyArgs
    Jobs?: boolean | JobsFindManyArgs
    Loads?: boolean | LoadsFindManyArgs
    Weeklies?: boolean | WeekliesFindManyArgs
    _count?: boolean | LoadTypesCountOutputTypeArgs
  }

  export type LoadTypesGetPayload<
    S extends boolean | null | undefined | LoadTypesArgs,
    U = keyof S
      > = S extends true
        ? LoadTypes
    : S extends undefined
    ? never
    : S extends LoadTypesArgs | LoadTypesFindManyArgs
    ?'include' extends U
    ? LoadTypes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'CustomerLoadTypes' ? Array < CustomerLoadTypesGetPayload<S['include'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['include'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['include'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['include'][P]>>  :
        P extends '_count' ? LoadTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'CustomerLoadTypes' ? Array < CustomerLoadTypesGetPayload<S['select'][P]>>  :
        P extends 'Jobs' ? Array < JobsGetPayload<S['select'][P]>>  :
        P extends 'Loads' ? Array < LoadsGetPayload<S['select'][P]>>  :
        P extends 'Weeklies' ? Array < WeekliesGetPayload<S['select'][P]>>  :
        P extends '_count' ? LoadTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LoadTypes ? LoadTypes[P] : never
  } 
    : LoadTypes
  : LoadTypes


  type LoadTypesCountArgs = Merge<
    Omit<LoadTypesFindManyArgs, 'select' | 'include'> & {
      select?: LoadTypesCountAggregateInputType | true
    }
  >

  export interface LoadTypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LoadTypes that matches the filter.
     * @param {LoadTypesFindUniqueArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoadTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoadTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LoadTypes'> extends True ? CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>> : CheckSelect<T, Prisma__LoadTypesClient<LoadTypes | null >, Prisma__LoadTypesClient<LoadTypesGetPayload<T> | null >>

    /**
     * Find the first LoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesFindFirstArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoadTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoadTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LoadTypes'> extends True ? CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>> : CheckSelect<T, Prisma__LoadTypesClient<LoadTypes | null >, Prisma__LoadTypesClient<LoadTypesGetPayload<T> | null >>

    /**
     * Find zero or more LoadTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoadTypes
     * const loadTypes = await prisma.loadTypes.findMany()
     * 
     * // Get first 10 LoadTypes
     * const loadTypes = await prisma.loadTypes.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const loadTypesWithIDOnly = await prisma.loadTypes.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends LoadTypesFindManyArgs>(
      args?: SelectSubset<T, LoadTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LoadTypes>>, PrismaPromise<Array<LoadTypesGetPayload<T>>>>

    /**
     * Create a LoadTypes.
     * @param {LoadTypesCreateArgs} args - Arguments to create a LoadTypes.
     * @example
     * // Create one LoadTypes
     * const LoadTypes = await prisma.loadTypes.create({
     *   data: {
     *     // ... data to create a LoadTypes
     *   }
     * })
     * 
    **/
    create<T extends LoadTypesCreateArgs>(
      args: SelectSubset<T, LoadTypesCreateArgs>
    ): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>>

    /**
     * Create many LoadTypes.
     *     @param {LoadTypesCreateManyArgs} args - Arguments to create many LoadTypes.
     *     @example
     *     // Create many LoadTypes
     *     const loadTypes = await prisma.loadTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoadTypesCreateManyArgs>(
      args?: SelectSubset<T, LoadTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LoadTypes.
     * @param {LoadTypesDeleteArgs} args - Arguments to delete one LoadTypes.
     * @example
     * // Delete one LoadTypes
     * const LoadTypes = await prisma.loadTypes.delete({
     *   where: {
     *     // ... filter to delete one LoadTypes
     *   }
     * })
     * 
    **/
    delete<T extends LoadTypesDeleteArgs>(
      args: SelectSubset<T, LoadTypesDeleteArgs>
    ): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>>

    /**
     * Update one LoadTypes.
     * @param {LoadTypesUpdateArgs} args - Arguments to update one LoadTypes.
     * @example
     * // Update one LoadTypes
     * const loadTypes = await prisma.loadTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoadTypesUpdateArgs>(
      args: SelectSubset<T, LoadTypesUpdateArgs>
    ): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>>

    /**
     * Delete zero or more LoadTypes.
     * @param {LoadTypesDeleteManyArgs} args - Arguments to filter LoadTypes to delete.
     * @example
     * // Delete a few LoadTypes
     * const { count } = await prisma.loadTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoadTypesDeleteManyArgs>(
      args?: SelectSubset<T, LoadTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoadTypes
     * const loadTypes = await prisma.loadTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoadTypesUpdateManyArgs>(
      args: SelectSubset<T, LoadTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LoadTypes.
     * @param {LoadTypesUpsertArgs} args - Arguments to update or create a LoadTypes.
     * @example
     * // Update or create a LoadTypes
     * const loadTypes = await prisma.loadTypes.upsert({
     *   create: {
     *     // ... data to create a LoadTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoadTypes we want to update
     *   }
     * })
    **/
    upsert<T extends LoadTypesUpsertArgs>(
      args: SelectSubset<T, LoadTypesUpsertArgs>
    ): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>>

    /**
     * Find one LoadTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LoadTypesFindUniqueOrThrowArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoadTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LoadTypesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>>

    /**
     * Find the first LoadTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesFindFirstOrThrowArgs} args - Arguments to find a LoadTypes
     * @example
     * // Get one LoadTypes
     * const loadTypes = await prisma.loadTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoadTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LoadTypesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes>, Prisma__LoadTypesClient<LoadTypesGetPayload<T>>>

    /**
     * Count the number of LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesCountArgs} args - Arguments to filter LoadTypes to count.
     * @example
     * // Count the number of LoadTypes
     * const count = await prisma.loadTypes.count({
     *   where: {
     *     // ... the filter for the LoadTypes we want to count
     *   }
     * })
    **/
    count<T extends LoadTypesCountArgs>(
      args?: Subset<T, LoadTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoadTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoadTypesAggregateArgs>(args: Subset<T, LoadTypesAggregateArgs>): PrismaPromise<GetLoadTypesAggregateType<T>>

    /**
     * Group by LoadTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoadTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoadTypesGroupByArgs['orderBy'] }
        : { orderBy?: LoadTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoadTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoadTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LoadTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoadTypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CustomerLoadTypes<T extends CustomerLoadTypesFindManyArgs = {}>(args?: Subset<T, CustomerLoadTypesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerLoadTypes>>, PrismaPromise<Array<CustomerLoadTypesGetPayload<T>>>>;

    Jobs<T extends JobsFindManyArgs = {}>(args?: Subset<T, JobsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>;

    Loads<T extends LoadsFindManyArgs = {}>(args?: Subset<T, LoadsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>;

    Weeklies<T extends WeekliesFindManyArgs = {}>(args?: Subset<T, WeekliesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Weeklies>>, PrismaPromise<Array<WeekliesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LoadTypes base type for findUnique actions
   */
  export type LoadTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
    /**
     * Filter, which LoadTypes to fetch.
     * 
    **/
    where: LoadTypesWhereUniqueInput
  }

  /**
   * LoadTypes: findUnique
   */
  export interface LoadTypesFindUniqueArgs extends LoadTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoadTypes base type for findFirst actions
   */
  export type LoadTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
    /**
     * Filter, which LoadTypes to fetch.
     * 
    **/
    where?: LoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoadTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LoadTypesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoadTypes.
     * 
    **/
    cursor?: LoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoadTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoadTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoadTypes.
     * 
    **/
    distinct?: Enumerable<LoadTypesScalarFieldEnum>
  }

  /**
   * LoadTypes: findFirst
   */
  export interface LoadTypesFindFirstArgs extends LoadTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoadTypes findMany
   */
  export type LoadTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
    /**
     * Filter, which LoadTypes to fetch.
     * 
    **/
    where?: LoadTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoadTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LoadTypesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoadTypes.
     * 
    **/
    cursor?: LoadTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoadTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoadTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LoadTypesScalarFieldEnum>
  }


  /**
   * LoadTypes create
   */
  export type LoadTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
    /**
     * The data needed to create a LoadTypes.
     * 
    **/
    data: XOR<LoadTypesCreateInput, LoadTypesUncheckedCreateInput>
  }


  /**
   * LoadTypes createMany
   */
  export type LoadTypesCreateManyArgs = {
    /**
     * The data used to create many LoadTypes.
     * 
    **/
    data: Enumerable<LoadTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LoadTypes update
   */
  export type LoadTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
    /**
     * The data needed to update a LoadTypes.
     * 
    **/
    data: XOR<LoadTypesUpdateInput, LoadTypesUncheckedUpdateInput>
    /**
     * Choose, which LoadTypes to update.
     * 
    **/
    where: LoadTypesWhereUniqueInput
  }


  /**
   * LoadTypes updateMany
   */
  export type LoadTypesUpdateManyArgs = {
    /**
     * The data used to update LoadTypes.
     * 
    **/
    data: XOR<LoadTypesUpdateManyMutationInput, LoadTypesUncheckedUpdateManyInput>
    /**
     * Filter which LoadTypes to update
     * 
    **/
    where?: LoadTypesWhereInput
  }


  /**
   * LoadTypes upsert
   */
  export type LoadTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
    /**
     * The filter to search for the LoadTypes to update in case it exists.
     * 
    **/
    where: LoadTypesWhereUniqueInput
    /**
     * In case the LoadTypes found by the `where` argument doesn't exist, create a new LoadTypes with this data.
     * 
    **/
    create: XOR<LoadTypesCreateInput, LoadTypesUncheckedCreateInput>
    /**
     * In case the LoadTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LoadTypesUpdateInput, LoadTypesUncheckedUpdateInput>
  }


  /**
   * LoadTypes delete
   */
  export type LoadTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
    /**
     * Filter which LoadTypes to delete.
     * 
    **/
    where: LoadTypesWhereUniqueInput
  }


  /**
   * LoadTypes deleteMany
   */
  export type LoadTypesDeleteManyArgs = {
    /**
     * Filter which LoadTypes to delete
     * 
    **/
    where?: LoadTypesWhereInput
  }


  /**
   * LoadTypes: findUniqueOrThrow
   */
  export type LoadTypesFindUniqueOrThrowArgs = LoadTypesFindUniqueArgsBase
      

  /**
   * LoadTypes: findFirstOrThrow
   */
  export type LoadTypesFindFirstOrThrowArgs = LoadTypesFindFirstArgsBase
      

  /**
   * LoadTypes without action
   */
  export type LoadTypesArgs = {
    /**
     * Select specific fields to fetch from the LoadTypes
     * 
    **/
    select?: LoadTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadTypesInclude | null
  }



  /**
   * Model States
   */


  export type AggregateStates = {
    _count: StatesCountAggregateOutputType | null
    _avg: StatesAvgAggregateOutputType | null
    _sum: StatesSumAggregateOutputType | null
    _min: StatesMinAggregateOutputType | null
    _max: StatesMaxAggregateOutputType | null
  }

  export type StatesAvgAggregateOutputType = {
    ID: number | null
  }

  export type StatesSumAggregateOutputType = {
    ID: number | null
  }

  export type StatesMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    Abbreviation: string | null
  }

  export type StatesMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    Abbreviation: string | null
  }

  export type StatesCountAggregateOutputType = {
    ID: number
    Name: number
    Abbreviation: number
    _all: number
  }


  export type StatesAvgAggregateInputType = {
    ID?: true
  }

  export type StatesSumAggregateInputType = {
    ID?: true
  }

  export type StatesMinAggregateInputType = {
    ID?: true
    Name?: true
    Abbreviation?: true
  }

  export type StatesMaxAggregateInputType = {
    ID?: true
    Name?: true
    Abbreviation?: true
  }

  export type StatesCountAggregateInputType = {
    ID?: true
    Name?: true
    Abbreviation?: true
    _all?: true
  }

  export type StatesAggregateArgs = {
    /**
     * Filter which States to aggregate.
     * 
    **/
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StatesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatesMaxAggregateInputType
  }

  export type GetStatesAggregateType<T extends StatesAggregateArgs> = {
        [P in keyof T & keyof AggregateStates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStates[P]>
      : GetScalarType<T[P], AggregateStates[P]>
  }




  export type StatesGroupByArgs = {
    where?: StatesWhereInput
    orderBy?: Enumerable<StatesOrderByWithAggregationInput>
    by: Array<StatesScalarFieldEnum>
    having?: StatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatesCountAggregateInputType | true
    _avg?: StatesAvgAggregateInputType
    _sum?: StatesSumAggregateInputType
    _min?: StatesMinAggregateInputType
    _max?: StatesMaxAggregateInputType
  }


  export type StatesGroupByOutputType = {
    ID: number
    Name: string
    Abbreviation: string
    _count: StatesCountAggregateOutputType | null
    _avg: StatesAvgAggregateOutputType | null
    _sum: StatesSumAggregateOutputType | null
    _min: StatesMinAggregateOutputType | null
    _max: StatesMaxAggregateOutputType | null
  }

  type GetStatesGroupByPayload<T extends StatesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatesGroupByOutputType[P]>
            : GetScalarType<T[P], StatesGroupByOutputType[P]>
        }
      >
    >


  export type StatesSelect = {
    ID?: boolean
    Name?: boolean
    Abbreviation?: boolean
    Customers?: boolean | CustomersFindManyArgs
    Drivers?: boolean | DriversFindManyArgs
    _count?: boolean | StatesCountOutputTypeArgs
  }

  export type StatesInclude = {
    Customers?: boolean | CustomersFindManyArgs
    Drivers?: boolean | DriversFindManyArgs
    _count?: boolean | StatesCountOutputTypeArgs
  }

  export type StatesGetPayload<
    S extends boolean | null | undefined | StatesArgs,
    U = keyof S
      > = S extends true
        ? States
    : S extends undefined
    ? never
    : S extends StatesArgs | StatesFindManyArgs
    ?'include' extends U
    ? States  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? Array < CustomersGetPayload<S['include'][P]>>  :
        P extends 'Drivers' ? Array < DriversGetPayload<S['include'][P]>>  :
        P extends '_count' ? StatesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? Array < CustomersGetPayload<S['select'][P]>>  :
        P extends 'Drivers' ? Array < DriversGetPayload<S['select'][P]>>  :
        P extends '_count' ? StatesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof States ? States[P] : never
  } 
    : States
  : States


  type StatesCountArgs = Merge<
    Omit<StatesFindManyArgs, 'select' | 'include'> & {
      select?: StatesCountAggregateInputType | true
    }
  >

  export interface StatesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one States that matches the filter.
     * @param {StatesFindUniqueArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StatesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'States'> extends True ? CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>> : CheckSelect<T, Prisma__StatesClient<States | null >, Prisma__StatesClient<StatesGetPayload<T> | null >>

    /**
     * Find the first States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindFirstArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StatesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'States'> extends True ? CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>> : CheckSelect<T, Prisma__StatesClient<States | null >, Prisma__StatesClient<StatesGetPayload<T> | null >>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.states.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.states.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const statesWithIDOnly = await prisma.states.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends StatesFindManyArgs>(
      args?: SelectSubset<T, StatesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<States>>, PrismaPromise<Array<StatesGetPayload<T>>>>

    /**
     * Create a States.
     * @param {StatesCreateArgs} args - Arguments to create a States.
     * @example
     * // Create one States
     * const States = await prisma.states.create({
     *   data: {
     *     // ... data to create a States
     *   }
     * })
     * 
    **/
    create<T extends StatesCreateArgs>(
      args: SelectSubset<T, StatesCreateArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Create many States.
     *     @param {StatesCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const states = await prisma.states.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatesCreateManyArgs>(
      args?: SelectSubset<T, StatesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a States.
     * @param {StatesDeleteArgs} args - Arguments to delete one States.
     * @example
     * // Delete one States
     * const States = await prisma.states.delete({
     *   where: {
     *     // ... filter to delete one States
     *   }
     * })
     * 
    **/
    delete<T extends StatesDeleteArgs>(
      args: SelectSubset<T, StatesDeleteArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Update one States.
     * @param {StatesUpdateArgs} args - Arguments to update one States.
     * @example
     * // Update one States
     * const states = await prisma.states.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatesUpdateArgs>(
      args: SelectSubset<T, StatesUpdateArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Delete zero or more States.
     * @param {StatesDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.states.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatesDeleteManyArgs>(
      args?: SelectSubset<T, StatesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const states = await prisma.states.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatesUpdateManyArgs>(
      args: SelectSubset<T, StatesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one States.
     * @param {StatesUpsertArgs} args - Arguments to update or create a States.
     * @example
     * // Update or create a States
     * const states = await prisma.states.upsert({
     *   create: {
     *     // ... data to create a States
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the States we want to update
     *   }
     * })
    **/
    upsert<T extends StatesUpsertArgs>(
      args: SelectSubset<T, StatesUpsertArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Find one States that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StatesFindUniqueOrThrowArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StatesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StatesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Find the first States that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindFirstOrThrowArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StatesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StatesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.states.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StatesCountArgs>(
      args?: Subset<T, StatesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatesAggregateArgs>(args: Subset<T, StatesAggregateArgs>): PrismaPromise<GetStatesAggregateType<T>>

    /**
     * Group by States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatesGroupByArgs['orderBy'] }
        : { orderBy?: StatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for States.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StatesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersFindManyArgs = {}>(args?: Subset<T, CustomersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Customers>>, PrismaPromise<Array<CustomersGetPayload<T>>>>;

    Drivers<T extends DriversFindManyArgs = {}>(args?: Subset<T, DriversFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Drivers>>, PrismaPromise<Array<DriversGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * States base type for findUnique actions
   */
  export type StatesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
    /**
     * Filter, which States to fetch.
     * 
    **/
    where: StatesWhereUniqueInput
  }

  /**
   * States: findUnique
   */
  export interface StatesFindUniqueArgs extends StatesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * States base type for findFirst actions
   */
  export type StatesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
    /**
     * Filter, which States to fetch.
     * 
    **/
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StatesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     * 
    **/
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     * 
    **/
    distinct?: Enumerable<StatesScalarFieldEnum>
  }

  /**
   * States: findFirst
   */
  export interface StatesFindFirstArgs extends StatesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * States findMany
   */
  export type StatesFindManyArgs = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
    /**
     * Filter, which States to fetch.
     * 
    **/
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StatesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     * 
    **/
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StatesScalarFieldEnum>
  }


  /**
   * States create
   */
  export type StatesCreateArgs = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
    /**
     * The data needed to create a States.
     * 
    **/
    data: XOR<StatesCreateInput, StatesUncheckedCreateInput>
  }


  /**
   * States createMany
   */
  export type StatesCreateManyArgs = {
    /**
     * The data used to create many States.
     * 
    **/
    data: Enumerable<StatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * States update
   */
  export type StatesUpdateArgs = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
    /**
     * The data needed to update a States.
     * 
    **/
    data: XOR<StatesUpdateInput, StatesUncheckedUpdateInput>
    /**
     * Choose, which States to update.
     * 
    **/
    where: StatesWhereUniqueInput
  }


  /**
   * States updateMany
   */
  export type StatesUpdateManyArgs = {
    /**
     * The data used to update States.
     * 
    **/
    data: XOR<StatesUpdateManyMutationInput, StatesUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     * 
    **/
    where?: StatesWhereInput
  }


  /**
   * States upsert
   */
  export type StatesUpsertArgs = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
    /**
     * The filter to search for the States to update in case it exists.
     * 
    **/
    where: StatesWhereUniqueInput
    /**
     * In case the States found by the `where` argument doesn't exist, create a new States with this data.
     * 
    **/
    create: XOR<StatesCreateInput, StatesUncheckedCreateInput>
    /**
     * In case the States was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StatesUpdateInput, StatesUncheckedUpdateInput>
  }


  /**
   * States delete
   */
  export type StatesDeleteArgs = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
    /**
     * Filter which States to delete.
     * 
    **/
    where: StatesWhereUniqueInput
  }


  /**
   * States deleteMany
   */
  export type StatesDeleteManyArgs = {
    /**
     * Filter which States to delete
     * 
    **/
    where?: StatesWhereInput
  }


  /**
   * States: findUniqueOrThrow
   */
  export type StatesFindUniqueOrThrowArgs = StatesFindUniqueArgsBase
      

  /**
   * States: findFirstOrThrow
   */
  export type StatesFindFirstOrThrowArgs = StatesFindFirstArgsBase
      

  /**
   * States without action
   */
  export type StatesArgs = {
    /**
     * Select specific fields to fetch from the States
     * 
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatesInclude | null
  }



  /**
   * Model Trucks
   */


  export type AggregateTrucks = {
    _count: TrucksCountAggregateOutputType | null
    _avg: TrucksAvgAggregateOutputType | null
    _sum: TrucksSumAggregateOutputType | null
    _min: TrucksMinAggregateOutputType | null
    _max: TrucksMaxAggregateOutputType | null
  }

  export type TrucksAvgAggregateOutputType = {
    ID: number | null
  }

  export type TrucksSumAggregateOutputType = {
    ID: number | null
  }

  export type TrucksMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    VIN: string | null
    Deleted: boolean | null
    Notes: string | null
  }

  export type TrucksMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    VIN: string | null
    Deleted: boolean | null
    Notes: string | null
  }

  export type TrucksCountAggregateOutputType = {
    ID: number
    Name: number
    VIN: number
    Deleted: number
    Notes: number
    _all: number
  }


  export type TrucksAvgAggregateInputType = {
    ID?: true
  }

  export type TrucksSumAggregateInputType = {
    ID?: true
  }

  export type TrucksMinAggregateInputType = {
    ID?: true
    Name?: true
    VIN?: true
    Deleted?: true
    Notes?: true
  }

  export type TrucksMaxAggregateInputType = {
    ID?: true
    Name?: true
    VIN?: true
    Deleted?: true
    Notes?: true
  }

  export type TrucksCountAggregateInputType = {
    ID?: true
    Name?: true
    VIN?: true
    Deleted?: true
    Notes?: true
    _all?: true
  }

  export type TrucksAggregateArgs = {
    /**
     * Filter which Trucks to aggregate.
     * 
    **/
    where?: TrucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     * 
    **/
    orderBy?: Enumerable<TrucksOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TrucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trucks
    **/
    _count?: true | TrucksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrucksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrucksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrucksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrucksMaxAggregateInputType
  }

  export type GetTrucksAggregateType<T extends TrucksAggregateArgs> = {
        [P in keyof T & keyof AggregateTrucks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrucks[P]>
      : GetScalarType<T[P], AggregateTrucks[P]>
  }




  export type TrucksGroupByArgs = {
    where?: TrucksWhereInput
    orderBy?: Enumerable<TrucksOrderByWithAggregationInput>
    by: Array<TrucksScalarFieldEnum>
    having?: TrucksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrucksCountAggregateInputType | true
    _avg?: TrucksAvgAggregateInputType
    _sum?: TrucksSumAggregateInputType
    _min?: TrucksMinAggregateInputType
    _max?: TrucksMaxAggregateInputType
  }


  export type TrucksGroupByOutputType = {
    ID: number
    Name: string
    VIN: string | null
    Deleted: boolean | null
    Notes: string | null
    _count: TrucksCountAggregateOutputType | null
    _avg: TrucksAvgAggregateOutputType | null
    _sum: TrucksSumAggregateOutputType | null
    _min: TrucksMinAggregateOutputType | null
    _max: TrucksMaxAggregateOutputType | null
  }

  type GetTrucksGroupByPayload<T extends TrucksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TrucksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrucksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrucksGroupByOutputType[P]>
            : GetScalarType<T[P], TrucksGroupByOutputType[P]>
        }
      >
    >


  export type TrucksSelect = {
    ID?: boolean
    Name?: boolean
    VIN?: boolean
    Deleted?: boolean
    Notes?: boolean
    Loads?: boolean | LoadsFindManyArgs
    TrucksDriven?: boolean | TrucksDrivenFindManyArgs
    _count?: boolean | TrucksCountOutputTypeArgs
  }

  export type TrucksInclude = {
    Loads?: boolean | LoadsFindManyArgs
    TrucksDriven?: boolean | TrucksDrivenFindManyArgs
    _count?: boolean | TrucksCountOutputTypeArgs
  }

  export type TrucksGetPayload<
    S extends boolean | null | undefined | TrucksArgs,
    U = keyof S
      > = S extends true
        ? Trucks
    : S extends undefined
    ? never
    : S extends TrucksArgs | TrucksFindManyArgs
    ?'include' extends U
    ? Trucks  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Loads' ? Array < LoadsGetPayload<S['include'][P]>>  :
        P extends 'TrucksDriven' ? Array < TrucksDrivenGetPayload<S['include'][P]>>  :
        P extends '_count' ? TrucksCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Loads' ? Array < LoadsGetPayload<S['select'][P]>>  :
        P extends 'TrucksDriven' ? Array < TrucksDrivenGetPayload<S['select'][P]>>  :
        P extends '_count' ? TrucksCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Trucks ? Trucks[P] : never
  } 
    : Trucks
  : Trucks


  type TrucksCountArgs = Merge<
    Omit<TrucksFindManyArgs, 'select' | 'include'> & {
      select?: TrucksCountAggregateInputType | true
    }
  >

  export interface TrucksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Trucks that matches the filter.
     * @param {TrucksFindUniqueArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrucksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrucksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Trucks'> extends True ? CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>> : CheckSelect<T, Prisma__TrucksClient<Trucks | null >, Prisma__TrucksClient<TrucksGetPayload<T> | null >>

    /**
     * Find the first Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksFindFirstArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrucksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrucksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Trucks'> extends True ? CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>> : CheckSelect<T, Prisma__TrucksClient<Trucks | null >, Prisma__TrucksClient<TrucksGetPayload<T> | null >>

    /**
     * Find zero or more Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trucks
     * const trucks = await prisma.trucks.findMany()
     * 
     * // Get first 10 Trucks
     * const trucks = await prisma.trucks.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const trucksWithIDOnly = await prisma.trucks.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TrucksFindManyArgs>(
      args?: SelectSubset<T, TrucksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Trucks>>, PrismaPromise<Array<TrucksGetPayload<T>>>>

    /**
     * Create a Trucks.
     * @param {TrucksCreateArgs} args - Arguments to create a Trucks.
     * @example
     * // Create one Trucks
     * const Trucks = await prisma.trucks.create({
     *   data: {
     *     // ... data to create a Trucks
     *   }
     * })
     * 
    **/
    create<T extends TrucksCreateArgs>(
      args: SelectSubset<T, TrucksCreateArgs>
    ): CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>>

    /**
     * Create many Trucks.
     *     @param {TrucksCreateManyArgs} args - Arguments to create many Trucks.
     *     @example
     *     // Create many Trucks
     *     const trucks = await prisma.trucks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrucksCreateManyArgs>(
      args?: SelectSubset<T, TrucksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Trucks.
     * @param {TrucksDeleteArgs} args - Arguments to delete one Trucks.
     * @example
     * // Delete one Trucks
     * const Trucks = await prisma.trucks.delete({
     *   where: {
     *     // ... filter to delete one Trucks
     *   }
     * })
     * 
    **/
    delete<T extends TrucksDeleteArgs>(
      args: SelectSubset<T, TrucksDeleteArgs>
    ): CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>>

    /**
     * Update one Trucks.
     * @param {TrucksUpdateArgs} args - Arguments to update one Trucks.
     * @example
     * // Update one Trucks
     * const trucks = await prisma.trucks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrucksUpdateArgs>(
      args: SelectSubset<T, TrucksUpdateArgs>
    ): CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>>

    /**
     * Delete zero or more Trucks.
     * @param {TrucksDeleteManyArgs} args - Arguments to filter Trucks to delete.
     * @example
     * // Delete a few Trucks
     * const { count } = await prisma.trucks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrucksDeleteManyArgs>(
      args?: SelectSubset<T, TrucksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trucks
     * const trucks = await prisma.trucks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrucksUpdateManyArgs>(
      args: SelectSubset<T, TrucksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Trucks.
     * @param {TrucksUpsertArgs} args - Arguments to update or create a Trucks.
     * @example
     * // Update or create a Trucks
     * const trucks = await prisma.trucks.upsert({
     *   create: {
     *     // ... data to create a Trucks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trucks we want to update
     *   }
     * })
    **/
    upsert<T extends TrucksUpsertArgs>(
      args: SelectSubset<T, TrucksUpsertArgs>
    ): CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>>

    /**
     * Find one Trucks that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TrucksFindUniqueOrThrowArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrucksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TrucksFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>>

    /**
     * Find the first Trucks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksFindFirstOrThrowArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrucksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TrucksFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TrucksClient<Trucks>, Prisma__TrucksClient<TrucksGetPayload<T>>>

    /**
     * Count the number of Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksCountArgs} args - Arguments to filter Trucks to count.
     * @example
     * // Count the number of Trucks
     * const count = await prisma.trucks.count({
     *   where: {
     *     // ... the filter for the Trucks we want to count
     *   }
     * })
    **/
    count<T extends TrucksCountArgs>(
      args?: Subset<T, TrucksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrucksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrucksAggregateArgs>(args: Subset<T, TrucksAggregateArgs>): PrismaPromise<GetTrucksAggregateType<T>>

    /**
     * Group by Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrucksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrucksGroupByArgs['orderBy'] }
        : { orderBy?: TrucksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrucksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrucksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Trucks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrucksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Loads<T extends LoadsFindManyArgs = {}>(args?: Subset<T, LoadsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>;

    TrucksDriven<T extends TrucksDrivenFindManyArgs = {}>(args?: Subset<T, TrucksDrivenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TrucksDriven>>, PrismaPromise<Array<TrucksDrivenGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Trucks base type for findUnique actions
   */
  export type TrucksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
    /**
     * Filter, which Trucks to fetch.
     * 
    **/
    where: TrucksWhereUniqueInput
  }

  /**
   * Trucks: findUnique
   */
  export interface TrucksFindUniqueArgs extends TrucksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Trucks base type for findFirst actions
   */
  export type TrucksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
    /**
     * Filter, which Trucks to fetch.
     * 
    **/
    where?: TrucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     * 
    **/
    orderBy?: Enumerable<TrucksOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trucks.
     * 
    **/
    cursor?: TrucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trucks.
     * 
    **/
    distinct?: Enumerable<TrucksScalarFieldEnum>
  }

  /**
   * Trucks: findFirst
   */
  export interface TrucksFindFirstArgs extends TrucksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Trucks findMany
   */
  export type TrucksFindManyArgs = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
    /**
     * Filter, which Trucks to fetch.
     * 
    **/
    where?: TrucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trucks to fetch.
     * 
    **/
    orderBy?: Enumerable<TrucksOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trucks.
     * 
    **/
    cursor?: TrucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trucks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trucks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TrucksScalarFieldEnum>
  }


  /**
   * Trucks create
   */
  export type TrucksCreateArgs = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
    /**
     * The data needed to create a Trucks.
     * 
    **/
    data: XOR<TrucksCreateInput, TrucksUncheckedCreateInput>
  }


  /**
   * Trucks createMany
   */
  export type TrucksCreateManyArgs = {
    /**
     * The data used to create many Trucks.
     * 
    **/
    data: Enumerable<TrucksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Trucks update
   */
  export type TrucksUpdateArgs = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
    /**
     * The data needed to update a Trucks.
     * 
    **/
    data: XOR<TrucksUpdateInput, TrucksUncheckedUpdateInput>
    /**
     * Choose, which Trucks to update.
     * 
    **/
    where: TrucksWhereUniqueInput
  }


  /**
   * Trucks updateMany
   */
  export type TrucksUpdateManyArgs = {
    /**
     * The data used to update Trucks.
     * 
    **/
    data: XOR<TrucksUpdateManyMutationInput, TrucksUncheckedUpdateManyInput>
    /**
     * Filter which Trucks to update
     * 
    **/
    where?: TrucksWhereInput
  }


  /**
   * Trucks upsert
   */
  export type TrucksUpsertArgs = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
    /**
     * The filter to search for the Trucks to update in case it exists.
     * 
    **/
    where: TrucksWhereUniqueInput
    /**
     * In case the Trucks found by the `where` argument doesn't exist, create a new Trucks with this data.
     * 
    **/
    create: XOR<TrucksCreateInput, TrucksUncheckedCreateInput>
    /**
     * In case the Trucks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TrucksUpdateInput, TrucksUncheckedUpdateInput>
  }


  /**
   * Trucks delete
   */
  export type TrucksDeleteArgs = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
    /**
     * Filter which Trucks to delete.
     * 
    **/
    where: TrucksWhereUniqueInput
  }


  /**
   * Trucks deleteMany
   */
  export type TrucksDeleteManyArgs = {
    /**
     * Filter which Trucks to delete
     * 
    **/
    where?: TrucksWhereInput
  }


  /**
   * Trucks: findUniqueOrThrow
   */
  export type TrucksFindUniqueOrThrowArgs = TrucksFindUniqueArgsBase
      

  /**
   * Trucks: findFirstOrThrow
   */
  export type TrucksFindFirstOrThrowArgs = TrucksFindFirstArgsBase
      

  /**
   * Trucks without action
   */
  export type TrucksArgs = {
    /**
     * Select specific fields to fetch from the Trucks
     * 
    **/
    select?: TrucksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksInclude | null
  }



  /**
   * Model TrucksDriven
   */


  export type AggregateTrucksDriven = {
    _count: TrucksDrivenCountAggregateOutputType | null
    _avg: TrucksDrivenAvgAggregateOutputType | null
    _sum: TrucksDrivenSumAggregateOutputType | null
    _min: TrucksDrivenMinAggregateOutputType | null
    _max: TrucksDrivenMaxAggregateOutputType | null
  }

  export type TrucksDrivenAvgAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
  }

  export type TrucksDrivenSumAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
  }

  export type TrucksDrivenMinAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
    DateDriven: Date | null
  }

  export type TrucksDrivenMaxAggregateOutputType = {
    ID: number | null
    TruckID: number | null
    DriverID: number | null
    DateDriven: Date | null
  }

  export type TrucksDrivenCountAggregateOutputType = {
    ID: number
    TruckID: number
    DriverID: number
    DateDriven: number
    _all: number
  }


  export type TrucksDrivenAvgAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
  }

  export type TrucksDrivenSumAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
  }

  export type TrucksDrivenMinAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
    DateDriven?: true
  }

  export type TrucksDrivenMaxAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
    DateDriven?: true
  }

  export type TrucksDrivenCountAggregateInputType = {
    ID?: true
    TruckID?: true
    DriverID?: true
    DateDriven?: true
    _all?: true
  }

  export type TrucksDrivenAggregateArgs = {
    /**
     * Filter which TrucksDriven to aggregate.
     * 
    **/
    where?: TrucksDrivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrucksDrivens to fetch.
     * 
    **/
    orderBy?: Enumerable<TrucksDrivenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TrucksDrivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrucksDrivens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrucksDrivens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrucksDrivens
    **/
    _count?: true | TrucksDrivenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrucksDrivenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrucksDrivenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrucksDrivenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrucksDrivenMaxAggregateInputType
  }

  export type GetTrucksDrivenAggregateType<T extends TrucksDrivenAggregateArgs> = {
        [P in keyof T & keyof AggregateTrucksDriven]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrucksDriven[P]>
      : GetScalarType<T[P], AggregateTrucksDriven[P]>
  }




  export type TrucksDrivenGroupByArgs = {
    where?: TrucksDrivenWhereInput
    orderBy?: Enumerable<TrucksDrivenOrderByWithAggregationInput>
    by: Array<TrucksDrivenScalarFieldEnum>
    having?: TrucksDrivenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrucksDrivenCountAggregateInputType | true
    _avg?: TrucksDrivenAvgAggregateInputType
    _sum?: TrucksDrivenSumAggregateInputType
    _min?: TrucksDrivenMinAggregateInputType
    _max?: TrucksDrivenMaxAggregateInputType
  }


  export type TrucksDrivenGroupByOutputType = {
    ID: number
    TruckID: number
    DriverID: number
    DateDriven: Date
    _count: TrucksDrivenCountAggregateOutputType | null
    _avg: TrucksDrivenAvgAggregateOutputType | null
    _sum: TrucksDrivenSumAggregateOutputType | null
    _min: TrucksDrivenMinAggregateOutputType | null
    _max: TrucksDrivenMaxAggregateOutputType | null
  }

  type GetTrucksDrivenGroupByPayload<T extends TrucksDrivenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TrucksDrivenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrucksDrivenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrucksDrivenGroupByOutputType[P]>
            : GetScalarType<T[P], TrucksDrivenGroupByOutputType[P]>
        }
      >
    >


  export type TrucksDrivenSelect = {
    ID?: boolean
    TruckID?: boolean
    DriverID?: boolean
    DateDriven?: boolean
    Drivers?: boolean | DriversArgs
    Trucks?: boolean | TrucksArgs
  }

  export type TrucksDrivenInclude = {
    Drivers?: boolean | DriversArgs
    Trucks?: boolean | TrucksArgs
  }

  export type TrucksDrivenGetPayload<
    S extends boolean | null | undefined | TrucksDrivenArgs,
    U = keyof S
      > = S extends true
        ? TrucksDriven
    : S extends undefined
    ? never
    : S extends TrucksDrivenArgs | TrucksDrivenFindManyArgs
    ?'include' extends U
    ? TrucksDriven  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Drivers' ? DriversGetPayload<S['include'][P]> :
        P extends 'Trucks' ? TrucksGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Drivers' ? DriversGetPayload<S['select'][P]> :
        P extends 'Trucks' ? TrucksGetPayload<S['select'][P]> :  P extends keyof TrucksDriven ? TrucksDriven[P] : never
  } 
    : TrucksDriven
  : TrucksDriven


  type TrucksDrivenCountArgs = Merge<
    Omit<TrucksDrivenFindManyArgs, 'select' | 'include'> & {
      select?: TrucksDrivenCountAggregateInputType | true
    }
  >

  export interface TrucksDrivenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TrucksDriven that matches the filter.
     * @param {TrucksDrivenFindUniqueArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrucksDrivenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrucksDrivenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TrucksDriven'> extends True ? CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>> : CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven | null >, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T> | null >>

    /**
     * Find the first TrucksDriven that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenFindFirstArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrucksDrivenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrucksDrivenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TrucksDriven'> extends True ? CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>> : CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven | null >, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T> | null >>

    /**
     * Find zero or more TrucksDrivens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrucksDrivens
     * const trucksDrivens = await prisma.trucksDriven.findMany()
     * 
     * // Get first 10 TrucksDrivens
     * const trucksDrivens = await prisma.trucksDriven.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const trucksDrivenWithIDOnly = await prisma.trucksDriven.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TrucksDrivenFindManyArgs>(
      args?: SelectSubset<T, TrucksDrivenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TrucksDriven>>, PrismaPromise<Array<TrucksDrivenGetPayload<T>>>>

    /**
     * Create a TrucksDriven.
     * @param {TrucksDrivenCreateArgs} args - Arguments to create a TrucksDriven.
     * @example
     * // Create one TrucksDriven
     * const TrucksDriven = await prisma.trucksDriven.create({
     *   data: {
     *     // ... data to create a TrucksDriven
     *   }
     * })
     * 
    **/
    create<T extends TrucksDrivenCreateArgs>(
      args: SelectSubset<T, TrucksDrivenCreateArgs>
    ): CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>>

    /**
     * Create many TrucksDrivens.
     *     @param {TrucksDrivenCreateManyArgs} args - Arguments to create many TrucksDrivens.
     *     @example
     *     // Create many TrucksDrivens
     *     const trucksDriven = await prisma.trucksDriven.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrucksDrivenCreateManyArgs>(
      args?: SelectSubset<T, TrucksDrivenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TrucksDriven.
     * @param {TrucksDrivenDeleteArgs} args - Arguments to delete one TrucksDriven.
     * @example
     * // Delete one TrucksDriven
     * const TrucksDriven = await prisma.trucksDriven.delete({
     *   where: {
     *     // ... filter to delete one TrucksDriven
     *   }
     * })
     * 
    **/
    delete<T extends TrucksDrivenDeleteArgs>(
      args: SelectSubset<T, TrucksDrivenDeleteArgs>
    ): CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>>

    /**
     * Update one TrucksDriven.
     * @param {TrucksDrivenUpdateArgs} args - Arguments to update one TrucksDriven.
     * @example
     * // Update one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrucksDrivenUpdateArgs>(
      args: SelectSubset<T, TrucksDrivenUpdateArgs>
    ): CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>>

    /**
     * Delete zero or more TrucksDrivens.
     * @param {TrucksDrivenDeleteManyArgs} args - Arguments to filter TrucksDrivens to delete.
     * @example
     * // Delete a few TrucksDrivens
     * const { count } = await prisma.trucksDriven.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrucksDrivenDeleteManyArgs>(
      args?: SelectSubset<T, TrucksDrivenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrucksDrivens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrucksDrivens
     * const trucksDriven = await prisma.trucksDriven.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrucksDrivenUpdateManyArgs>(
      args: SelectSubset<T, TrucksDrivenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TrucksDriven.
     * @param {TrucksDrivenUpsertArgs} args - Arguments to update or create a TrucksDriven.
     * @example
     * // Update or create a TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.upsert({
     *   create: {
     *     // ... data to create a TrucksDriven
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrucksDriven we want to update
     *   }
     * })
    **/
    upsert<T extends TrucksDrivenUpsertArgs>(
      args: SelectSubset<T, TrucksDrivenUpsertArgs>
    ): CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>>

    /**
     * Find one TrucksDriven that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TrucksDrivenFindUniqueOrThrowArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrucksDrivenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TrucksDrivenFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>>

    /**
     * Find the first TrucksDriven that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenFindFirstOrThrowArgs} args - Arguments to find a TrucksDriven
     * @example
     * // Get one TrucksDriven
     * const trucksDriven = await prisma.trucksDriven.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrucksDrivenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TrucksDrivenFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TrucksDrivenClient<TrucksDriven>, Prisma__TrucksDrivenClient<TrucksDrivenGetPayload<T>>>

    /**
     * Count the number of TrucksDrivens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenCountArgs} args - Arguments to filter TrucksDrivens to count.
     * @example
     * // Count the number of TrucksDrivens
     * const count = await prisma.trucksDriven.count({
     *   where: {
     *     // ... the filter for the TrucksDrivens we want to count
     *   }
     * })
    **/
    count<T extends TrucksDrivenCountArgs>(
      args?: Subset<T, TrucksDrivenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrucksDrivenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrucksDriven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrucksDrivenAggregateArgs>(args: Subset<T, TrucksDrivenAggregateArgs>): PrismaPromise<GetTrucksDrivenAggregateType<T>>

    /**
     * Group by TrucksDriven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksDrivenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrucksDrivenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrucksDrivenGroupByArgs['orderBy'] }
        : { orderBy?: TrucksDrivenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrucksDrivenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrucksDrivenGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TrucksDriven.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrucksDrivenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Drivers<T extends DriversArgs = {}>(args?: Subset<T, DriversArgs>): CheckSelect<T, Prisma__DriversClient<Drivers | null >, Prisma__DriversClient<DriversGetPayload<T> | null >>;

    Trucks<T extends TrucksArgs = {}>(args?: Subset<T, TrucksArgs>): CheckSelect<T, Prisma__TrucksClient<Trucks | null >, Prisma__TrucksClient<TrucksGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TrucksDriven base type for findUnique actions
   */
  export type TrucksDrivenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
    /**
     * Filter, which TrucksDriven to fetch.
     * 
    **/
    where: TrucksDrivenWhereUniqueInput
  }

  /**
   * TrucksDriven: findUnique
   */
  export interface TrucksDrivenFindUniqueArgs extends TrucksDrivenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrucksDriven base type for findFirst actions
   */
  export type TrucksDrivenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
    /**
     * Filter, which TrucksDriven to fetch.
     * 
    **/
    where?: TrucksDrivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrucksDrivens to fetch.
     * 
    **/
    orderBy?: Enumerable<TrucksDrivenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrucksDrivens.
     * 
    **/
    cursor?: TrucksDrivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrucksDrivens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrucksDrivens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrucksDrivens.
     * 
    **/
    distinct?: Enumerable<TrucksDrivenScalarFieldEnum>
  }

  /**
   * TrucksDriven: findFirst
   */
  export interface TrucksDrivenFindFirstArgs extends TrucksDrivenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrucksDriven findMany
   */
  export type TrucksDrivenFindManyArgs = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
    /**
     * Filter, which TrucksDrivens to fetch.
     * 
    **/
    where?: TrucksDrivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrucksDrivens to fetch.
     * 
    **/
    orderBy?: Enumerable<TrucksDrivenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrucksDrivens.
     * 
    **/
    cursor?: TrucksDrivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrucksDrivens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrucksDrivens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TrucksDrivenScalarFieldEnum>
  }


  /**
   * TrucksDriven create
   */
  export type TrucksDrivenCreateArgs = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
    /**
     * The data needed to create a TrucksDriven.
     * 
    **/
    data: XOR<TrucksDrivenCreateInput, TrucksDrivenUncheckedCreateInput>
  }


  /**
   * TrucksDriven createMany
   */
  export type TrucksDrivenCreateManyArgs = {
    /**
     * The data used to create many TrucksDrivens.
     * 
    **/
    data: Enumerable<TrucksDrivenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TrucksDriven update
   */
  export type TrucksDrivenUpdateArgs = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
    /**
     * The data needed to update a TrucksDriven.
     * 
    **/
    data: XOR<TrucksDrivenUpdateInput, TrucksDrivenUncheckedUpdateInput>
    /**
     * Choose, which TrucksDriven to update.
     * 
    **/
    where: TrucksDrivenWhereUniqueInput
  }


  /**
   * TrucksDriven updateMany
   */
  export type TrucksDrivenUpdateManyArgs = {
    /**
     * The data used to update TrucksDrivens.
     * 
    **/
    data: XOR<TrucksDrivenUpdateManyMutationInput, TrucksDrivenUncheckedUpdateManyInput>
    /**
     * Filter which TrucksDrivens to update
     * 
    **/
    where?: TrucksDrivenWhereInput
  }


  /**
   * TrucksDriven upsert
   */
  export type TrucksDrivenUpsertArgs = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
    /**
     * The filter to search for the TrucksDriven to update in case it exists.
     * 
    **/
    where: TrucksDrivenWhereUniqueInput
    /**
     * In case the TrucksDriven found by the `where` argument doesn't exist, create a new TrucksDriven with this data.
     * 
    **/
    create: XOR<TrucksDrivenCreateInput, TrucksDrivenUncheckedCreateInput>
    /**
     * In case the TrucksDriven was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TrucksDrivenUpdateInput, TrucksDrivenUncheckedUpdateInput>
  }


  /**
   * TrucksDriven delete
   */
  export type TrucksDrivenDeleteArgs = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
    /**
     * Filter which TrucksDriven to delete.
     * 
    **/
    where: TrucksDrivenWhereUniqueInput
  }


  /**
   * TrucksDriven deleteMany
   */
  export type TrucksDrivenDeleteManyArgs = {
    /**
     * Filter which TrucksDrivens to delete
     * 
    **/
    where?: TrucksDrivenWhereInput
  }


  /**
   * TrucksDriven: findUniqueOrThrow
   */
  export type TrucksDrivenFindUniqueOrThrowArgs = TrucksDrivenFindUniqueArgsBase
      

  /**
   * TrucksDriven: findFirstOrThrow
   */
  export type TrucksDrivenFindFirstOrThrowArgs = TrucksDrivenFindFirstArgsBase
      

  /**
   * TrucksDriven without action
   */
  export type TrucksDrivenArgs = {
    /**
     * Select specific fields to fetch from the TrucksDriven
     * 
    **/
    select?: TrucksDrivenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrucksDrivenInclude | null
  }



  /**
   * Model Loads
   */


  export type AggregateLoads = {
    _count: LoadsCountAggregateOutputType | null
    _avg: LoadsAvgAggregateOutputType | null
    _sum: LoadsSumAggregateOutputType | null
    _min: LoadsMinAggregateOutputType | null
    _max: LoadsMaxAggregateOutputType | null
  }

  export type LoadsAvgAggregateOutputType = {
    ID: number | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    TicketNumber: number | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    JobID: number | null
    DriverRate: number | null
  }

  export type LoadsSumAggregateOutputType = {
    ID: number | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    TicketNumber: number | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    JobID: number | null
    DriverRate: number | null
  }

  export type LoadsMinAggregateOutputType = {
    ID: number | null
    StartDate: Date | null
    Created: Date | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    Received: string | null
    Notes: string | null
    TicketNumber: number | null
    Invoiced: boolean | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    Deleted: boolean | null
    JobID: number | null
    Week: string | null
    DriverRate: number | null
  }

  export type LoadsMaxAggregateOutputType = {
    ID: number | null
    StartDate: Date | null
    Created: Date | null
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    Received: string | null
    Notes: string | null
    TicketNumber: number | null
    Invoiced: boolean | null
    CustomerID: number | null
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    Deleted: boolean | null
    JobID: number | null
    Week: string | null
    DriverRate: number | null
  }

  export type LoadsCountAggregateOutputType = {
    ID: number
    StartDate: number
    Created: number
    Weight: number
    Hours: number
    TotalRate: number
    TotalAmount: number
    TruckRate: number
    MaterialRate: number
    Received: number
    Notes: number
    TicketNumber: number
    Invoiced: number
    CustomerID: number
    InvoiceID: number
    LoadTypeID: number
    DeliveryLocationID: number
    TruckID: number
    DriverID: number
    Deleted: number
    JobID: number
    Week: number
    DriverRate: number
    _all: number
  }


  export type LoadsAvgAggregateInputType = {
    ID?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    TicketNumber?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    JobID?: true
    DriverRate?: true
  }

  export type LoadsSumAggregateInputType = {
    ID?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    TicketNumber?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    JobID?: true
    DriverRate?: true
  }

  export type LoadsMinAggregateInputType = {
    ID?: true
    StartDate?: true
    Created?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    Received?: true
    Notes?: true
    TicketNumber?: true
    Invoiced?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    Deleted?: true
    JobID?: true
    Week?: true
    DriverRate?: true
  }

  export type LoadsMaxAggregateInputType = {
    ID?: true
    StartDate?: true
    Created?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    Received?: true
    Notes?: true
    TicketNumber?: true
    Invoiced?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    Deleted?: true
    JobID?: true
    Week?: true
    DriverRate?: true
  }

  export type LoadsCountAggregateInputType = {
    ID?: true
    StartDate?: true
    Created?: true
    Weight?: true
    Hours?: true
    TotalRate?: true
    TotalAmount?: true
    TruckRate?: true
    MaterialRate?: true
    Received?: true
    Notes?: true
    TicketNumber?: true
    Invoiced?: true
    CustomerID?: true
    InvoiceID?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TruckID?: true
    DriverID?: true
    Deleted?: true
    JobID?: true
    Week?: true
    DriverRate?: true
    _all?: true
  }

  export type LoadsAggregateArgs = {
    /**
     * Filter which Loads to aggregate.
     * 
    **/
    where?: LoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loads to fetch.
     * 
    **/
    orderBy?: Enumerable<LoadsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loads
    **/
    _count?: true | LoadsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoadsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoadsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoadsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoadsMaxAggregateInputType
  }

  export type GetLoadsAggregateType<T extends LoadsAggregateArgs> = {
        [P in keyof T & keyof AggregateLoads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoads[P]>
      : GetScalarType<T[P], AggregateLoads[P]>
  }




  export type LoadsGroupByArgs = {
    where?: LoadsWhereInput
    orderBy?: Enumerable<LoadsOrderByWithAggregationInput>
    by: Array<LoadsScalarFieldEnum>
    having?: LoadsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoadsCountAggregateInputType | true
    _avg?: LoadsAvgAggregateInputType
    _sum?: LoadsSumAggregateInputType
    _min?: LoadsMinAggregateInputType
    _max?: LoadsMaxAggregateInputType
  }


  export type LoadsGroupByOutputType = {
    ID: number
    StartDate: Date
    Created: Date
    Weight: number | null
    Hours: number | null
    TotalRate: number | null
    TotalAmount: number | null
    TruckRate: number | null
    MaterialRate: number | null
    Received: string | null
    Notes: string | null
    TicketNumber: number
    Invoiced: boolean | null
    CustomerID: number
    InvoiceID: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TruckID: number | null
    DriverID: number | null
    Deleted: boolean | null
    JobID: number | null
    Week: string
    DriverRate: number | null
    _count: LoadsCountAggregateOutputType | null
    _avg: LoadsAvgAggregateOutputType | null
    _sum: LoadsSumAggregateOutputType | null
    _min: LoadsMinAggregateOutputType | null
    _max: LoadsMaxAggregateOutputType | null
  }

  type GetLoadsGroupByPayload<T extends LoadsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LoadsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoadsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoadsGroupByOutputType[P]>
            : GetScalarType<T[P], LoadsGroupByOutputType[P]>
        }
      >
    >


  export type LoadsSelect = {
    ID?: boolean
    StartDate?: boolean
    Created?: boolean
    Weight?: boolean
    Hours?: boolean
    TotalRate?: boolean
    TotalAmount?: boolean
    TruckRate?: boolean
    MaterialRate?: boolean
    Received?: boolean
    Notes?: boolean
    TicketNumber?: boolean
    Invoiced?: boolean
    CustomerID?: boolean
    InvoiceID?: boolean
    LoadTypeID?: boolean
    DeliveryLocationID?: boolean
    TruckID?: boolean
    DriverID?: boolean
    Deleted?: boolean
    JobID?: boolean
    Week?: boolean
    DriverRate?: boolean
    Customers?: boolean | CustomersArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
    Drivers?: boolean | DriversArgs
    Invoices?: boolean | InvoicesArgs
    Jobs?: boolean | JobsArgs
    LoadTypes?: boolean | LoadTypesArgs
    Trucks?: boolean | TrucksArgs
  }

  export type LoadsInclude = {
    Customers?: boolean | CustomersArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
    Drivers?: boolean | DriversArgs
    Invoices?: boolean | InvoicesArgs
    Jobs?: boolean | JobsArgs
    LoadTypes?: boolean | LoadTypesArgs
    Trucks?: boolean | TrucksArgs
  }

  export type LoadsGetPayload<
    S extends boolean | null | undefined | LoadsArgs,
    U = keyof S
      > = S extends true
        ? Loads
    : S extends undefined
    ? never
    : S extends LoadsArgs | LoadsFindManyArgs
    ?'include' extends U
    ? Loads  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? CustomersGetPayload<S['include'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['include'][P]> | null :
        P extends 'Drivers' ? DriversGetPayload<S['include'][P]> | null :
        P extends 'Invoices' ? InvoicesGetPayload<S['include'][P]> | null :
        P extends 'Jobs' ? JobsGetPayload<S['include'][P]> | null :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['include'][P]> | null :
        P extends 'Trucks' ? TrucksGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? CustomersGetPayload<S['select'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['select'][P]> | null :
        P extends 'Drivers' ? DriversGetPayload<S['select'][P]> | null :
        P extends 'Invoices' ? InvoicesGetPayload<S['select'][P]> | null :
        P extends 'Jobs' ? JobsGetPayload<S['select'][P]> | null :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['select'][P]> | null :
        P extends 'Trucks' ? TrucksGetPayload<S['select'][P]> | null :  P extends keyof Loads ? Loads[P] : never
  } 
    : Loads
  : Loads


  type LoadsCountArgs = Merge<
    Omit<LoadsFindManyArgs, 'select' | 'include'> & {
      select?: LoadsCountAggregateInputType | true
    }
  >

  export interface LoadsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Loads that matches the filter.
     * @param {LoadsFindUniqueArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoadsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoadsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Loads'> extends True ? CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>> : CheckSelect<T, Prisma__LoadsClient<Loads | null >, Prisma__LoadsClient<LoadsGetPayload<T> | null >>

    /**
     * Find the first Loads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsFindFirstArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoadsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoadsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Loads'> extends True ? CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>> : CheckSelect<T, Prisma__LoadsClient<Loads | null >, Prisma__LoadsClient<LoadsGetPayload<T> | null >>

    /**
     * Find zero or more Loads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loads
     * const loads = await prisma.loads.findMany()
     * 
     * // Get first 10 Loads
     * const loads = await prisma.loads.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const loadsWithIDOnly = await prisma.loads.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends LoadsFindManyArgs>(
      args?: SelectSubset<T, LoadsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>

    /**
     * Create a Loads.
     * @param {LoadsCreateArgs} args - Arguments to create a Loads.
     * @example
     * // Create one Loads
     * const Loads = await prisma.loads.create({
     *   data: {
     *     // ... data to create a Loads
     *   }
     * })
     * 
    **/
    create<T extends LoadsCreateArgs>(
      args: SelectSubset<T, LoadsCreateArgs>
    ): CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>>

    /**
     * Create many Loads.
     *     @param {LoadsCreateManyArgs} args - Arguments to create many Loads.
     *     @example
     *     // Create many Loads
     *     const loads = await prisma.loads.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoadsCreateManyArgs>(
      args?: SelectSubset<T, LoadsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Loads.
     * @param {LoadsDeleteArgs} args - Arguments to delete one Loads.
     * @example
     * // Delete one Loads
     * const Loads = await prisma.loads.delete({
     *   where: {
     *     // ... filter to delete one Loads
     *   }
     * })
     * 
    **/
    delete<T extends LoadsDeleteArgs>(
      args: SelectSubset<T, LoadsDeleteArgs>
    ): CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>>

    /**
     * Update one Loads.
     * @param {LoadsUpdateArgs} args - Arguments to update one Loads.
     * @example
     * // Update one Loads
     * const loads = await prisma.loads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoadsUpdateArgs>(
      args: SelectSubset<T, LoadsUpdateArgs>
    ): CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>>

    /**
     * Delete zero or more Loads.
     * @param {LoadsDeleteManyArgs} args - Arguments to filter Loads to delete.
     * @example
     * // Delete a few Loads
     * const { count } = await prisma.loads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoadsDeleteManyArgs>(
      args?: SelectSubset<T, LoadsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loads
     * const loads = await prisma.loads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoadsUpdateManyArgs>(
      args: SelectSubset<T, LoadsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Loads.
     * @param {LoadsUpsertArgs} args - Arguments to update or create a Loads.
     * @example
     * // Update or create a Loads
     * const loads = await prisma.loads.upsert({
     *   create: {
     *     // ... data to create a Loads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loads we want to update
     *   }
     * })
    **/
    upsert<T extends LoadsUpsertArgs>(
      args: SelectSubset<T, LoadsUpsertArgs>
    ): CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>>

    /**
     * Find one Loads that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LoadsFindUniqueOrThrowArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoadsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LoadsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>>

    /**
     * Find the first Loads that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsFindFirstOrThrowArgs} args - Arguments to find a Loads
     * @example
     * // Get one Loads
     * const loads = await prisma.loads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoadsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LoadsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LoadsClient<Loads>, Prisma__LoadsClient<LoadsGetPayload<T>>>

    /**
     * Count the number of Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsCountArgs} args - Arguments to filter Loads to count.
     * @example
     * // Count the number of Loads
     * const count = await prisma.loads.count({
     *   where: {
     *     // ... the filter for the Loads we want to count
     *   }
     * })
    **/
    count<T extends LoadsCountArgs>(
      args?: Subset<T, LoadsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoadsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoadsAggregateArgs>(args: Subset<T, LoadsAggregateArgs>): PrismaPromise<GetLoadsAggregateType<T>>

    /**
     * Group by Loads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoadsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoadsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoadsGroupByArgs['orderBy'] }
        : { orderBy?: LoadsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoadsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoadsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Loads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoadsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    DeliveryLocations<T extends DeliveryLocationsArgs = {}>(args?: Subset<T, DeliveryLocationsArgs>): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations | null >, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T> | null >>;

    Drivers<T extends DriversArgs = {}>(args?: Subset<T, DriversArgs>): CheckSelect<T, Prisma__DriversClient<Drivers | null >, Prisma__DriversClient<DriversGetPayload<T> | null >>;

    Invoices<T extends InvoicesArgs = {}>(args?: Subset<T, InvoicesArgs>): CheckSelect<T, Prisma__InvoicesClient<Invoices | null >, Prisma__InvoicesClient<InvoicesGetPayload<T> | null >>;

    Jobs<T extends JobsArgs = {}>(args?: Subset<T, JobsArgs>): CheckSelect<T, Prisma__JobsClient<Jobs | null >, Prisma__JobsClient<JobsGetPayload<T> | null >>;

    LoadTypes<T extends LoadTypesArgs = {}>(args?: Subset<T, LoadTypesArgs>): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes | null >, Prisma__LoadTypesClient<LoadTypesGetPayload<T> | null >>;

    Trucks<T extends TrucksArgs = {}>(args?: Subset<T, TrucksArgs>): CheckSelect<T, Prisma__TrucksClient<Trucks | null >, Prisma__TrucksClient<TrucksGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Loads base type for findUnique actions
   */
  export type LoadsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
    /**
     * Filter, which Loads to fetch.
     * 
    **/
    where: LoadsWhereUniqueInput
  }

  /**
   * Loads: findUnique
   */
  export interface LoadsFindUniqueArgs extends LoadsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Loads base type for findFirst actions
   */
  export type LoadsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
    /**
     * Filter, which Loads to fetch.
     * 
    **/
    where?: LoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loads to fetch.
     * 
    **/
    orderBy?: Enumerable<LoadsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loads.
     * 
    **/
    cursor?: LoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loads.
     * 
    **/
    distinct?: Enumerable<LoadsScalarFieldEnum>
  }

  /**
   * Loads: findFirst
   */
  export interface LoadsFindFirstArgs extends LoadsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Loads findMany
   */
  export type LoadsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
    /**
     * Filter, which Loads to fetch.
     * 
    **/
    where?: LoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loads to fetch.
     * 
    **/
    orderBy?: Enumerable<LoadsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loads.
     * 
    **/
    cursor?: LoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LoadsScalarFieldEnum>
  }


  /**
   * Loads create
   */
  export type LoadsCreateArgs = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
    /**
     * The data needed to create a Loads.
     * 
    **/
    data: XOR<LoadsCreateInput, LoadsUncheckedCreateInput>
  }


  /**
   * Loads createMany
   */
  export type LoadsCreateManyArgs = {
    /**
     * The data used to create many Loads.
     * 
    **/
    data: Enumerable<LoadsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Loads update
   */
  export type LoadsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
    /**
     * The data needed to update a Loads.
     * 
    **/
    data: XOR<LoadsUpdateInput, LoadsUncheckedUpdateInput>
    /**
     * Choose, which Loads to update.
     * 
    **/
    where: LoadsWhereUniqueInput
  }


  /**
   * Loads updateMany
   */
  export type LoadsUpdateManyArgs = {
    /**
     * The data used to update Loads.
     * 
    **/
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyInput>
    /**
     * Filter which Loads to update
     * 
    **/
    where?: LoadsWhereInput
  }


  /**
   * Loads upsert
   */
  export type LoadsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
    /**
     * The filter to search for the Loads to update in case it exists.
     * 
    **/
    where: LoadsWhereUniqueInput
    /**
     * In case the Loads found by the `where` argument doesn't exist, create a new Loads with this data.
     * 
    **/
    create: XOR<LoadsCreateInput, LoadsUncheckedCreateInput>
    /**
     * In case the Loads was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LoadsUpdateInput, LoadsUncheckedUpdateInput>
  }


  /**
   * Loads delete
   */
  export type LoadsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
    /**
     * Filter which Loads to delete.
     * 
    **/
    where: LoadsWhereUniqueInput
  }


  /**
   * Loads deleteMany
   */
  export type LoadsDeleteManyArgs = {
    /**
     * Filter which Loads to delete
     * 
    **/
    where?: LoadsWhereInput
  }


  /**
   * Loads: findUniqueOrThrow
   */
  export type LoadsFindUniqueOrThrowArgs = LoadsFindUniqueArgsBase
      

  /**
   * Loads: findFirstOrThrow
   */
  export type LoadsFindFirstOrThrowArgs = LoadsFindFirstArgsBase
      

  /**
   * Loads without action
   */
  export type LoadsArgs = {
    /**
     * Select specific fields to fetch from the Loads
     * 
    **/
    select?: LoadsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoadsInclude | null
  }



  /**
   * Model CustomerDeliveryLocations
   */


  export type AggregateCustomerDeliveryLocations = {
    _count: CustomerDeliveryLocationsCountAggregateOutputType | null
    _avg: CustomerDeliveryLocationsAvgAggregateOutputType | null
    _sum: CustomerDeliveryLocationsSumAggregateOutputType | null
    _min: CustomerDeliveryLocationsMinAggregateOutputType | null
    _max: CustomerDeliveryLocationsMaxAggregateOutputType | null
  }

  export type CustomerDeliveryLocationsAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
  }

  export type CustomerDeliveryLocationsSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
  }

  export type CustomerDeliveryLocationsMinAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
    DateUsed: Date | null
  }

  export type CustomerDeliveryLocationsMaxAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    DeliveryLocationID: number | null
    DateUsed: Date | null
  }

  export type CustomerDeliveryLocationsCountAggregateOutputType = {
    ID: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: number
    _all: number
  }


  export type CustomerDeliveryLocationsAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
  }

  export type CustomerDeliveryLocationsSumAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
  }

  export type CustomerDeliveryLocationsMinAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
    DateUsed?: true
  }

  export type CustomerDeliveryLocationsMaxAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
    DateUsed?: true
  }

  export type CustomerDeliveryLocationsCountAggregateInputType = {
    ID?: true
    CustomerID?: true
    DeliveryLocationID?: true
    DateUsed?: true
    _all?: true
  }

  export type CustomerDeliveryLocationsAggregateArgs = {
    /**
     * Filter which CustomerDeliveryLocations to aggregate.
     * 
    **/
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDeliveryLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerDeliveryLocationsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDeliveryLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDeliveryLocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerDeliveryLocations
    **/
    _count?: true | CustomerDeliveryLocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerDeliveryLocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerDeliveryLocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerDeliveryLocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerDeliveryLocationsMaxAggregateInputType
  }

  export type GetCustomerDeliveryLocationsAggregateType<T extends CustomerDeliveryLocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerDeliveryLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerDeliveryLocations[P]>
      : GetScalarType<T[P], AggregateCustomerDeliveryLocations[P]>
  }




  export type CustomerDeliveryLocationsGroupByArgs = {
    where?: CustomerDeliveryLocationsWhereInput
    orderBy?: Enumerable<CustomerDeliveryLocationsOrderByWithAggregationInput>
    by: Array<CustomerDeliveryLocationsScalarFieldEnum>
    having?: CustomerDeliveryLocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerDeliveryLocationsCountAggregateInputType | true
    _avg?: CustomerDeliveryLocationsAvgAggregateInputType
    _sum?: CustomerDeliveryLocationsSumAggregateInputType
    _min?: CustomerDeliveryLocationsMinAggregateInputType
    _max?: CustomerDeliveryLocationsMaxAggregateInputType
  }


  export type CustomerDeliveryLocationsGroupByOutputType = {
    ID: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: Date
    _count: CustomerDeliveryLocationsCountAggregateOutputType | null
    _avg: CustomerDeliveryLocationsAvgAggregateOutputType | null
    _sum: CustomerDeliveryLocationsSumAggregateOutputType | null
    _min: CustomerDeliveryLocationsMinAggregateOutputType | null
    _max: CustomerDeliveryLocationsMaxAggregateOutputType | null
  }

  type GetCustomerDeliveryLocationsGroupByPayload<T extends CustomerDeliveryLocationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerDeliveryLocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerDeliveryLocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerDeliveryLocationsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerDeliveryLocationsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerDeliveryLocationsSelect = {
    ID?: boolean
    CustomerID?: boolean
    DeliveryLocationID?: boolean
    DateUsed?: boolean
    Customers?: boolean | CustomersArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
  }

  export type CustomerDeliveryLocationsInclude = {
    Customers?: boolean | CustomersArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
  }

  export type CustomerDeliveryLocationsGetPayload<
    S extends boolean | null | undefined | CustomerDeliveryLocationsArgs,
    U = keyof S
      > = S extends true
        ? CustomerDeliveryLocations
    : S extends undefined
    ? never
    : S extends CustomerDeliveryLocationsArgs | CustomerDeliveryLocationsFindManyArgs
    ?'include' extends U
    ? CustomerDeliveryLocations  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? CustomersGetPayload<S['include'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? CustomersGetPayload<S['select'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['select'][P]> :  P extends keyof CustomerDeliveryLocations ? CustomerDeliveryLocations[P] : never
  } 
    : CustomerDeliveryLocations
  : CustomerDeliveryLocations


  type CustomerDeliveryLocationsCountArgs = Merge<
    Omit<CustomerDeliveryLocationsFindManyArgs, 'select' | 'include'> & {
      select?: CustomerDeliveryLocationsCountAggregateInputType | true
    }
  >

  export interface CustomerDeliveryLocationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CustomerDeliveryLocations that matches the filter.
     * @param {CustomerDeliveryLocationsFindUniqueArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerDeliveryLocationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerDeliveryLocationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerDeliveryLocations'> extends True ? CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>> : CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations | null >, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T> | null >>

    /**
     * Find the first CustomerDeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsFindFirstArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerDeliveryLocationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerDeliveryLocationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerDeliveryLocations'> extends True ? CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>> : CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations | null >, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T> | null >>

    /**
     * Find zero or more CustomerDeliveryLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findMany()
     * 
     * // Get first 10 CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const customerDeliveryLocationsWithIDOnly = await prisma.customerDeliveryLocations.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends CustomerDeliveryLocationsFindManyArgs>(
      args?: SelectSubset<T, CustomerDeliveryLocationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CustomerDeliveryLocations>>, PrismaPromise<Array<CustomerDeliveryLocationsGetPayload<T>>>>

    /**
     * Create a CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsCreateArgs} args - Arguments to create a CustomerDeliveryLocations.
     * @example
     * // Create one CustomerDeliveryLocations
     * const CustomerDeliveryLocations = await prisma.customerDeliveryLocations.create({
     *   data: {
     *     // ... data to create a CustomerDeliveryLocations
     *   }
     * })
     * 
    **/
    create<T extends CustomerDeliveryLocationsCreateArgs>(
      args: SelectSubset<T, CustomerDeliveryLocationsCreateArgs>
    ): CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>>

    /**
     * Create many CustomerDeliveryLocations.
     *     @param {CustomerDeliveryLocationsCreateManyArgs} args - Arguments to create many CustomerDeliveryLocations.
     *     @example
     *     // Create many CustomerDeliveryLocations
     *     const customerDeliveryLocations = await prisma.customerDeliveryLocations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerDeliveryLocationsCreateManyArgs>(
      args?: SelectSubset<T, CustomerDeliveryLocationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsDeleteArgs} args - Arguments to delete one CustomerDeliveryLocations.
     * @example
     * // Delete one CustomerDeliveryLocations
     * const CustomerDeliveryLocations = await prisma.customerDeliveryLocations.delete({
     *   where: {
     *     // ... filter to delete one CustomerDeliveryLocations
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeliveryLocationsDeleteArgs>(
      args: SelectSubset<T, CustomerDeliveryLocationsDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>>

    /**
     * Update one CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsUpdateArgs} args - Arguments to update one CustomerDeliveryLocations.
     * @example
     * // Update one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerDeliveryLocationsUpdateArgs>(
      args: SelectSubset<T, CustomerDeliveryLocationsUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>>

    /**
     * Delete zero or more CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsDeleteManyArgs} args - Arguments to filter CustomerDeliveryLocations to delete.
     * @example
     * // Delete a few CustomerDeliveryLocations
     * const { count } = await prisma.customerDeliveryLocations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeliveryLocationsDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeliveryLocationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerDeliveryLocationsUpdateManyArgs>(
      args: SelectSubset<T, CustomerDeliveryLocationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerDeliveryLocations.
     * @param {CustomerDeliveryLocationsUpsertArgs} args - Arguments to update or create a CustomerDeliveryLocations.
     * @example
     * // Update or create a CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.upsert({
     *   create: {
     *     // ... data to create a CustomerDeliveryLocations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerDeliveryLocations we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerDeliveryLocationsUpsertArgs>(
      args: SelectSubset<T, CustomerDeliveryLocationsUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>>

    /**
     * Find one CustomerDeliveryLocations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CustomerDeliveryLocationsFindUniqueOrThrowArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerDeliveryLocationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerDeliveryLocationsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>>

    /**
     * Find the first CustomerDeliveryLocations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsFindFirstOrThrowArgs} args - Arguments to find a CustomerDeliveryLocations
     * @example
     * // Get one CustomerDeliveryLocations
     * const customerDeliveryLocations = await prisma.customerDeliveryLocations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerDeliveryLocationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerDeliveryLocationsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocations>, Prisma__CustomerDeliveryLocationsClient<CustomerDeliveryLocationsGetPayload<T>>>

    /**
     * Count the number of CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsCountArgs} args - Arguments to filter CustomerDeliveryLocations to count.
     * @example
     * // Count the number of CustomerDeliveryLocations
     * const count = await prisma.customerDeliveryLocations.count({
     *   where: {
     *     // ... the filter for the CustomerDeliveryLocations we want to count
     *   }
     * })
    **/
    count<T extends CustomerDeliveryLocationsCountArgs>(
      args?: Subset<T, CustomerDeliveryLocationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerDeliveryLocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerDeliveryLocationsAggregateArgs>(args: Subset<T, CustomerDeliveryLocationsAggregateArgs>): PrismaPromise<GetCustomerDeliveryLocationsAggregateType<T>>

    /**
     * Group by CustomerDeliveryLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeliveryLocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerDeliveryLocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerDeliveryLocationsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerDeliveryLocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerDeliveryLocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerDeliveryLocationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerDeliveryLocations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerDeliveryLocationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    DeliveryLocations<T extends DeliveryLocationsArgs = {}>(args?: Subset<T, DeliveryLocationsArgs>): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations | null >, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerDeliveryLocations base type for findUnique actions
   */
  export type CustomerDeliveryLocationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     * 
    **/
    where: CustomerDeliveryLocationsWhereUniqueInput
  }

  /**
   * CustomerDeliveryLocations: findUnique
   */
  export interface CustomerDeliveryLocationsFindUniqueArgs extends CustomerDeliveryLocationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerDeliveryLocations base type for findFirst actions
   */
  export type CustomerDeliveryLocationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     * 
    **/
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDeliveryLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerDeliveryLocationsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDeliveryLocations.
     * 
    **/
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDeliveryLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDeliveryLocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDeliveryLocations.
     * 
    **/
    distinct?: Enumerable<CustomerDeliveryLocationsScalarFieldEnum>
  }

  /**
   * CustomerDeliveryLocations: findFirst
   */
  export interface CustomerDeliveryLocationsFindFirstArgs extends CustomerDeliveryLocationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerDeliveryLocations findMany
   */
  export type CustomerDeliveryLocationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
    /**
     * Filter, which CustomerDeliveryLocations to fetch.
     * 
    **/
    where?: CustomerDeliveryLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDeliveryLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerDeliveryLocationsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerDeliveryLocations.
     * 
    **/
    cursor?: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDeliveryLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDeliveryLocations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerDeliveryLocationsScalarFieldEnum>
  }


  /**
   * CustomerDeliveryLocations create
   */
  export type CustomerDeliveryLocationsCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
    /**
     * The data needed to create a CustomerDeliveryLocations.
     * 
    **/
    data: XOR<CustomerDeliveryLocationsCreateInput, CustomerDeliveryLocationsUncheckedCreateInput>
  }


  /**
   * CustomerDeliveryLocations createMany
   */
  export type CustomerDeliveryLocationsCreateManyArgs = {
    /**
     * The data used to create many CustomerDeliveryLocations.
     * 
    **/
    data: Enumerable<CustomerDeliveryLocationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerDeliveryLocations update
   */
  export type CustomerDeliveryLocationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
    /**
     * The data needed to update a CustomerDeliveryLocations.
     * 
    **/
    data: XOR<CustomerDeliveryLocationsUpdateInput, CustomerDeliveryLocationsUncheckedUpdateInput>
    /**
     * Choose, which CustomerDeliveryLocations to update.
     * 
    **/
    where: CustomerDeliveryLocationsWhereUniqueInput
  }


  /**
   * CustomerDeliveryLocations updateMany
   */
  export type CustomerDeliveryLocationsUpdateManyArgs = {
    /**
     * The data used to update CustomerDeliveryLocations.
     * 
    **/
    data: XOR<CustomerDeliveryLocationsUpdateManyMutationInput, CustomerDeliveryLocationsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDeliveryLocations to update
     * 
    **/
    where?: CustomerDeliveryLocationsWhereInput
  }


  /**
   * CustomerDeliveryLocations upsert
   */
  export type CustomerDeliveryLocationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
    /**
     * The filter to search for the CustomerDeliveryLocations to update in case it exists.
     * 
    **/
    where: CustomerDeliveryLocationsWhereUniqueInput
    /**
     * In case the CustomerDeliveryLocations found by the `where` argument doesn't exist, create a new CustomerDeliveryLocations with this data.
     * 
    **/
    create: XOR<CustomerDeliveryLocationsCreateInput, CustomerDeliveryLocationsUncheckedCreateInput>
    /**
     * In case the CustomerDeliveryLocations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerDeliveryLocationsUpdateInput, CustomerDeliveryLocationsUncheckedUpdateInput>
  }


  /**
   * CustomerDeliveryLocations delete
   */
  export type CustomerDeliveryLocationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
    /**
     * Filter which CustomerDeliveryLocations to delete.
     * 
    **/
    where: CustomerDeliveryLocationsWhereUniqueInput
  }


  /**
   * CustomerDeliveryLocations deleteMany
   */
  export type CustomerDeliveryLocationsDeleteManyArgs = {
    /**
     * Filter which CustomerDeliveryLocations to delete
     * 
    **/
    where?: CustomerDeliveryLocationsWhereInput
  }


  /**
   * CustomerDeliveryLocations: findUniqueOrThrow
   */
  export type CustomerDeliveryLocationsFindUniqueOrThrowArgs = CustomerDeliveryLocationsFindUniqueArgsBase
      

  /**
   * CustomerDeliveryLocations: findFirstOrThrow
   */
  export type CustomerDeliveryLocationsFindFirstOrThrowArgs = CustomerDeliveryLocationsFindFirstArgsBase
      

  /**
   * CustomerDeliveryLocations without action
   */
  export type CustomerDeliveryLocationsArgs = {
    /**
     * Select specific fields to fetch from the CustomerDeliveryLocations
     * 
    **/
    select?: CustomerDeliveryLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerDeliveryLocationsInclude | null
  }



  /**
   * Model Dailies
   */


  export type AggregateDailies = {
    _count: DailiesCountAggregateOutputType | null
    _avg: DailiesAvgAggregateOutputType | null
    _sum: DailiesSumAggregateOutputType | null
    _min: DailiesMinAggregateOutputType | null
    _max: DailiesMaxAggregateOutputType | null
  }

  export type DailiesAvgAggregateOutputType = {
    ID: number | null
    DriverID: number | null
  }

  export type DailiesSumAggregateOutputType = {
    ID: number | null
    DriverID: number | null
  }

  export type DailiesMinAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Week: string | null
    LastPrinted: Date | null
  }

  export type DailiesMaxAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Week: string | null
    LastPrinted: Date | null
  }

  export type DailiesCountAggregateOutputType = {
    ID: number
    DriverID: number
    Week: number
    LastPrinted: number
    _all: number
  }


  export type DailiesAvgAggregateInputType = {
    ID?: true
    DriverID?: true
  }

  export type DailiesSumAggregateInputType = {
    ID?: true
    DriverID?: true
  }

  export type DailiesMinAggregateInputType = {
    ID?: true
    DriverID?: true
    Week?: true
    LastPrinted?: true
  }

  export type DailiesMaxAggregateInputType = {
    ID?: true
    DriverID?: true
    Week?: true
    LastPrinted?: true
  }

  export type DailiesCountAggregateInputType = {
    ID?: true
    DriverID?: true
    Week?: true
    LastPrinted?: true
    _all?: true
  }

  export type DailiesAggregateArgs = {
    /**
     * Filter which Dailies to aggregate.
     * 
    **/
    where?: DailiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dailies to fetch.
     * 
    **/
    orderBy?: Enumerable<DailiesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DailiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dailies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dailies
    **/
    _count?: true | DailiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailiesMaxAggregateInputType
  }

  export type GetDailiesAggregateType<T extends DailiesAggregateArgs> = {
        [P in keyof T & keyof AggregateDailies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailies[P]>
      : GetScalarType<T[P], AggregateDailies[P]>
  }




  export type DailiesGroupByArgs = {
    where?: DailiesWhereInput
    orderBy?: Enumerable<DailiesOrderByWithAggregationInput>
    by: Array<DailiesScalarFieldEnum>
    having?: DailiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailiesCountAggregateInputType | true
    _avg?: DailiesAvgAggregateInputType
    _sum?: DailiesSumAggregateInputType
    _min?: DailiesMinAggregateInputType
    _max?: DailiesMaxAggregateInputType
  }


  export type DailiesGroupByOutputType = {
    ID: number
    DriverID: number
    Week: string
    LastPrinted: Date | null
    _count: DailiesCountAggregateOutputType | null
    _avg: DailiesAvgAggregateOutputType | null
    _sum: DailiesSumAggregateOutputType | null
    _min: DailiesMinAggregateOutputType | null
    _max: DailiesMaxAggregateOutputType | null
  }

  type GetDailiesGroupByPayload<T extends DailiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DailiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailiesGroupByOutputType[P]>
            : GetScalarType<T[P], DailiesGroupByOutputType[P]>
        }
      >
    >


  export type DailiesSelect = {
    ID?: boolean
    DriverID?: boolean
    Week?: boolean
    LastPrinted?: boolean
    Drivers?: boolean | DriversArgs
    Jobs?: boolean | JobsFindManyArgs
    _count?: boolean | DailiesCountOutputTypeArgs
  }

  export type DailiesInclude = {
    Drivers?: boolean | DriversArgs
    Jobs?: boolean | JobsFindManyArgs
    _count?: boolean | DailiesCountOutputTypeArgs
  }

  export type DailiesGetPayload<
    S extends boolean | null | undefined | DailiesArgs,
    U = keyof S
      > = S extends true
        ? Dailies
    : S extends undefined
    ? never
    : S extends DailiesArgs | DailiesFindManyArgs
    ?'include' extends U
    ? Dailies  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Drivers' ? DriversGetPayload<S['include'][P]> :
        P extends 'Jobs' ? Array < JobsGetPayload<S['include'][P]>>  :
        P extends '_count' ? DailiesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Drivers' ? DriversGetPayload<S['select'][P]> :
        P extends 'Jobs' ? Array < JobsGetPayload<S['select'][P]>>  :
        P extends '_count' ? DailiesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Dailies ? Dailies[P] : never
  } 
    : Dailies
  : Dailies


  type DailiesCountArgs = Merge<
    Omit<DailiesFindManyArgs, 'select' | 'include'> & {
      select?: DailiesCountAggregateInputType | true
    }
  >

  export interface DailiesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Dailies that matches the filter.
     * @param {DailiesFindUniqueArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dailies'> extends True ? CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>> : CheckSelect<T, Prisma__DailiesClient<Dailies | null >, Prisma__DailiesClient<DailiesGetPayload<T> | null >>

    /**
     * Find the first Dailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesFindFirstArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dailies'> extends True ? CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>> : CheckSelect<T, Prisma__DailiesClient<Dailies | null >, Prisma__DailiesClient<DailiesGetPayload<T> | null >>

    /**
     * Find zero or more Dailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dailies
     * const dailies = await prisma.dailies.findMany()
     * 
     * // Get first 10 Dailies
     * const dailies = await prisma.dailies.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const dailiesWithIDOnly = await prisma.dailies.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends DailiesFindManyArgs>(
      args?: SelectSubset<T, DailiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Dailies>>, PrismaPromise<Array<DailiesGetPayload<T>>>>

    /**
     * Create a Dailies.
     * @param {DailiesCreateArgs} args - Arguments to create a Dailies.
     * @example
     * // Create one Dailies
     * const Dailies = await prisma.dailies.create({
     *   data: {
     *     // ... data to create a Dailies
     *   }
     * })
     * 
    **/
    create<T extends DailiesCreateArgs>(
      args: SelectSubset<T, DailiesCreateArgs>
    ): CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>>

    /**
     * Create many Dailies.
     *     @param {DailiesCreateManyArgs} args - Arguments to create many Dailies.
     *     @example
     *     // Create many Dailies
     *     const dailies = await prisma.dailies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailiesCreateManyArgs>(
      args?: SelectSubset<T, DailiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Dailies.
     * @param {DailiesDeleteArgs} args - Arguments to delete one Dailies.
     * @example
     * // Delete one Dailies
     * const Dailies = await prisma.dailies.delete({
     *   where: {
     *     // ... filter to delete one Dailies
     *   }
     * })
     * 
    **/
    delete<T extends DailiesDeleteArgs>(
      args: SelectSubset<T, DailiesDeleteArgs>
    ): CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>>

    /**
     * Update one Dailies.
     * @param {DailiesUpdateArgs} args - Arguments to update one Dailies.
     * @example
     * // Update one Dailies
     * const dailies = await prisma.dailies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailiesUpdateArgs>(
      args: SelectSubset<T, DailiesUpdateArgs>
    ): CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>>

    /**
     * Delete zero or more Dailies.
     * @param {DailiesDeleteManyArgs} args - Arguments to filter Dailies to delete.
     * @example
     * // Delete a few Dailies
     * const { count } = await prisma.dailies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailiesDeleteManyArgs>(
      args?: SelectSubset<T, DailiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dailies
     * const dailies = await prisma.dailies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailiesUpdateManyArgs>(
      args: SelectSubset<T, DailiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Dailies.
     * @param {DailiesUpsertArgs} args - Arguments to update or create a Dailies.
     * @example
     * // Update or create a Dailies
     * const dailies = await prisma.dailies.upsert({
     *   create: {
     *     // ... data to create a Dailies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dailies we want to update
     *   }
     * })
    **/
    upsert<T extends DailiesUpsertArgs>(
      args: SelectSubset<T, DailiesUpsertArgs>
    ): CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>>

    /**
     * Find one Dailies that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DailiesFindUniqueOrThrowArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DailiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DailiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>>

    /**
     * Find the first Dailies that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesFindFirstOrThrowArgs} args - Arguments to find a Dailies
     * @example
     * // Get one Dailies
     * const dailies = await prisma.dailies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DailiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DailiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DailiesClient<Dailies>, Prisma__DailiesClient<DailiesGetPayload<T>>>

    /**
     * Count the number of Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesCountArgs} args - Arguments to filter Dailies to count.
     * @example
     * // Count the number of Dailies
     * const count = await prisma.dailies.count({
     *   where: {
     *     // ... the filter for the Dailies we want to count
     *   }
     * })
    **/
    count<T extends DailiesCountArgs>(
      args?: Subset<T, DailiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailiesAggregateArgs>(args: Subset<T, DailiesAggregateArgs>): PrismaPromise<GetDailiesAggregateType<T>>

    /**
     * Group by Dailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailiesGroupByArgs['orderBy'] }
        : { orderBy?: DailiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Dailies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailiesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Drivers<T extends DriversArgs = {}>(args?: Subset<T, DriversArgs>): CheckSelect<T, Prisma__DriversClient<Drivers | null >, Prisma__DriversClient<DriversGetPayload<T> | null >>;

    Jobs<T extends JobsFindManyArgs = {}>(args?: Subset<T, JobsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Dailies base type for findUnique actions
   */
  export type DailiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
    /**
     * Filter, which Dailies to fetch.
     * 
    **/
    where: DailiesWhereUniqueInput
  }

  /**
   * Dailies: findUnique
   */
  export interface DailiesFindUniqueArgs extends DailiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dailies base type for findFirst actions
   */
  export type DailiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
    /**
     * Filter, which Dailies to fetch.
     * 
    **/
    where?: DailiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dailies to fetch.
     * 
    **/
    orderBy?: Enumerable<DailiesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dailies.
     * 
    **/
    cursor?: DailiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dailies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dailies.
     * 
    **/
    distinct?: Enumerable<DailiesScalarFieldEnum>
  }

  /**
   * Dailies: findFirst
   */
  export interface DailiesFindFirstArgs extends DailiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dailies findMany
   */
  export type DailiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
    /**
     * Filter, which Dailies to fetch.
     * 
    **/
    where?: DailiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dailies to fetch.
     * 
    **/
    orderBy?: Enumerable<DailiesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dailies.
     * 
    **/
    cursor?: DailiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dailies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DailiesScalarFieldEnum>
  }


  /**
   * Dailies create
   */
  export type DailiesCreateArgs = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
    /**
     * The data needed to create a Dailies.
     * 
    **/
    data: XOR<DailiesCreateInput, DailiesUncheckedCreateInput>
  }


  /**
   * Dailies createMany
   */
  export type DailiesCreateManyArgs = {
    /**
     * The data used to create many Dailies.
     * 
    **/
    data: Enumerable<DailiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Dailies update
   */
  export type DailiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
    /**
     * The data needed to update a Dailies.
     * 
    **/
    data: XOR<DailiesUpdateInput, DailiesUncheckedUpdateInput>
    /**
     * Choose, which Dailies to update.
     * 
    **/
    where: DailiesWhereUniqueInput
  }


  /**
   * Dailies updateMany
   */
  export type DailiesUpdateManyArgs = {
    /**
     * The data used to update Dailies.
     * 
    **/
    data: XOR<DailiesUpdateManyMutationInput, DailiesUncheckedUpdateManyInput>
    /**
     * Filter which Dailies to update
     * 
    **/
    where?: DailiesWhereInput
  }


  /**
   * Dailies upsert
   */
  export type DailiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
    /**
     * The filter to search for the Dailies to update in case it exists.
     * 
    **/
    where: DailiesWhereUniqueInput
    /**
     * In case the Dailies found by the `where` argument doesn't exist, create a new Dailies with this data.
     * 
    **/
    create: XOR<DailiesCreateInput, DailiesUncheckedCreateInput>
    /**
     * In case the Dailies was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DailiesUpdateInput, DailiesUncheckedUpdateInput>
  }


  /**
   * Dailies delete
   */
  export type DailiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
    /**
     * Filter which Dailies to delete.
     * 
    **/
    where: DailiesWhereUniqueInput
  }


  /**
   * Dailies deleteMany
   */
  export type DailiesDeleteManyArgs = {
    /**
     * Filter which Dailies to delete
     * 
    **/
    where?: DailiesWhereInput
  }


  /**
   * Dailies: findUniqueOrThrow
   */
  export type DailiesFindUniqueOrThrowArgs = DailiesFindUniqueArgsBase
      

  /**
   * Dailies: findFirstOrThrow
   */
  export type DailiesFindFirstOrThrowArgs = DailiesFindFirstArgsBase
      

  /**
   * Dailies without action
   */
  export type DailiesArgs = {
    /**
     * Select specific fields to fetch from the Dailies
     * 
    **/
    select?: DailiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailiesInclude | null
  }



  /**
   * Model Jobs
   */


  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsSumAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsMinAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    PaidOut: boolean | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsMaxAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    LoadTypeID: number | null
    CustomerID: number | null
    PaidOut: boolean | null
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number | null
    CompanyRate: number | null
    DeliveryLocationID: number | null
    WeeklyID: number | null
    DailyID: number | null
    MaterialRate: number | null
    DriverRate: number | null
    PayStubID: number | null
  }

  export type JobsCountAggregateOutputType = {
    ID: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut: number
    TruckingRevenue: number
    CompanyRevenue: number
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsSumAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsMinAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    PaidOut?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsMaxAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    PaidOut?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
  }

  export type JobsCountAggregateInputType = {
    ID?: true
    DriverID?: true
    LoadTypeID?: true
    CustomerID?: true
    PaidOut?: true
    TruckingRevenue?: true
    CompanyRevenue?: true
    TruckingRate?: true
    CompanyRate?: true
    DeliveryLocationID?: true
    WeeklyID?: true
    DailyID?: true
    MaterialRate?: true
    DriverRate?: true
    PayStubID?: true
    _all?: true
  }

  export type JobsAggregateArgs = {
    /**
     * Filter which Jobs to aggregate.
     * 
    **/
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type JobsGroupByArgs = {
    where?: JobsWhereInput
    orderBy?: Enumerable<JobsOrderByWithAggregationInput>
    by: Array<JobsScalarFieldEnum>
    having?: JobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }


  export type JobsGroupByOutputType = {
    ID: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut: boolean
    TruckingRevenue: number | null
    CompanyRevenue: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID: number | null
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type JobsSelect = {
    ID?: boolean
    DriverID?: boolean
    LoadTypeID?: boolean
    CustomerID?: boolean
    PaidOut?: boolean
    TruckingRevenue?: boolean
    CompanyRevenue?: boolean
    TruckingRate?: boolean
    CompanyRate?: boolean
    DeliveryLocationID?: boolean
    WeeklyID?: boolean
    DailyID?: boolean
    MaterialRate?: boolean
    DriverRate?: boolean
    PayStubID?: boolean
    Customers?: boolean | CustomersArgs
    Dailies?: boolean | DailiesArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
    Drivers?: boolean | DriversArgs
    LoadTypes?: boolean | LoadTypesArgs
    PayStubs?: boolean | PayStubsArgs
    Weeklies?: boolean | WeekliesArgs
    Loads?: boolean | LoadsFindManyArgs
    _count?: boolean | JobsCountOutputTypeArgs
  }

  export type JobsInclude = {
    Customers?: boolean | CustomersArgs
    Dailies?: boolean | DailiesArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
    Drivers?: boolean | DriversArgs
    LoadTypes?: boolean | LoadTypesArgs
    PayStubs?: boolean | PayStubsArgs
    Weeklies?: boolean | WeekliesArgs
    Loads?: boolean | LoadsFindManyArgs
    _count?: boolean | JobsCountOutputTypeArgs
  }

  export type JobsGetPayload<
    S extends boolean | null | undefined | JobsArgs,
    U = keyof S
      > = S extends true
        ? Jobs
    : S extends undefined
    ? never
    : S extends JobsArgs | JobsFindManyArgs
    ?'include' extends U
    ? Jobs  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? CustomersGetPayload<S['include'][P]> :
        P extends 'Dailies' ? DailiesGetPayload<S['include'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['include'][P]> :
        P extends 'Drivers' ? DriversGetPayload<S['include'][P]> :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['include'][P]> :
        P extends 'PayStubs' ? PayStubsGetPayload<S['include'][P]> | null :
        P extends 'Weeklies' ? WeekliesGetPayload<S['include'][P]> :
        P extends 'Loads' ? Array < LoadsGetPayload<S['include'][P]>>  :
        P extends '_count' ? JobsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? CustomersGetPayload<S['select'][P]> :
        P extends 'Dailies' ? DailiesGetPayload<S['select'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['select'][P]> :
        P extends 'Drivers' ? DriversGetPayload<S['select'][P]> :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['select'][P]> :
        P extends 'PayStubs' ? PayStubsGetPayload<S['select'][P]> | null :
        P extends 'Weeklies' ? WeekliesGetPayload<S['select'][P]> :
        P extends 'Loads' ? Array < LoadsGetPayload<S['select'][P]>>  :
        P extends '_count' ? JobsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Jobs ? Jobs[P] : never
  } 
    : Jobs
  : Jobs


  type JobsCountArgs = Merge<
    Omit<JobsFindManyArgs, 'select' | 'include'> & {
      select?: JobsCountAggregateInputType | true
    }
  >

  export interface JobsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Jobs'> extends True ? CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>> : CheckSelect<T, Prisma__JobsClient<Jobs | null >, Prisma__JobsClient<JobsGetPayload<T> | null >>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Jobs'> extends True ? CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>> : CheckSelect<T, Prisma__JobsClient<Jobs | null >, Prisma__JobsClient<JobsGetPayload<T> | null >>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const jobsWithIDOnly = await prisma.jobs.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends JobsFindManyArgs>(
      args?: SelectSubset<T, JobsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
    **/
    create<T extends JobsCreateArgs>(
      args: SelectSubset<T, JobsCreateArgs>
    ): CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>>

    /**
     * Create many Jobs.
     *     @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     *     @example
     *     // Create many Jobs
     *     const jobs = await prisma.jobs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobsCreateManyArgs>(
      args?: SelectSubset<T, JobsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
    **/
    delete<T extends JobsDeleteArgs>(
      args: SelectSubset<T, JobsDeleteArgs>
    ): CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>>

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobsUpdateArgs>(
      args: SelectSubset<T, JobsUpdateArgs>
    ): CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>>

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobsDeleteManyArgs>(
      args?: SelectSubset<T, JobsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobsUpdateManyArgs>(
      args: SelectSubset<T, JobsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
    **/
    upsert<T extends JobsUpsertArgs>(
      args: SelectSubset<T, JobsUpsertArgs>
    ): CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>>

    /**
     * Find one Jobs that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>>

    /**
     * Find the first Jobs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__JobsClient<Jobs>, Prisma__JobsClient<JobsGetPayload<T>>>

    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs['orderBy'] }
        : { orderBy?: JobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    Dailies<T extends DailiesArgs = {}>(args?: Subset<T, DailiesArgs>): CheckSelect<T, Prisma__DailiesClient<Dailies | null >, Prisma__DailiesClient<DailiesGetPayload<T> | null >>;

    DeliveryLocations<T extends DeliveryLocationsArgs = {}>(args?: Subset<T, DeliveryLocationsArgs>): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations | null >, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T> | null >>;

    Drivers<T extends DriversArgs = {}>(args?: Subset<T, DriversArgs>): CheckSelect<T, Prisma__DriversClient<Drivers | null >, Prisma__DriversClient<DriversGetPayload<T> | null >>;

    LoadTypes<T extends LoadTypesArgs = {}>(args?: Subset<T, LoadTypesArgs>): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes | null >, Prisma__LoadTypesClient<LoadTypesGetPayload<T> | null >>;

    PayStubs<T extends PayStubsArgs = {}>(args?: Subset<T, PayStubsArgs>): CheckSelect<T, Prisma__PayStubsClient<PayStubs | null >, Prisma__PayStubsClient<PayStubsGetPayload<T> | null >>;

    Weeklies<T extends WeekliesArgs = {}>(args?: Subset<T, WeekliesArgs>): CheckSelect<T, Prisma__WeekliesClient<Weeklies | null >, Prisma__WeekliesClient<WeekliesGetPayload<T> | null >>;

    Loads<T extends LoadsFindManyArgs = {}>(args?: Subset<T, LoadsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Loads>>, PrismaPromise<Array<LoadsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Jobs base type for findUnique actions
   */
  export type JobsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
    /**
     * Filter, which Jobs to fetch.
     * 
    **/
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs: findUnique
   */
  export interface JobsFindUniqueArgs extends JobsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Jobs base type for findFirst actions
   */
  export type JobsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
    /**
     * Filter, which Jobs to fetch.
     * 
    **/
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     * 
    **/
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     * 
    **/
    distinct?: Enumerable<JobsScalarFieldEnum>
  }

  /**
   * Jobs: findFirst
   */
  export interface JobsFindFirstArgs extends JobsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
    /**
     * Filter, which Jobs to fetch.
     * 
    **/
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     * 
    **/
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobsScalarFieldEnum>
  }


  /**
   * Jobs create
   */
  export type JobsCreateArgs = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
    /**
     * The data needed to create a Jobs.
     * 
    **/
    data: XOR<JobsCreateInput, JobsUncheckedCreateInput>
  }


  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs = {
    /**
     * The data used to create many Jobs.
     * 
    **/
    data: Enumerable<JobsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Jobs update
   */
  export type JobsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
    /**
     * The data needed to update a Jobs.
     * 
    **/
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
    /**
     * Choose, which Jobs to update.
     * 
    **/
    where: JobsWhereUniqueInput
  }


  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs = {
    /**
     * The data used to update Jobs.
     * 
    **/
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     * 
    **/
    where?: JobsWhereInput
  }


  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
    /**
     * The filter to search for the Jobs to update in case it exists.
     * 
    **/
    where: JobsWhereUniqueInput
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     * 
    **/
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
  }


  /**
   * Jobs delete
   */
  export type JobsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
    /**
     * Filter which Jobs to delete.
     * 
    **/
    where: JobsWhereUniqueInput
  }


  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs = {
    /**
     * Filter which Jobs to delete
     * 
    **/
    where?: JobsWhereInput
  }


  /**
   * Jobs: findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs = JobsFindUniqueArgsBase
      

  /**
   * Jobs: findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs = JobsFindFirstArgsBase
      

  /**
   * Jobs without action
   */
  export type JobsArgs = {
    /**
     * Select specific fields to fetch from the Jobs
     * 
    **/
    select?: JobsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobsInclude | null
  }



  /**
   * Model Weeklies
   */


  export type AggregateWeeklies = {
    _count: WeekliesCountAggregateOutputType | null
    _avg: WeekliesAvgAggregateOutputType | null
    _sum: WeekliesSumAggregateOutputType | null
    _min: WeekliesMinAggregateOutputType | null
    _max: WeekliesMaxAggregateOutputType | null
  }

  export type WeekliesAvgAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TotalWeight: number | null
  }

  export type WeekliesSumAggregateOutputType = {
    ID: number | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    TotalWeight: number | null
  }

  export type WeekliesMinAggregateOutputType = {
    ID: number | null
    Week: string | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    LastPrinted: Date | null
    TotalWeight: number | null
  }

  export type WeekliesMaxAggregateOutputType = {
    ID: number | null
    Week: string | null
    CustomerID: number | null
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number | null
    DeliveryLocationID: number | null
    LastPrinted: Date | null
    TotalWeight: number | null
  }

  export type WeekliesCountAggregateOutputType = {
    ID: number
    Week: number
    CustomerID: number
    InvoiceID: number
    CompanyRate: number
    Revenue: number
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted: number
    TotalWeight: number
    _all: number
  }


  export type WeekliesAvgAggregateInputType = {
    ID?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TotalWeight?: true
  }

  export type WeekliesSumAggregateInputType = {
    ID?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    TotalWeight?: true
  }

  export type WeekliesMinAggregateInputType = {
    ID?: true
    Week?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    LastPrinted?: true
    TotalWeight?: true
  }

  export type WeekliesMaxAggregateInputType = {
    ID?: true
    Week?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    LastPrinted?: true
    TotalWeight?: true
  }

  export type WeekliesCountAggregateInputType = {
    ID?: true
    Week?: true
    CustomerID?: true
    InvoiceID?: true
    CompanyRate?: true
    Revenue?: true
    LoadTypeID?: true
    DeliveryLocationID?: true
    LastPrinted?: true
    TotalWeight?: true
    _all?: true
  }

  export type WeekliesAggregateArgs = {
    /**
     * Filter which Weeklies to aggregate.
     * 
    **/
    where?: WeekliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeklies to fetch.
     * 
    **/
    orderBy?: Enumerable<WeekliesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WeekliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeklies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeklies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weeklies
    **/
    _count?: true | WeekliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeekliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeekliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeekliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeekliesMaxAggregateInputType
  }

  export type GetWeekliesAggregateType<T extends WeekliesAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklies[P]>
      : GetScalarType<T[P], AggregateWeeklies[P]>
  }




  export type WeekliesGroupByArgs = {
    where?: WeekliesWhereInput
    orderBy?: Enumerable<WeekliesOrderByWithAggregationInput>
    by: Array<WeekliesScalarFieldEnum>
    having?: WeekliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeekliesCountAggregateInputType | true
    _avg?: WeekliesAvgAggregateInputType
    _sum?: WeekliesSumAggregateInputType
    _min?: WeekliesMinAggregateInputType
    _max?: WeekliesMaxAggregateInputType
  }


  export type WeekliesGroupByOutputType = {
    ID: number
    Week: string
    CustomerID: number
    InvoiceID: number | null
    CompanyRate: number | null
    Revenue: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted: Date | null
    TotalWeight: number | null
    _count: WeekliesCountAggregateOutputType | null
    _avg: WeekliesAvgAggregateOutputType | null
    _sum: WeekliesSumAggregateOutputType | null
    _min: WeekliesMinAggregateOutputType | null
    _max: WeekliesMaxAggregateOutputType | null
  }

  type GetWeekliesGroupByPayload<T extends WeekliesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WeekliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeekliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeekliesGroupByOutputType[P]>
            : GetScalarType<T[P], WeekliesGroupByOutputType[P]>
        }
      >
    >


  export type WeekliesSelect = {
    ID?: boolean
    Week?: boolean
    CustomerID?: boolean
    InvoiceID?: boolean
    CompanyRate?: boolean
    Revenue?: boolean
    LoadTypeID?: boolean
    DeliveryLocationID?: boolean
    LastPrinted?: boolean
    TotalWeight?: boolean
    Customers?: boolean | CustomersArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
    Invoices?: boolean | InvoicesArgs
    LoadTypes?: boolean | LoadTypesArgs
    Jobs?: boolean | JobsFindManyArgs
    _count?: boolean | WeekliesCountOutputTypeArgs
  }

  export type WeekliesInclude = {
    Customers?: boolean | CustomersArgs
    DeliveryLocations?: boolean | DeliveryLocationsArgs
    Invoices?: boolean | InvoicesArgs
    LoadTypes?: boolean | LoadTypesArgs
    Jobs?: boolean | JobsFindManyArgs
    _count?: boolean | WeekliesCountOutputTypeArgs
  }

  export type WeekliesGetPayload<
    S extends boolean | null | undefined | WeekliesArgs,
    U = keyof S
      > = S extends true
        ? Weeklies
    : S extends undefined
    ? never
    : S extends WeekliesArgs | WeekliesFindManyArgs
    ?'include' extends U
    ? Weeklies  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Customers' ? CustomersGetPayload<S['include'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['include'][P]> :
        P extends 'Invoices' ? InvoicesGetPayload<S['include'][P]> | null :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['include'][P]> :
        P extends 'Jobs' ? Array < JobsGetPayload<S['include'][P]>>  :
        P extends '_count' ? WeekliesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Customers' ? CustomersGetPayload<S['select'][P]> :
        P extends 'DeliveryLocations' ? DeliveryLocationsGetPayload<S['select'][P]> :
        P extends 'Invoices' ? InvoicesGetPayload<S['select'][P]> | null :
        P extends 'LoadTypes' ? LoadTypesGetPayload<S['select'][P]> :
        P extends 'Jobs' ? Array < JobsGetPayload<S['select'][P]>>  :
        P extends '_count' ? WeekliesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Weeklies ? Weeklies[P] : never
  } 
    : Weeklies
  : Weeklies


  type WeekliesCountArgs = Merge<
    Omit<WeekliesFindManyArgs, 'select' | 'include'> & {
      select?: WeekliesCountAggregateInputType | true
    }
  >

  export interface WeekliesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weeklies that matches the filter.
     * @param {WeekliesFindUniqueArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WeekliesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WeekliesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Weeklies'> extends True ? CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>> : CheckSelect<T, Prisma__WeekliesClient<Weeklies | null >, Prisma__WeekliesClient<WeekliesGetPayload<T> | null >>

    /**
     * Find the first Weeklies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesFindFirstArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WeekliesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WeekliesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Weeklies'> extends True ? CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>> : CheckSelect<T, Prisma__WeekliesClient<Weeklies | null >, Prisma__WeekliesClient<WeekliesGetPayload<T> | null >>

    /**
     * Find zero or more Weeklies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weeklies
     * const weeklies = await prisma.weeklies.findMany()
     * 
     * // Get first 10 Weeklies
     * const weeklies = await prisma.weeklies.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const weekliesWithIDOnly = await prisma.weeklies.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends WeekliesFindManyArgs>(
      args?: SelectSubset<T, WeekliesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Weeklies>>, PrismaPromise<Array<WeekliesGetPayload<T>>>>

    /**
     * Create a Weeklies.
     * @param {WeekliesCreateArgs} args - Arguments to create a Weeklies.
     * @example
     * // Create one Weeklies
     * const Weeklies = await prisma.weeklies.create({
     *   data: {
     *     // ... data to create a Weeklies
     *   }
     * })
     * 
    **/
    create<T extends WeekliesCreateArgs>(
      args: SelectSubset<T, WeekliesCreateArgs>
    ): CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>>

    /**
     * Create many Weeklies.
     *     @param {WeekliesCreateManyArgs} args - Arguments to create many Weeklies.
     *     @example
     *     // Create many Weeklies
     *     const weeklies = await prisma.weeklies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WeekliesCreateManyArgs>(
      args?: SelectSubset<T, WeekliesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weeklies.
     * @param {WeekliesDeleteArgs} args - Arguments to delete one Weeklies.
     * @example
     * // Delete one Weeklies
     * const Weeklies = await prisma.weeklies.delete({
     *   where: {
     *     // ... filter to delete one Weeklies
     *   }
     * })
     * 
    **/
    delete<T extends WeekliesDeleteArgs>(
      args: SelectSubset<T, WeekliesDeleteArgs>
    ): CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>>

    /**
     * Update one Weeklies.
     * @param {WeekliesUpdateArgs} args - Arguments to update one Weeklies.
     * @example
     * // Update one Weeklies
     * const weeklies = await prisma.weeklies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WeekliesUpdateArgs>(
      args: SelectSubset<T, WeekliesUpdateArgs>
    ): CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>>

    /**
     * Delete zero or more Weeklies.
     * @param {WeekliesDeleteManyArgs} args - Arguments to filter Weeklies to delete.
     * @example
     * // Delete a few Weeklies
     * const { count } = await prisma.weeklies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WeekliesDeleteManyArgs>(
      args?: SelectSubset<T, WeekliesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weeklies
     * const weeklies = await prisma.weeklies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WeekliesUpdateManyArgs>(
      args: SelectSubset<T, WeekliesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weeklies.
     * @param {WeekliesUpsertArgs} args - Arguments to update or create a Weeklies.
     * @example
     * // Update or create a Weeklies
     * const weeklies = await prisma.weeklies.upsert({
     *   create: {
     *     // ... data to create a Weeklies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weeklies we want to update
     *   }
     * })
    **/
    upsert<T extends WeekliesUpsertArgs>(
      args: SelectSubset<T, WeekliesUpsertArgs>
    ): CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>>

    /**
     * Find one Weeklies that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {WeekliesFindUniqueOrThrowArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WeekliesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WeekliesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>>

    /**
     * Find the first Weeklies that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesFindFirstOrThrowArgs} args - Arguments to find a Weeklies
     * @example
     * // Get one Weeklies
     * const weeklies = await prisma.weeklies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WeekliesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WeekliesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__WeekliesClient<Weeklies>, Prisma__WeekliesClient<WeekliesGetPayload<T>>>

    /**
     * Count the number of Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesCountArgs} args - Arguments to filter Weeklies to count.
     * @example
     * // Count the number of Weeklies
     * const count = await prisma.weeklies.count({
     *   where: {
     *     // ... the filter for the Weeklies we want to count
     *   }
     * })
    **/
    count<T extends WeekliesCountArgs>(
      args?: Subset<T, WeekliesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeekliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeekliesAggregateArgs>(args: Subset<T, WeekliesAggregateArgs>): PrismaPromise<GetWeekliesAggregateType<T>>

    /**
     * Group by Weeklies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeekliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeekliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeekliesGroupByArgs['orderBy'] }
        : { orderBy?: WeekliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeekliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeekliesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Weeklies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WeekliesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Customers<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    DeliveryLocations<T extends DeliveryLocationsArgs = {}>(args?: Subset<T, DeliveryLocationsArgs>): CheckSelect<T, Prisma__DeliveryLocationsClient<DeliveryLocations | null >, Prisma__DeliveryLocationsClient<DeliveryLocationsGetPayload<T> | null >>;

    Invoices<T extends InvoicesArgs = {}>(args?: Subset<T, InvoicesArgs>): CheckSelect<T, Prisma__InvoicesClient<Invoices | null >, Prisma__InvoicesClient<InvoicesGetPayload<T> | null >>;

    LoadTypes<T extends LoadTypesArgs = {}>(args?: Subset<T, LoadTypesArgs>): CheckSelect<T, Prisma__LoadTypesClient<LoadTypes | null >, Prisma__LoadTypesClient<LoadTypesGetPayload<T> | null >>;

    Jobs<T extends JobsFindManyArgs = {}>(args?: Subset<T, JobsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Weeklies base type for findUnique actions
   */
  export type WeekliesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
    /**
     * Filter, which Weeklies to fetch.
     * 
    **/
    where: WeekliesWhereUniqueInput
  }

  /**
   * Weeklies: findUnique
   */
  export interface WeekliesFindUniqueArgs extends WeekliesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Weeklies base type for findFirst actions
   */
  export type WeekliesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
    /**
     * Filter, which Weeklies to fetch.
     * 
    **/
    where?: WeekliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeklies to fetch.
     * 
    **/
    orderBy?: Enumerable<WeekliesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weeklies.
     * 
    **/
    cursor?: WeekliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeklies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeklies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weeklies.
     * 
    **/
    distinct?: Enumerable<WeekliesScalarFieldEnum>
  }

  /**
   * Weeklies: findFirst
   */
  export interface WeekliesFindFirstArgs extends WeekliesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Weeklies findMany
   */
  export type WeekliesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
    /**
     * Filter, which Weeklies to fetch.
     * 
    **/
    where?: WeekliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weeklies to fetch.
     * 
    **/
    orderBy?: Enumerable<WeekliesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weeklies.
     * 
    **/
    cursor?: WeekliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weeklies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weeklies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WeekliesScalarFieldEnum>
  }


  /**
   * Weeklies create
   */
  export type WeekliesCreateArgs = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
    /**
     * The data needed to create a Weeklies.
     * 
    **/
    data: XOR<WeekliesCreateInput, WeekliesUncheckedCreateInput>
  }


  /**
   * Weeklies createMany
   */
  export type WeekliesCreateManyArgs = {
    /**
     * The data used to create many Weeklies.
     * 
    **/
    data: Enumerable<WeekliesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Weeklies update
   */
  export type WeekliesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
    /**
     * The data needed to update a Weeklies.
     * 
    **/
    data: XOR<WeekliesUpdateInput, WeekliesUncheckedUpdateInput>
    /**
     * Choose, which Weeklies to update.
     * 
    **/
    where: WeekliesWhereUniqueInput
  }


  /**
   * Weeklies updateMany
   */
  export type WeekliesUpdateManyArgs = {
    /**
     * The data used to update Weeklies.
     * 
    **/
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyInput>
    /**
     * Filter which Weeklies to update
     * 
    **/
    where?: WeekliesWhereInput
  }


  /**
   * Weeklies upsert
   */
  export type WeekliesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
    /**
     * The filter to search for the Weeklies to update in case it exists.
     * 
    **/
    where: WeekliesWhereUniqueInput
    /**
     * In case the Weeklies found by the `where` argument doesn't exist, create a new Weeklies with this data.
     * 
    **/
    create: XOR<WeekliesCreateInput, WeekliesUncheckedCreateInput>
    /**
     * In case the Weeklies was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WeekliesUpdateInput, WeekliesUncheckedUpdateInput>
  }


  /**
   * Weeklies delete
   */
  export type WeekliesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
    /**
     * Filter which Weeklies to delete.
     * 
    **/
    where: WeekliesWhereUniqueInput
  }


  /**
   * Weeklies deleteMany
   */
  export type WeekliesDeleteManyArgs = {
    /**
     * Filter which Weeklies to delete
     * 
    **/
    where?: WeekliesWhereInput
  }


  /**
   * Weeklies: findUniqueOrThrow
   */
  export type WeekliesFindUniqueOrThrowArgs = WeekliesFindUniqueArgsBase
      

  /**
   * Weeklies: findFirstOrThrow
   */
  export type WeekliesFindFirstOrThrowArgs = WeekliesFindFirstArgsBase
      

  /**
   * Weeklies without action
   */
  export type WeekliesArgs = {
    /**
     * Select specific fields to fetch from the Weeklies
     * 
    **/
    select?: WeekliesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeekliesInclude | null
  }



  /**
   * Model PayStubs
   */


  export type AggregatePayStubs = {
    _count: PayStubsCountAggregateOutputType | null
    _avg: PayStubsAvgAggregateOutputType | null
    _sum: PayStubsSumAggregateOutputType | null
    _min: PayStubsMinAggregateOutputType | null
    _max: PayStubsMaxAggregateOutputType | null
  }

  export type PayStubsAvgAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
  }

  export type PayStubsSumAggregateOutputType = {
    ID: number | null
    DriverID: number | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
  }

  export type PayStubsMinAggregateOutputType = {
    ID: number | null
    Created: Date | null
    DriverID: number | null
    CheckNumber: string | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    LastPrinted: Date | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
    Notes: string | null
    DepositDate: Date | null
  }

  export type PayStubsMaxAggregateOutputType = {
    ID: number | null
    Created: Date | null
    DriverID: number | null
    CheckNumber: string | null
    Gross: number | null
    Percentage: number | null
    NetTotal: number | null
    LastPrinted: Date | null
    TakeHome: number | null
    Deductions: number | null
    Additions: number | null
    Notes: string | null
    DepositDate: Date | null
  }

  export type PayStubsCountAggregateOutputType = {
    ID: number
    Created: number
    DriverID: number
    CheckNumber: number
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted: number
    TakeHome: number
    Deductions: number
    Additions: number
    Notes: number
    DepositDate: number
    _all: number
  }


  export type PayStubsAvgAggregateInputType = {
    ID?: true
    DriverID?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
  }

  export type PayStubsSumAggregateInputType = {
    ID?: true
    DriverID?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
  }

  export type PayStubsMinAggregateInputType = {
    ID?: true
    Created?: true
    DriverID?: true
    CheckNumber?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    LastPrinted?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
    Notes?: true
    DepositDate?: true
  }

  export type PayStubsMaxAggregateInputType = {
    ID?: true
    Created?: true
    DriverID?: true
    CheckNumber?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    LastPrinted?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
    Notes?: true
    DepositDate?: true
  }

  export type PayStubsCountAggregateInputType = {
    ID?: true
    Created?: true
    DriverID?: true
    CheckNumber?: true
    Gross?: true
    Percentage?: true
    NetTotal?: true
    LastPrinted?: true
    TakeHome?: true
    Deductions?: true
    Additions?: true
    Notes?: true
    DepositDate?: true
    _all?: true
  }

  export type PayStubsAggregateArgs = {
    /**
     * Filter which PayStubs to aggregate.
     * 
    **/
    where?: PayStubsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStubs to fetch.
     * 
    **/
    orderBy?: Enumerable<PayStubsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PayStubsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStubs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayStubs
    **/
    _count?: true | PayStubsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayStubsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayStubsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayStubsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayStubsMaxAggregateInputType
  }

  export type GetPayStubsAggregateType<T extends PayStubsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayStubs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayStubs[P]>
      : GetScalarType<T[P], AggregatePayStubs[P]>
  }




  export type PayStubsGroupByArgs = {
    where?: PayStubsWhereInput
    orderBy?: Enumerable<PayStubsOrderByWithAggregationInput>
    by: Array<PayStubsScalarFieldEnum>
    having?: PayStubsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayStubsCountAggregateInputType | true
    _avg?: PayStubsAvgAggregateInputType
    _sum?: PayStubsSumAggregateInputType
    _min?: PayStubsMinAggregateInputType
    _max?: PayStubsMaxAggregateInputType
  }


  export type PayStubsGroupByOutputType = {
    ID: number
    Created: Date
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted: Date | null
    TakeHome: number
    Deductions: number
    Additions: number
    Notes: string | null
    DepositDate: Date | null
    _count: PayStubsCountAggregateOutputType | null
    _avg: PayStubsAvgAggregateOutputType | null
    _sum: PayStubsSumAggregateOutputType | null
    _min: PayStubsMinAggregateOutputType | null
    _max: PayStubsMaxAggregateOutputType | null
  }

  type GetPayStubsGroupByPayload<T extends PayStubsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PayStubsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayStubsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayStubsGroupByOutputType[P]>
            : GetScalarType<T[P], PayStubsGroupByOutputType[P]>
        }
      >
    >


  export type PayStubsSelect = {
    ID?: boolean
    Created?: boolean
    DriverID?: boolean
    CheckNumber?: boolean
    Gross?: boolean
    Percentage?: boolean
    NetTotal?: boolean
    LastPrinted?: boolean
    TakeHome?: boolean
    Deductions?: boolean
    Additions?: boolean
    Notes?: boolean
    DepositDate?: boolean
    Drivers?: boolean | DriversArgs
    Jobs?: boolean | JobsFindManyArgs
    _count?: boolean | PayStubsCountOutputTypeArgs
  }

  export type PayStubsInclude = {
    Drivers?: boolean | DriversArgs
    Jobs?: boolean | JobsFindManyArgs
    _count?: boolean | PayStubsCountOutputTypeArgs
  }

  export type PayStubsGetPayload<
    S extends boolean | null | undefined | PayStubsArgs,
    U = keyof S
      > = S extends true
        ? PayStubs
    : S extends undefined
    ? never
    : S extends PayStubsArgs | PayStubsFindManyArgs
    ?'include' extends U
    ? PayStubs  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Drivers' ? DriversGetPayload<S['include'][P]> :
        P extends 'Jobs' ? Array < JobsGetPayload<S['include'][P]>>  :
        P extends '_count' ? PayStubsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Drivers' ? DriversGetPayload<S['select'][P]> :
        P extends 'Jobs' ? Array < JobsGetPayload<S['select'][P]>>  :
        P extends '_count' ? PayStubsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PayStubs ? PayStubs[P] : never
  } 
    : PayStubs
  : PayStubs


  type PayStubsCountArgs = Merge<
    Omit<PayStubsFindManyArgs, 'select' | 'include'> & {
      select?: PayStubsCountAggregateInputType | true
    }
  >

  export interface PayStubsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PayStubs that matches the filter.
     * @param {PayStubsFindUniqueArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PayStubsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PayStubsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PayStubs'> extends True ? CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>> : CheckSelect<T, Prisma__PayStubsClient<PayStubs | null >, Prisma__PayStubsClient<PayStubsGetPayload<T> | null >>

    /**
     * Find the first PayStubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsFindFirstArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PayStubsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PayStubsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PayStubs'> extends True ? CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>> : CheckSelect<T, Prisma__PayStubsClient<PayStubs | null >, Prisma__PayStubsClient<PayStubsGetPayload<T> | null >>

    /**
     * Find zero or more PayStubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayStubs
     * const payStubs = await prisma.payStubs.findMany()
     * 
     * // Get first 10 PayStubs
     * const payStubs = await prisma.payStubs.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const payStubsWithIDOnly = await prisma.payStubs.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends PayStubsFindManyArgs>(
      args?: SelectSubset<T, PayStubsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PayStubs>>, PrismaPromise<Array<PayStubsGetPayload<T>>>>

    /**
     * Create a PayStubs.
     * @param {PayStubsCreateArgs} args - Arguments to create a PayStubs.
     * @example
     * // Create one PayStubs
     * const PayStubs = await prisma.payStubs.create({
     *   data: {
     *     // ... data to create a PayStubs
     *   }
     * })
     * 
    **/
    create<T extends PayStubsCreateArgs>(
      args: SelectSubset<T, PayStubsCreateArgs>
    ): CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>>

    /**
     * Create many PayStubs.
     *     @param {PayStubsCreateManyArgs} args - Arguments to create many PayStubs.
     *     @example
     *     // Create many PayStubs
     *     const payStubs = await prisma.payStubs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PayStubsCreateManyArgs>(
      args?: SelectSubset<T, PayStubsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PayStubs.
     * @param {PayStubsDeleteArgs} args - Arguments to delete one PayStubs.
     * @example
     * // Delete one PayStubs
     * const PayStubs = await prisma.payStubs.delete({
     *   where: {
     *     // ... filter to delete one PayStubs
     *   }
     * })
     * 
    **/
    delete<T extends PayStubsDeleteArgs>(
      args: SelectSubset<T, PayStubsDeleteArgs>
    ): CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>>

    /**
     * Update one PayStubs.
     * @param {PayStubsUpdateArgs} args - Arguments to update one PayStubs.
     * @example
     * // Update one PayStubs
     * const payStubs = await prisma.payStubs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PayStubsUpdateArgs>(
      args: SelectSubset<T, PayStubsUpdateArgs>
    ): CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>>

    /**
     * Delete zero or more PayStubs.
     * @param {PayStubsDeleteManyArgs} args - Arguments to filter PayStubs to delete.
     * @example
     * // Delete a few PayStubs
     * const { count } = await prisma.payStubs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PayStubsDeleteManyArgs>(
      args?: SelectSubset<T, PayStubsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayStubs
     * const payStubs = await prisma.payStubs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PayStubsUpdateManyArgs>(
      args: SelectSubset<T, PayStubsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PayStubs.
     * @param {PayStubsUpsertArgs} args - Arguments to update or create a PayStubs.
     * @example
     * // Update or create a PayStubs
     * const payStubs = await prisma.payStubs.upsert({
     *   create: {
     *     // ... data to create a PayStubs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayStubs we want to update
     *   }
     * })
    **/
    upsert<T extends PayStubsUpsertArgs>(
      args: SelectSubset<T, PayStubsUpsertArgs>
    ): CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>>

    /**
     * Find one PayStubs that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PayStubsFindUniqueOrThrowArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PayStubsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PayStubsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>>

    /**
     * Find the first PayStubs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsFindFirstOrThrowArgs} args - Arguments to find a PayStubs
     * @example
     * // Get one PayStubs
     * const payStubs = await prisma.payStubs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PayStubsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PayStubsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PayStubsClient<PayStubs>, Prisma__PayStubsClient<PayStubsGetPayload<T>>>

    /**
     * Count the number of PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsCountArgs} args - Arguments to filter PayStubs to count.
     * @example
     * // Count the number of PayStubs
     * const count = await prisma.payStubs.count({
     *   where: {
     *     // ... the filter for the PayStubs we want to count
     *   }
     * })
    **/
    count<T extends PayStubsCountArgs>(
      args?: Subset<T, PayStubsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayStubsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayStubsAggregateArgs>(args: Subset<T, PayStubsAggregateArgs>): PrismaPromise<GetPayStubsAggregateType<T>>

    /**
     * Group by PayStubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStubsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayStubsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayStubsGroupByArgs['orderBy'] }
        : { orderBy?: PayStubsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayStubsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayStubsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PayStubs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PayStubsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Drivers<T extends DriversArgs = {}>(args?: Subset<T, DriversArgs>): CheckSelect<T, Prisma__DriversClient<Drivers | null >, Prisma__DriversClient<DriversGetPayload<T> | null >>;

    Jobs<T extends JobsFindManyArgs = {}>(args?: Subset<T, JobsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Jobs>>, PrismaPromise<Array<JobsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PayStubs base type for findUnique actions
   */
  export type PayStubsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
    /**
     * Filter, which PayStubs to fetch.
     * 
    **/
    where: PayStubsWhereUniqueInput
  }

  /**
   * PayStubs: findUnique
   */
  export interface PayStubsFindUniqueArgs extends PayStubsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PayStubs base type for findFirst actions
   */
  export type PayStubsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
    /**
     * Filter, which PayStubs to fetch.
     * 
    **/
    where?: PayStubsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStubs to fetch.
     * 
    **/
    orderBy?: Enumerable<PayStubsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayStubs.
     * 
    **/
    cursor?: PayStubsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStubs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayStubs.
     * 
    **/
    distinct?: Enumerable<PayStubsScalarFieldEnum>
  }

  /**
   * PayStubs: findFirst
   */
  export interface PayStubsFindFirstArgs extends PayStubsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PayStubs findMany
   */
  export type PayStubsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
    /**
     * Filter, which PayStubs to fetch.
     * 
    **/
    where?: PayStubsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStubs to fetch.
     * 
    **/
    orderBy?: Enumerable<PayStubsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayStubs.
     * 
    **/
    cursor?: PayStubsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStubs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PayStubsScalarFieldEnum>
  }


  /**
   * PayStubs create
   */
  export type PayStubsCreateArgs = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
    /**
     * The data needed to create a PayStubs.
     * 
    **/
    data: XOR<PayStubsCreateInput, PayStubsUncheckedCreateInput>
  }


  /**
   * PayStubs createMany
   */
  export type PayStubsCreateManyArgs = {
    /**
     * The data used to create many PayStubs.
     * 
    **/
    data: Enumerable<PayStubsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PayStubs update
   */
  export type PayStubsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
    /**
     * The data needed to update a PayStubs.
     * 
    **/
    data: XOR<PayStubsUpdateInput, PayStubsUncheckedUpdateInput>
    /**
     * Choose, which PayStubs to update.
     * 
    **/
    where: PayStubsWhereUniqueInput
  }


  /**
   * PayStubs updateMany
   */
  export type PayStubsUpdateManyArgs = {
    /**
     * The data used to update PayStubs.
     * 
    **/
    data: XOR<PayStubsUpdateManyMutationInput, PayStubsUncheckedUpdateManyInput>
    /**
     * Filter which PayStubs to update
     * 
    **/
    where?: PayStubsWhereInput
  }


  /**
   * PayStubs upsert
   */
  export type PayStubsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
    /**
     * The filter to search for the PayStubs to update in case it exists.
     * 
    **/
    where: PayStubsWhereUniqueInput
    /**
     * In case the PayStubs found by the `where` argument doesn't exist, create a new PayStubs with this data.
     * 
    **/
    create: XOR<PayStubsCreateInput, PayStubsUncheckedCreateInput>
    /**
     * In case the PayStubs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PayStubsUpdateInput, PayStubsUncheckedUpdateInput>
  }


  /**
   * PayStubs delete
   */
  export type PayStubsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
    /**
     * Filter which PayStubs to delete.
     * 
    **/
    where: PayStubsWhereUniqueInput
  }


  /**
   * PayStubs deleteMany
   */
  export type PayStubsDeleteManyArgs = {
    /**
     * Filter which PayStubs to delete
     * 
    **/
    where?: PayStubsWhereInput
  }


  /**
   * PayStubs: findUniqueOrThrow
   */
  export type PayStubsFindUniqueOrThrowArgs = PayStubsFindUniqueArgsBase
      

  /**
   * PayStubs: findFirstOrThrow
   */
  export type PayStubsFindFirstOrThrowArgs = PayStubsFindFirstArgsBase
      

  /**
   * PayStubs without action
   */
  export type PayStubsArgs = {
    /**
     * Select specific fields to fetch from the PayStubs
     * 
    **/
    select?: PayStubsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PayStubsInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CustomerDeliveryLocationsScalarFieldEnum: {
    ID: 'ID',
    CustomerID: 'CustomerID',
    DeliveryLocationID: 'DeliveryLocationID',
    DateUsed: 'DateUsed'
  };

  export type CustomerDeliveryLocationsScalarFieldEnum = (typeof CustomerDeliveryLocationsScalarFieldEnum)[keyof typeof CustomerDeliveryLocationsScalarFieldEnum]


  export const CustomerLoadTypesScalarFieldEnum: {
    ID: 'ID',
    CustomerID: 'CustomerID',
    LoadTypeID: 'LoadTypeID',
    DateDelivered: 'DateDelivered'
  };

  export type CustomerLoadTypesScalarFieldEnum = (typeof CustomerLoadTypesScalarFieldEnum)[keyof typeof CustomerLoadTypesScalarFieldEnum]


  export const CustomersOrderByRelevanceFieldEnum: {
    Name: 'Name',
    Street: 'Street',
    City: 'City',
    ZIP: 'ZIP',
    Phone: 'Phone',
    Email: 'Email',
    Notes: 'Notes',
    MainContact: 'MainContact'
  };

  export type CustomersOrderByRelevanceFieldEnum = (typeof CustomersOrderByRelevanceFieldEnum)[keyof typeof CustomersOrderByRelevanceFieldEnum]


  export const CustomersScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Street: 'Street',
    City: 'City',
    State: 'State',
    ZIP: 'ZIP',
    Phone: 'Phone',
    Email: 'Email',
    Notes: 'Notes',
    MainContact: 'MainContact',
    Deleted: 'Deleted'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const DailiesOrderByRelevanceFieldEnum: {
    Week: 'Week'
  };

  export type DailiesOrderByRelevanceFieldEnum = (typeof DailiesOrderByRelevanceFieldEnum)[keyof typeof DailiesOrderByRelevanceFieldEnum]


  export const DailiesScalarFieldEnum: {
    ID: 'ID',
    DriverID: 'DriverID',
    Week: 'Week',
    LastPrinted: 'LastPrinted'
  };

  export type DailiesScalarFieldEnum = (typeof DailiesScalarFieldEnum)[keyof typeof DailiesScalarFieldEnum]


  export const DeliveryLocationsOrderByRelevanceFieldEnum: {
    Description: 'Description'
  };

  export type DeliveryLocationsOrderByRelevanceFieldEnum = (typeof DeliveryLocationsOrderByRelevanceFieldEnum)[keyof typeof DeliveryLocationsOrderByRelevanceFieldEnum]


  export const DeliveryLocationsScalarFieldEnum: {
    ID: 'ID',
    Description: 'Description',
    Deleted: 'Deleted',
    CustomerID: 'CustomerID'
  };

  export type DeliveryLocationsScalarFieldEnum = (typeof DeliveryLocationsScalarFieldEnum)[keyof typeof DeliveryLocationsScalarFieldEnum]


  export const DriversOrderByRelevanceFieldEnum: {
    FirstName: 'FirstName',
    MiddleName: 'MiddleName',
    LastName: 'LastName',
    Street: 'Street',
    City: 'City',
    ZIP: 'ZIP',
    License: 'License',
    Email: 'Email',
    Phone: 'Phone',
    Notes: 'Notes',
    HireDate: 'HireDate'
  };

  export type DriversOrderByRelevanceFieldEnum = (typeof DriversOrderByRelevanceFieldEnum)[keyof typeof DriversOrderByRelevanceFieldEnum]


  export const DriversScalarFieldEnum: {
    ID: 'ID',
    FirstName: 'FirstName',
    MiddleName: 'MiddleName',
    LastName: 'LastName',
    Street: 'Street',
    City: 'City',
    State: 'State',
    ZIP: 'ZIP',
    DOB: 'DOB',
    License: 'License',
    Email: 'Email',
    Phone: 'Phone',
    Notes: 'Notes',
    Deleted: 'Deleted',
    HireDate: 'HireDate',
    OwnerOperator: 'OwnerOperator'
  };

  export type DriversScalarFieldEnum = (typeof DriversScalarFieldEnum)[keyof typeof DriversScalarFieldEnum]


  export const InvoicesOrderByRelevanceFieldEnum: {
    CheckNumber: 'CheckNumber',
    PaymentType: 'PaymentType'
  };

  export type InvoicesOrderByRelevanceFieldEnum = (typeof InvoicesOrderByRelevanceFieldEnum)[keyof typeof InvoicesOrderByRelevanceFieldEnum]


  export const InvoicesScalarFieldEnum: {
    ID: 'ID',
    InvoiceDate: 'InvoiceDate',
    Number: 'Number',
    CustomerID: 'CustomerID',
    TotalAmount: 'TotalAmount',
    PaidDate: 'PaidDate',
    CheckNumber: 'CheckNumber',
    Paid: 'Paid',
    Printed: 'Printed',
    Deleted: 'Deleted',
    PaymentType: 'PaymentType',
    Consolidated: 'Consolidated',
    ConsolidatedID: 'ConsolidatedID'
  };

  export type InvoicesScalarFieldEnum = (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    ID: 'ID',
    DriverID: 'DriverID',
    LoadTypeID: 'LoadTypeID',
    CustomerID: 'CustomerID',
    PaidOut: 'PaidOut',
    TruckingRevenue: 'TruckingRevenue',
    CompanyRevenue: 'CompanyRevenue',
    TruckingRate: 'TruckingRate',
    CompanyRate: 'CompanyRate',
    DeliveryLocationID: 'DeliveryLocationID',
    WeeklyID: 'WeeklyID',
    DailyID: 'DailyID',
    MaterialRate: 'MaterialRate',
    DriverRate: 'DriverRate',
    PayStubID: 'PayStubID'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const LoadTypesOrderByRelevanceFieldEnum: {
    Description: 'Description',
    Notes: 'Notes'
  };

  export type LoadTypesOrderByRelevanceFieldEnum = (typeof LoadTypesOrderByRelevanceFieldEnum)[keyof typeof LoadTypesOrderByRelevanceFieldEnum]


  export const LoadTypesScalarFieldEnum: {
    ID: 'ID',
    Description: 'Description',
    Deleted: 'Deleted',
    SourceID: 'SourceID',
    Notes: 'Notes'
  };

  export type LoadTypesScalarFieldEnum = (typeof LoadTypesScalarFieldEnum)[keyof typeof LoadTypesScalarFieldEnum]


  export const LoadsOrderByRelevanceFieldEnum: {
    Received: 'Received',
    Notes: 'Notes',
    Week: 'Week'
  };

  export type LoadsOrderByRelevanceFieldEnum = (typeof LoadsOrderByRelevanceFieldEnum)[keyof typeof LoadsOrderByRelevanceFieldEnum]


  export const LoadsScalarFieldEnum: {
    ID: 'ID',
    StartDate: 'StartDate',
    Created: 'Created',
    Weight: 'Weight',
    Hours: 'Hours',
    TotalRate: 'TotalRate',
    TotalAmount: 'TotalAmount',
    TruckRate: 'TruckRate',
    MaterialRate: 'MaterialRate',
    Received: 'Received',
    Notes: 'Notes',
    TicketNumber: 'TicketNumber',
    Invoiced: 'Invoiced',
    CustomerID: 'CustomerID',
    InvoiceID: 'InvoiceID',
    LoadTypeID: 'LoadTypeID',
    DeliveryLocationID: 'DeliveryLocationID',
    TruckID: 'TruckID',
    DriverID: 'DriverID',
    Deleted: 'Deleted',
    JobID: 'JobID',
    Week: 'Week',
    DriverRate: 'DriverRate'
  };

  export type LoadsScalarFieldEnum = (typeof LoadsScalarFieldEnum)[keyof typeof LoadsScalarFieldEnum]


  export const PayStubsOrderByRelevanceFieldEnum: {
    CheckNumber: 'CheckNumber',
    Notes: 'Notes'
  };

  export type PayStubsOrderByRelevanceFieldEnum = (typeof PayStubsOrderByRelevanceFieldEnum)[keyof typeof PayStubsOrderByRelevanceFieldEnum]


  export const PayStubsScalarFieldEnum: {
    ID: 'ID',
    Created: 'Created',
    DriverID: 'DriverID',
    CheckNumber: 'CheckNumber',
    Gross: 'Gross',
    Percentage: 'Percentage',
    NetTotal: 'NetTotal',
    LastPrinted: 'LastPrinted',
    TakeHome: 'TakeHome',
    Deductions: 'Deductions',
    Additions: 'Additions',
    Notes: 'Notes',
    DepositDate: 'DepositDate'
  };

  export type PayStubsScalarFieldEnum = (typeof PayStubsScalarFieldEnum)[keyof typeof PayStubsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StatesOrderByRelevanceFieldEnum: {
    Name: 'Name',
    Abbreviation: 'Abbreviation'
  };

  export type StatesOrderByRelevanceFieldEnum = (typeof StatesOrderByRelevanceFieldEnum)[keyof typeof StatesOrderByRelevanceFieldEnum]


  export const StatesScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Abbreviation: 'Abbreviation'
  };

  export type StatesScalarFieldEnum = (typeof StatesScalarFieldEnum)[keyof typeof StatesScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TrucksDrivenScalarFieldEnum: {
    ID: 'ID',
    TruckID: 'TruckID',
    DriverID: 'DriverID',
    DateDriven: 'DateDriven'
  };

  export type TrucksDrivenScalarFieldEnum = (typeof TrucksDrivenScalarFieldEnum)[keyof typeof TrucksDrivenScalarFieldEnum]


  export const TrucksOrderByRelevanceFieldEnum: {
    Name: 'Name',
    VIN: 'VIN',
    Notes: 'Notes'
  };

  export type TrucksOrderByRelevanceFieldEnum = (typeof TrucksOrderByRelevanceFieldEnum)[keyof typeof TrucksOrderByRelevanceFieldEnum]


  export const TrucksScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    VIN: 'VIN',
    Deleted: 'Deleted',
    Notes: 'Notes'
  };

  export type TrucksScalarFieldEnum = (typeof TrucksScalarFieldEnum)[keyof typeof TrucksScalarFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    organization: 'organization',
    password: 'password',
    username: 'username'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    organization: 'organization',
    password: 'password',
    username: 'username'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WeekliesOrderByRelevanceFieldEnum: {
    Week: 'Week'
  };

  export type WeekliesOrderByRelevanceFieldEnum = (typeof WeekliesOrderByRelevanceFieldEnum)[keyof typeof WeekliesOrderByRelevanceFieldEnum]


  export const WeekliesScalarFieldEnum: {
    ID: 'ID',
    Week: 'Week',
    CustomerID: 'CustomerID',
    InvoiceID: 'InvoiceID',
    CompanyRate: 'CompanyRate',
    Revenue: 'Revenue',
    LoadTypeID: 'LoadTypeID',
    DeliveryLocationID: 'DeliveryLocationID',
    LastPrinted: 'LastPrinted',
    TotalWeight: 'TotalWeight'
  };

  export type WeekliesScalarFieldEnum = (typeof WeekliesScalarFieldEnum)[keyof typeof WeekliesScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    organization?: StringFilter | string
    password?: StringFilter | string
    username?: StringFilter | string
  }

  export type UserOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = {
    id?: number
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    organization?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
  }

  export type CustomerLoadTypesWhereInput = {
    AND?: Enumerable<CustomerLoadTypesWhereInput>
    OR?: Enumerable<CustomerLoadTypesWhereInput>
    NOT?: Enumerable<CustomerLoadTypesWhereInput>
    ID?: IntFilter | number
    CustomerID?: IntFilter | number
    LoadTypeID?: IntFilter | number
    DateDelivered?: DateTimeFilter | Date | string
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    LoadTypes?: XOR<LoadTypesRelationFilter, LoadTypesWhereInput>
  }

  export type CustomerLoadTypesOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
    Customers?: CustomersOrderByWithRelationAndSearchRelevanceInput
    LoadTypes?: LoadTypesOrderByWithRelationAndSearchRelevanceInput
  }

  export type CustomerLoadTypesWhereUniqueInput = {
    ID?: number
  }

  export type CustomerLoadTypesOrderByWithAggregationInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
    _count?: CustomerLoadTypesCountOrderByAggregateInput
    _avg?: CustomerLoadTypesAvgOrderByAggregateInput
    _max?: CustomerLoadTypesMaxOrderByAggregateInput
    _min?: CustomerLoadTypesMinOrderByAggregateInput
    _sum?: CustomerLoadTypesSumOrderByAggregateInput
  }

  export type CustomerLoadTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerLoadTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerLoadTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerLoadTypesScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    CustomerID?: IntWithAggregatesFilter | number
    LoadTypeID?: IntWithAggregatesFilter | number
    DateDelivered?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomersWhereInput = {
    AND?: Enumerable<CustomersWhereInput>
    OR?: Enumerable<CustomersWhereInput>
    NOT?: Enumerable<CustomersWhereInput>
    ID?: IntFilter | number
    Name?: StringFilter | string
    Street?: StringFilter | string
    City?: StringFilter | string
    State?: IntFilter | number
    ZIP?: StringFilter | string
    Phone?: StringNullableFilter | string | null
    Email?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    MainContact?: StringNullableFilter | string | null
    Deleted?: BoolNullableFilter | boolean | null
    States?: XOR<StatesRelationFilter, StatesWhereInput>
    CustomerDeliveryLocations?: CustomerDeliveryLocationsListRelationFilter
    CustomerLoadTypes?: CustomerLoadTypesListRelationFilter
    DeliveryLocations?: DeliveryLocationsListRelationFilter
    Invoices?: InvoicesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type CustomersOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
    States?: StatesOrderByWithRelationAndSearchRelevanceInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsOrderByRelationAggregateInput
    CustomerLoadTypes?: CustomerLoadTypesOrderByRelationAggregateInput
    DeliveryLocations?: DeliveryLocationsOrderByRelationAggregateInput
    Invoices?: InvoicesOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: CustomersOrderByRelevanceInput
  }

  export type CustomersWhereUniqueInput = {
    ID?: number
  }

  export type CustomersOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Street?: StringWithAggregatesFilter | string
    City?: StringWithAggregatesFilter | string
    State?: IntWithAggregatesFilter | number
    ZIP?: StringWithAggregatesFilter | string
    Phone?: StringNullableWithAggregatesFilter | string | null
    Email?: StringNullableWithAggregatesFilter | string | null
    Notes?: StringNullableWithAggregatesFilter | string | null
    MainContact?: StringNullableWithAggregatesFilter | string | null
    Deleted?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type DeliveryLocationsWhereInput = {
    AND?: Enumerable<DeliveryLocationsWhereInput>
    OR?: Enumerable<DeliveryLocationsWhereInput>
    NOT?: Enumerable<DeliveryLocationsWhereInput>
    ID?: IntFilter | number
    Description?: StringFilter | string
    Deleted?: BoolNullableFilter | boolean | null
    CustomerID?: IntNullableFilter | number | null
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput> | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
    Customers?: CustomersOrderByWithRelationAndSearchRelevanceInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: DeliveryLocationsOrderByRelevanceInput
  }

  export type DeliveryLocationsWhereUniqueInput = {
    ID?: number
  }

  export type DeliveryLocationsOrderByWithAggregationInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
    _count?: DeliveryLocationsCountOrderByAggregateInput
    _avg?: DeliveryLocationsAvgOrderByAggregateInput
    _max?: DeliveryLocationsMaxOrderByAggregateInput
    _min?: DeliveryLocationsMinOrderByAggregateInput
    _sum?: DeliveryLocationsSumOrderByAggregateInput
  }

  export type DeliveryLocationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeliveryLocationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeliveryLocationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeliveryLocationsScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Deleted?: BoolNullableWithAggregatesFilter | boolean | null
    CustomerID?: IntNullableWithAggregatesFilter | number | null
  }

  export type DriversWhereInput = {
    AND?: Enumerable<DriversWhereInput>
    OR?: Enumerable<DriversWhereInput>
    NOT?: Enumerable<DriversWhereInput>
    ID?: IntFilter | number
    FirstName?: StringFilter | string
    MiddleName?: StringNullableFilter | string | null
    LastName?: StringFilter | string
    Street?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    State?: IntNullableFilter | number | null
    ZIP?: StringNullableFilter | string | null
    DOB?: DateTimeNullableFilter | Date | string | null
    License?: StringNullableFilter | string | null
    Email?: StringNullableFilter | string | null
    Phone?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    Deleted?: BoolNullableFilter | boolean | null
    HireDate?: StringNullableFilter | string | null
    OwnerOperator?: BoolFilter | boolean
    States?: XOR<StatesRelationFilter, StatesWhereInput> | null
    Dailies?: DailiesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    PayStubs?: PayStubsListRelationFilter
    TrucksDriven?: TrucksDrivenListRelationFilter
  }

  export type DriversOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
    States?: StatesOrderByWithRelationAndSearchRelevanceInput
    Dailies?: DailiesOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    PayStubs?: PayStubsOrderByRelationAggregateInput
    TrucksDriven?: TrucksDrivenOrderByRelationAggregateInput
    _relevance?: DriversOrderByRelevanceInput
  }

  export type DriversWhereUniqueInput = {
    ID?: number
  }

  export type DriversOrderByWithAggregationInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
    _count?: DriversCountOrderByAggregateInput
    _avg?: DriversAvgOrderByAggregateInput
    _max?: DriversMaxOrderByAggregateInput
    _min?: DriversMinOrderByAggregateInput
    _sum?: DriversSumOrderByAggregateInput
  }

  export type DriversScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DriversScalarWhereWithAggregatesInput>
    OR?: Enumerable<DriversScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DriversScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    FirstName?: StringWithAggregatesFilter | string
    MiddleName?: StringNullableWithAggregatesFilter | string | null
    LastName?: StringWithAggregatesFilter | string
    Street?: StringNullableWithAggregatesFilter | string | null
    City?: StringNullableWithAggregatesFilter | string | null
    State?: IntNullableWithAggregatesFilter | number | null
    ZIP?: StringNullableWithAggregatesFilter | string | null
    DOB?: DateTimeNullableWithAggregatesFilter | Date | string | null
    License?: StringNullableWithAggregatesFilter | string | null
    Email?: StringNullableWithAggregatesFilter | string | null
    Phone?: StringNullableWithAggregatesFilter | string | null
    Notes?: StringNullableWithAggregatesFilter | string | null
    Deleted?: BoolNullableWithAggregatesFilter | boolean | null
    HireDate?: StringNullableWithAggregatesFilter | string | null
    OwnerOperator?: BoolWithAggregatesFilter | boolean
  }

  export type InvoicesWhereInput = {
    AND?: Enumerable<InvoicesWhereInput>
    OR?: Enumerable<InvoicesWhereInput>
    NOT?: Enumerable<InvoicesWhereInput>
    ID?: IntFilter | number
    InvoiceDate?: DateTimeFilter | Date | string
    Number?: IntNullableFilter | number | null
    CustomerID?: IntFilter | number
    TotalAmount?: FloatFilter | number
    PaidDate?: DateTimeNullableFilter | Date | string | null
    CheckNumber?: StringNullableFilter | string | null
    Paid?: BoolNullableFilter | boolean | null
    Printed?: BoolNullableFilter | boolean | null
    Deleted?: BoolNullableFilter | boolean | null
    PaymentType?: StringNullableFilter | string | null
    Consolidated?: BoolNullableFilter | boolean | null
    ConsolidatedID?: IntNullableFilter | number | null
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type InvoicesOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
    Customers?: CustomersOrderByWithRelationAndSearchRelevanceInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: InvoicesOrderByRelevanceInput
  }

  export type InvoicesWhereUniqueInput = {
    ID?: number
  }

  export type InvoicesOrderByWithAggregationInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
    _count?: InvoicesCountOrderByAggregateInput
    _avg?: InvoicesAvgOrderByAggregateInput
    _max?: InvoicesMaxOrderByAggregateInput
    _min?: InvoicesMinOrderByAggregateInput
    _sum?: InvoicesSumOrderByAggregateInput
  }

  export type InvoicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoicesScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    InvoiceDate?: DateTimeWithAggregatesFilter | Date | string
    Number?: IntNullableWithAggregatesFilter | number | null
    CustomerID?: IntWithAggregatesFilter | number
    TotalAmount?: FloatWithAggregatesFilter | number
    PaidDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CheckNumber?: StringNullableWithAggregatesFilter | string | null
    Paid?: BoolNullableWithAggregatesFilter | boolean | null
    Printed?: BoolNullableWithAggregatesFilter | boolean | null
    Deleted?: BoolNullableWithAggregatesFilter | boolean | null
    PaymentType?: StringNullableWithAggregatesFilter | string | null
    Consolidated?: BoolNullableWithAggregatesFilter | boolean | null
    ConsolidatedID?: IntNullableWithAggregatesFilter | number | null
  }

  export type LoadTypesWhereInput = {
    AND?: Enumerable<LoadTypesWhereInput>
    OR?: Enumerable<LoadTypesWhereInput>
    NOT?: Enumerable<LoadTypesWhereInput>
    ID?: IntFilter | number
    Description?: StringFilter | string
    Deleted?: BoolNullableFilter | boolean | null
    SourceID?: IntNullableFilter | number | null
    Notes?: StringNullableFilter | string | null
    CustomerLoadTypes?: CustomerLoadTypesListRelationFilter
    Jobs?: JobsListRelationFilter
    Loads?: LoadsListRelationFilter
    Weeklies?: WeekliesListRelationFilter
  }

  export type LoadTypesOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
    CustomerLoadTypes?: CustomerLoadTypesOrderByRelationAggregateInput
    Jobs?: JobsOrderByRelationAggregateInput
    Loads?: LoadsOrderByRelationAggregateInput
    Weeklies?: WeekliesOrderByRelationAggregateInput
    _relevance?: LoadTypesOrderByRelevanceInput
  }

  export type LoadTypesWhereUniqueInput = {
    ID?: number
  }

  export type LoadTypesOrderByWithAggregationInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
    _count?: LoadTypesCountOrderByAggregateInput
    _avg?: LoadTypesAvgOrderByAggregateInput
    _max?: LoadTypesMaxOrderByAggregateInput
    _min?: LoadTypesMinOrderByAggregateInput
    _sum?: LoadTypesSumOrderByAggregateInput
  }

  export type LoadTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoadTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoadTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoadTypesScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Deleted?: BoolNullableWithAggregatesFilter | boolean | null
    SourceID?: IntNullableWithAggregatesFilter | number | null
    Notes?: StringNullableWithAggregatesFilter | string | null
  }

  export type StatesWhereInput = {
    AND?: Enumerable<StatesWhereInput>
    OR?: Enumerable<StatesWhereInput>
    NOT?: Enumerable<StatesWhereInput>
    ID?: IntFilter | number
    Name?: StringFilter | string
    Abbreviation?: StringFilter | string
    Customers?: CustomersListRelationFilter
    Drivers?: DriversListRelationFilter
  }

  export type StatesOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
    Customers?: CustomersOrderByRelationAggregateInput
    Drivers?: DriversOrderByRelationAggregateInput
    _relevance?: StatesOrderByRelevanceInput
  }

  export type StatesWhereUniqueInput = {
    ID?: number
  }

  export type StatesOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
    _count?: StatesCountOrderByAggregateInput
    _avg?: StatesAvgOrderByAggregateInput
    _max?: StatesMaxOrderByAggregateInput
    _min?: StatesMinOrderByAggregateInput
    _sum?: StatesSumOrderByAggregateInput
  }

  export type StatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<StatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StatesScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Abbreviation?: StringWithAggregatesFilter | string
  }

  export type TrucksWhereInput = {
    AND?: Enumerable<TrucksWhereInput>
    OR?: Enumerable<TrucksWhereInput>
    NOT?: Enumerable<TrucksWhereInput>
    ID?: IntFilter | number
    Name?: StringFilter | string
    VIN?: StringNullableFilter | string | null
    Deleted?: BoolNullableFilter | boolean | null
    Notes?: StringNullableFilter | string | null
    Loads?: LoadsListRelationFilter
    TrucksDriven?: TrucksDrivenListRelationFilter
  }

  export type TrucksOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
    Loads?: LoadsOrderByRelationAggregateInput
    TrucksDriven?: TrucksDrivenOrderByRelationAggregateInput
    _relevance?: TrucksOrderByRelevanceInput
  }

  export type TrucksWhereUniqueInput = {
    ID?: number
  }

  export type TrucksOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
    _count?: TrucksCountOrderByAggregateInput
    _avg?: TrucksAvgOrderByAggregateInput
    _max?: TrucksMaxOrderByAggregateInput
    _min?: TrucksMinOrderByAggregateInput
    _sum?: TrucksSumOrderByAggregateInput
  }

  export type TrucksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrucksScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrucksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrucksScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    VIN?: StringNullableWithAggregatesFilter | string | null
    Deleted?: BoolNullableWithAggregatesFilter | boolean | null
    Notes?: StringNullableWithAggregatesFilter | string | null
  }

  export type TrucksDrivenWhereInput = {
    AND?: Enumerable<TrucksDrivenWhereInput>
    OR?: Enumerable<TrucksDrivenWhereInput>
    NOT?: Enumerable<TrucksDrivenWhereInput>
    ID?: IntFilter | number
    TruckID?: IntFilter | number
    DriverID?: IntFilter | number
    DateDriven?: DateTimeFilter | Date | string
    Drivers?: XOR<DriversRelationFilter, DriversWhereInput>
    Trucks?: XOR<TrucksRelationFilter, TrucksWhereInput>
  }

  export type TrucksDrivenOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
    Drivers?: DriversOrderByWithRelationAndSearchRelevanceInput
    Trucks?: TrucksOrderByWithRelationAndSearchRelevanceInput
  }

  export type TrucksDrivenWhereUniqueInput = {
    ID?: number
  }

  export type TrucksDrivenOrderByWithAggregationInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
    _count?: TrucksDrivenCountOrderByAggregateInput
    _avg?: TrucksDrivenAvgOrderByAggregateInput
    _max?: TrucksDrivenMaxOrderByAggregateInput
    _min?: TrucksDrivenMinOrderByAggregateInput
    _sum?: TrucksDrivenSumOrderByAggregateInput
  }

  export type TrucksDrivenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrucksDrivenScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrucksDrivenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrucksDrivenScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    TruckID?: IntWithAggregatesFilter | number
    DriverID?: IntWithAggregatesFilter | number
    DateDriven?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LoadsWhereInput = {
    AND?: Enumerable<LoadsWhereInput>
    OR?: Enumerable<LoadsWhereInput>
    NOT?: Enumerable<LoadsWhereInput>
    ID?: IntFilter | number
    StartDate?: DateTimeFilter | Date | string
    Created?: DateTimeFilter | Date | string
    Weight?: FloatNullableFilter | number | null
    Hours?: FloatNullableFilter | number | null
    TotalRate?: FloatNullableFilter | number | null
    TotalAmount?: FloatNullableFilter | number | null
    TruckRate?: FloatNullableFilter | number | null
    MaterialRate?: FloatNullableFilter | number | null
    Received?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    TicketNumber?: IntFilter | number
    Invoiced?: BoolNullableFilter | boolean | null
    CustomerID?: IntFilter | number
    InvoiceID?: IntNullableFilter | number | null
    LoadTypeID?: IntNullableFilter | number | null
    DeliveryLocationID?: IntNullableFilter | number | null
    TruckID?: IntNullableFilter | number | null
    DriverID?: IntNullableFilter | number | null
    Deleted?: BoolNullableFilter | boolean | null
    JobID?: IntNullableFilter | number | null
    Week?: StringFilter | string
    DriverRate?: FloatNullableFilter | number | null
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsRelationFilter, DeliveryLocationsWhereInput> | null
    Drivers?: XOR<DriversRelationFilter, DriversWhereInput> | null
    Invoices?: XOR<InvoicesRelationFilter, InvoicesWhereInput> | null
    Jobs?: XOR<JobsRelationFilter, JobsWhereInput> | null
    LoadTypes?: XOR<LoadTypesRelationFilter, LoadTypesWhereInput> | null
    Trucks?: XOR<TrucksRelationFilter, TrucksWhereInput> | null
  }

  export type LoadsOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
    Customers?: CustomersOrderByWithRelationAndSearchRelevanceInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput
    Drivers?: DriversOrderByWithRelationAndSearchRelevanceInput
    Invoices?: InvoicesOrderByWithRelationAndSearchRelevanceInput
    Jobs?: JobsOrderByWithRelationAndSearchRelevanceInput
    LoadTypes?: LoadTypesOrderByWithRelationAndSearchRelevanceInput
    Trucks?: TrucksOrderByWithRelationAndSearchRelevanceInput
    _relevance?: LoadsOrderByRelevanceInput
  }

  export type LoadsWhereUniqueInput = {
    ID?: number
  }

  export type LoadsOrderByWithAggregationInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
    _count?: LoadsCountOrderByAggregateInput
    _avg?: LoadsAvgOrderByAggregateInput
    _max?: LoadsMaxOrderByAggregateInput
    _min?: LoadsMinOrderByAggregateInput
    _sum?: LoadsSumOrderByAggregateInput
  }

  export type LoadsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoadsScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoadsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoadsScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    StartDate?: DateTimeWithAggregatesFilter | Date | string
    Created?: DateTimeWithAggregatesFilter | Date | string
    Weight?: FloatNullableWithAggregatesFilter | number | null
    Hours?: FloatNullableWithAggregatesFilter | number | null
    TotalRate?: FloatNullableWithAggregatesFilter | number | null
    TotalAmount?: FloatNullableWithAggregatesFilter | number | null
    TruckRate?: FloatNullableWithAggregatesFilter | number | null
    MaterialRate?: FloatNullableWithAggregatesFilter | number | null
    Received?: StringNullableWithAggregatesFilter | string | null
    Notes?: StringNullableWithAggregatesFilter | string | null
    TicketNumber?: IntWithAggregatesFilter | number
    Invoiced?: BoolNullableWithAggregatesFilter | boolean | null
    CustomerID?: IntWithAggregatesFilter | number
    InvoiceID?: IntNullableWithAggregatesFilter | number | null
    LoadTypeID?: IntNullableWithAggregatesFilter | number | null
    DeliveryLocationID?: IntNullableWithAggregatesFilter | number | null
    TruckID?: IntNullableWithAggregatesFilter | number | null
    DriverID?: IntNullableWithAggregatesFilter | number | null
    Deleted?: BoolNullableWithAggregatesFilter | boolean | null
    JobID?: IntNullableWithAggregatesFilter | number | null
    Week?: StringWithAggregatesFilter | string
    DriverRate?: FloatNullableWithAggregatesFilter | number | null
  }

  export type CustomerDeliveryLocationsWhereInput = {
    AND?: Enumerable<CustomerDeliveryLocationsWhereInput>
    OR?: Enumerable<CustomerDeliveryLocationsWhereInput>
    NOT?: Enumerable<CustomerDeliveryLocationsWhereInput>
    ID?: IntFilter | number
    CustomerID?: IntFilter | number
    DeliveryLocationID?: IntFilter | number
    DateUsed?: DateTimeFilter | Date | string
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsRelationFilter, DeliveryLocationsWhereInput>
  }

  export type CustomerDeliveryLocationsOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
    Customers?: CustomersOrderByWithRelationAndSearchRelevanceInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput
  }

  export type CustomerDeliveryLocationsWhereUniqueInput = {
    ID?: number
  }

  export type CustomerDeliveryLocationsOrderByWithAggregationInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
    _count?: CustomerDeliveryLocationsCountOrderByAggregateInput
    _avg?: CustomerDeliveryLocationsAvgOrderByAggregateInput
    _max?: CustomerDeliveryLocationsMaxOrderByAggregateInput
    _min?: CustomerDeliveryLocationsMinOrderByAggregateInput
    _sum?: CustomerDeliveryLocationsSumOrderByAggregateInput
  }

  export type CustomerDeliveryLocationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerDeliveryLocationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerDeliveryLocationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerDeliveryLocationsScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    CustomerID?: IntWithAggregatesFilter | number
    DeliveryLocationID?: IntWithAggregatesFilter | number
    DateUsed?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DailiesWhereInput = {
    AND?: Enumerable<DailiesWhereInput>
    OR?: Enumerable<DailiesWhereInput>
    NOT?: Enumerable<DailiesWhereInput>
    ID?: IntFilter | number
    DriverID?: IntFilter | number
    Week?: StringFilter | string
    LastPrinted?: DateTimeNullableFilter | Date | string | null
    Drivers?: XOR<DriversRelationFilter, DriversWhereInput>
    Jobs?: JobsListRelationFilter
  }

  export type DailiesOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
    Drivers?: DriversOrderByWithRelationAndSearchRelevanceInput
    Jobs?: JobsOrderByRelationAggregateInput
    _relevance?: DailiesOrderByRelevanceInput
  }

  export type DailiesWhereUniqueInput = {
    ID?: number
  }

  export type DailiesOrderByWithAggregationInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
    _count?: DailiesCountOrderByAggregateInput
    _avg?: DailiesAvgOrderByAggregateInput
    _max?: DailiesMaxOrderByAggregateInput
    _min?: DailiesMinOrderByAggregateInput
    _sum?: DailiesSumOrderByAggregateInput
  }

  export type DailiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailiesScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    DriverID?: IntWithAggregatesFilter | number
    Week?: StringWithAggregatesFilter | string
    LastPrinted?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type JobsWhereInput = {
    AND?: Enumerable<JobsWhereInput>
    OR?: Enumerable<JobsWhereInput>
    NOT?: Enumerable<JobsWhereInput>
    ID?: IntFilter | number
    DriverID?: IntFilter | number
    LoadTypeID?: IntFilter | number
    CustomerID?: IntFilter | number
    PaidOut?: BoolFilter | boolean
    TruckingRevenue?: FloatNullableFilter | number | null
    CompanyRevenue?: FloatNullableFilter | number | null
    TruckingRate?: FloatFilter | number
    CompanyRate?: FloatFilter | number
    DeliveryLocationID?: IntFilter | number
    WeeklyID?: IntFilter | number
    DailyID?: IntFilter | number
    MaterialRate?: FloatFilter | number
    DriverRate?: FloatFilter | number
    PayStubID?: IntNullableFilter | number | null
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    Dailies?: XOR<DailiesRelationFilter, DailiesWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsRelationFilter, DeliveryLocationsWhereInput>
    Drivers?: XOR<DriversRelationFilter, DriversWhereInput>
    LoadTypes?: XOR<LoadTypesRelationFilter, LoadTypesWhereInput>
    PayStubs?: XOR<PayStubsRelationFilter, PayStubsWhereInput> | null
    Weeklies?: XOR<WeekliesRelationFilter, WeekliesWhereInput>
    Loads?: LoadsListRelationFilter
  }

  export type JobsOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
    Customers?: CustomersOrderByWithRelationAndSearchRelevanceInput
    Dailies?: DailiesOrderByWithRelationAndSearchRelevanceInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput
    Drivers?: DriversOrderByWithRelationAndSearchRelevanceInput
    LoadTypes?: LoadTypesOrderByWithRelationAndSearchRelevanceInput
    PayStubs?: PayStubsOrderByWithRelationAndSearchRelevanceInput
    Weeklies?: WeekliesOrderByWithRelationAndSearchRelevanceInput
    Loads?: LoadsOrderByRelationAggregateInput
  }

  export type JobsWhereUniqueInput = {
    ID?: number
  }

  export type JobsOrderByWithAggregationInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
    _count?: JobsCountOrderByAggregateInput
    _avg?: JobsAvgOrderByAggregateInput
    _max?: JobsMaxOrderByAggregateInput
    _min?: JobsMinOrderByAggregateInput
    _sum?: JobsSumOrderByAggregateInput
  }

  export type JobsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobsScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobsScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    DriverID?: IntWithAggregatesFilter | number
    LoadTypeID?: IntWithAggregatesFilter | number
    CustomerID?: IntWithAggregatesFilter | number
    PaidOut?: BoolWithAggregatesFilter | boolean
    TruckingRevenue?: FloatNullableWithAggregatesFilter | number | null
    CompanyRevenue?: FloatNullableWithAggregatesFilter | number | null
    TruckingRate?: FloatWithAggregatesFilter | number
    CompanyRate?: FloatWithAggregatesFilter | number
    DeliveryLocationID?: IntWithAggregatesFilter | number
    WeeklyID?: IntWithAggregatesFilter | number
    DailyID?: IntWithAggregatesFilter | number
    MaterialRate?: FloatWithAggregatesFilter | number
    DriverRate?: FloatWithAggregatesFilter | number
    PayStubID?: IntNullableWithAggregatesFilter | number | null
  }

  export type WeekliesWhereInput = {
    AND?: Enumerable<WeekliesWhereInput>
    OR?: Enumerable<WeekliesWhereInput>
    NOT?: Enumerable<WeekliesWhereInput>
    ID?: IntFilter | number
    Week?: StringFilter | string
    CustomerID?: IntFilter | number
    InvoiceID?: IntNullableFilter | number | null
    CompanyRate?: FloatNullableFilter | number | null
    Revenue?: FloatNullableFilter | number | null
    LoadTypeID?: IntFilter | number
    DeliveryLocationID?: IntFilter | number
    LastPrinted?: DateTimeNullableFilter | Date | string | null
    TotalWeight?: FloatNullableFilter | number | null
    Customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    DeliveryLocations?: XOR<DeliveryLocationsRelationFilter, DeliveryLocationsWhereInput>
    Invoices?: XOR<InvoicesRelationFilter, InvoicesWhereInput> | null
    LoadTypes?: XOR<LoadTypesRelationFilter, LoadTypesWhereInput>
    Jobs?: JobsListRelationFilter
  }

  export type WeekliesOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
    Customers?: CustomersOrderByWithRelationAndSearchRelevanceInput
    DeliveryLocations?: DeliveryLocationsOrderByWithRelationAndSearchRelevanceInput
    Invoices?: InvoicesOrderByWithRelationAndSearchRelevanceInput
    LoadTypes?: LoadTypesOrderByWithRelationAndSearchRelevanceInput
    Jobs?: JobsOrderByRelationAggregateInput
    _relevance?: WeekliesOrderByRelevanceInput
  }

  export type WeekliesWhereUniqueInput = {
    ID?: number
  }

  export type WeekliesOrderByWithAggregationInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
    _count?: WeekliesCountOrderByAggregateInput
    _avg?: WeekliesAvgOrderByAggregateInput
    _max?: WeekliesMaxOrderByAggregateInput
    _min?: WeekliesMinOrderByAggregateInput
    _sum?: WeekliesSumOrderByAggregateInput
  }

  export type WeekliesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WeekliesScalarWhereWithAggregatesInput>
    OR?: Enumerable<WeekliesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WeekliesScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    Week?: StringWithAggregatesFilter | string
    CustomerID?: IntWithAggregatesFilter | number
    InvoiceID?: IntNullableWithAggregatesFilter | number | null
    CompanyRate?: FloatNullableWithAggregatesFilter | number | null
    Revenue?: FloatNullableWithAggregatesFilter | number | null
    LoadTypeID?: IntWithAggregatesFilter | number
    DeliveryLocationID?: IntWithAggregatesFilter | number
    LastPrinted?: DateTimeNullableWithAggregatesFilter | Date | string | null
    TotalWeight?: FloatNullableWithAggregatesFilter | number | null
  }

  export type PayStubsWhereInput = {
    AND?: Enumerable<PayStubsWhereInput>
    OR?: Enumerable<PayStubsWhereInput>
    NOT?: Enumerable<PayStubsWhereInput>
    ID?: IntFilter | number
    Created?: DateTimeFilter | Date | string
    DriverID?: IntFilter | number
    CheckNumber?: StringFilter | string
    Gross?: FloatFilter | number
    Percentage?: FloatFilter | number
    NetTotal?: FloatFilter | number
    LastPrinted?: DateTimeNullableFilter | Date | string | null
    TakeHome?: FloatFilter | number
    Deductions?: FloatFilter | number
    Additions?: FloatFilter | number
    Notes?: StringNullableFilter | string | null
    DepositDate?: DateTimeNullableFilter | Date | string | null
    Drivers?: XOR<DriversRelationFilter, DriversWhereInput>
    Jobs?: JobsListRelationFilter
  }

  export type PayStubsOrderByWithRelationAndSearchRelevanceInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
    Drivers?: DriversOrderByWithRelationAndSearchRelevanceInput
    Jobs?: JobsOrderByRelationAggregateInput
    _relevance?: PayStubsOrderByRelevanceInput
  }

  export type PayStubsWhereUniqueInput = {
    ID?: number
  }

  export type PayStubsOrderByWithAggregationInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
    _count?: PayStubsCountOrderByAggregateInput
    _avg?: PayStubsAvgOrderByAggregateInput
    _max?: PayStubsMaxOrderByAggregateInput
    _min?: PayStubsMinOrderByAggregateInput
    _sum?: PayStubsSumOrderByAggregateInput
  }

  export type PayStubsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PayStubsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PayStubsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PayStubsScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter | number
    Created?: DateTimeWithAggregatesFilter | Date | string
    DriverID?: IntWithAggregatesFilter | number
    CheckNumber?: StringWithAggregatesFilter | string
    Gross?: FloatWithAggregatesFilter | number
    Percentage?: FloatWithAggregatesFilter | number
    NetTotal?: FloatWithAggregatesFilter | number
    LastPrinted?: DateTimeNullableWithAggregatesFilter | Date | string | null
    TakeHome?: FloatWithAggregatesFilter | number
    Deductions?: FloatWithAggregatesFilter | number
    Additions?: FloatWithAggregatesFilter | number
    Notes?: StringNullableWithAggregatesFilter | string | null
    DepositDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserCreateInput = {
    email: string
    organization: string
    password: string
    username: string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    organization: string
    password: string
    username: string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    organization: string
    password: string
    username: string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerLoadTypesCreateInput = {
    DateDelivered: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerLoadTypesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutCustomerLoadTypesInput
  }

  export type CustomerLoadTypesUncheckedCreateInput = {
    ID?: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesUpdateInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
  }

  export type CustomerLoadTypesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesCreateManyInput = {
    ID?: number
    CustomerID: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesUpdateManyMutationInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersCreateInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersCreateManyInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
  }

  export type CustomersUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CustomersUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeliveryLocationsCreateInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUpdateInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsCreateManyInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
  }

  export type DeliveryLocationsUpdateManyMutationInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeliveryLocationsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DriversCreateInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversUpdateInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type DriversCreateManyInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
  }

  export type DriversUpdateManyMutationInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DriversUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicesCreateInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Customers: CustomersCreateNestedOneWithoutInvoicesInput
    Loads?: LoadsCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUpdateInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutInvoicesNestedInput
    Loads?: LoadsUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesCreateManyInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
  }

  export type InvoicesUpdateManyMutationInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InvoicesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadTypesCreateInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUpdateInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesCreateManyInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
  }

  export type LoadTypesUpdateManyMutationInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoadTypesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StatesCreateInput = {
    Name: string
    Abbreviation: string
    Customers?: CustomersCreateNestedManyWithoutStatesInput
    Drivers?: DriversCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateInput = {
    ID?: number
    Name: string
    Abbreviation: string
    Customers?: CustomersUncheckedCreateNestedManyWithoutStatesInput
    Drivers?: DriversUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUpdateManyWithoutStatesNestedInput
    Drivers?: DriversUpdateManyWithoutStatesNestedInput
  }

  export type StatesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUncheckedUpdateManyWithoutStatesNestedInput
    Drivers?: DriversUncheckedUpdateManyWithoutStatesNestedInput
  }

  export type StatesCreateManyInput = {
    ID?: number
    Name: string
    Abbreviation: string
  }

  export type StatesUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type StatesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type TrucksCreateInput = {
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsCreateNestedManyWithoutTrucksInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUncheckedCreateInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutTrucksInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUpdateManyWithoutTrucksNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUncheckedUpdateManyWithoutTrucksNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksCreateManyInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
  }

  export type TrucksUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrucksUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrucksDrivenCreateInput = {
    DateDriven: Date | string
    Drivers: DriversCreateNestedOneWithoutTrucksDrivenInput
    Trucks: TrucksCreateNestedOneWithoutTrucksDrivenInput
  }

  export type TrucksDrivenUncheckedCreateInput = {
    ID?: number
    TruckID: number
    DriverID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenUpdateInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
    Drivers?: DriversUpdateOneRequiredWithoutTrucksDrivenNestedInput
    Trucks?: TrucksUpdateOneRequiredWithoutTrucksDrivenNestedInput
  }

  export type TrucksDrivenUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrucksDrivenCreateManyInput = {
    ID?: number
    TruckID: number
    DriverID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenUpdateManyMutationInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrucksDrivenUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoadsCreateInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsUpdateInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsCreateManyInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsUpdateManyMutationInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerDeliveryLocationsCreateInput = {
    DateUsed: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerDeliveryLocationsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutCustomerDeliveryLocationsInput
  }

  export type CustomerDeliveryLocationsUncheckedCreateInput = {
    ID?: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsUpdateInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
  }

  export type CustomerDeliveryLocationsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeliveryLocationsCreateManyInput = {
    ID?: number
    CustomerID: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsUpdateManyMutationInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailiesCreateInput = {
    Week: string
    LastPrinted?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutDailiesInput
    Jobs?: JobsCreateNestedManyWithoutDailiesInput
  }

  export type DailiesUncheckedCreateInput = {
    ID?: number
    DriverID: number
    Week: string
    LastPrinted?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutDailiesInput
  }

  export type DailiesUpdateInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutDailiesNestedInput
    Jobs?: JobsUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesCreateManyInput = {
    ID?: number
    DriverID: number
    Week: string
    LastPrinted?: Date | string | null
  }

  export type DailiesUpdateManyMutationInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailiesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobsCreateInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsUpdateInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsCreateManyInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsUpdateManyMutationInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
  }

  export type JobsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeekliesCreateInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUpdateInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesCreateManyInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type WeekliesUpdateManyMutationInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PayStubsCreateInput = {
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutPayStubsInput
    Jobs?: JobsCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsUncheckedCreateInput = {
    ID?: number
    Created?: Date | string
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsUpdateInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutPayStubsNestedInput
    Jobs?: JobsUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverID?: IntFieldUpdateOperationsInput | number
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsCreateManyInput = {
    ID?: number
    Created?: Date | string
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
  }

  export type PayStubsUpdateManyMutationInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayStubsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverID?: IntFieldUpdateOperationsInput | number
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type UserOrderByRelevanceInput = {
    fields: Enumerable<UserOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organization?: SortOrder
    password?: SortOrder
    username?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CustomersRelationFilter = {
    is?: CustomersWhereInput
    isNot?: CustomersWhereInput
  }

  export type LoadTypesRelationFilter = {
    is?: LoadTypesWhereInput
    isNot?: LoadTypesWhereInput
  }

  export type CustomerLoadTypesCountOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
  }

  export type CustomerLoadTypesAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
  }

  export type CustomerLoadTypesMaxOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
  }

  export type CustomerLoadTypesMinOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
    DateDelivered?: SortOrder
  }

  export type CustomerLoadTypesSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    LoadTypeID?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type StatesRelationFilter = {
    is?: StatesWhereInput | null
    isNot?: StatesWhereInput | null
  }

  export type CustomerDeliveryLocationsListRelationFilter = {
    every?: CustomerDeliveryLocationsWhereInput
    some?: CustomerDeliveryLocationsWhereInput
    none?: CustomerDeliveryLocationsWhereInput
  }

  export type CustomerLoadTypesListRelationFilter = {
    every?: CustomerLoadTypesWhereInput
    some?: CustomerLoadTypesWhereInput
    none?: CustomerLoadTypesWhereInput
  }

  export type DeliveryLocationsListRelationFilter = {
    every?: DeliveryLocationsWhereInput
    some?: DeliveryLocationsWhereInput
    none?: DeliveryLocationsWhereInput
  }

  export type InvoicesListRelationFilter = {
    every?: InvoicesWhereInput
    some?: InvoicesWhereInput
    none?: InvoicesWhereInput
  }

  export type JobsListRelationFilter = {
    every?: JobsWhereInput
    some?: JobsWhereInput
    none?: JobsWhereInput
  }

  export type LoadsListRelationFilter = {
    every?: LoadsWhereInput
    some?: LoadsWhereInput
    none?: LoadsWhereInput
  }

  export type WeekliesListRelationFilter = {
    every?: WeekliesWhereInput
    some?: WeekliesWhereInput
    none?: WeekliesWhereInput
  }

  export type CustomerDeliveryLocationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerLoadTypesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryLocationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoadsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeekliesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersOrderByRelevanceInput = {
    fields: Enumerable<CustomersOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CustomersCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    Notes?: SortOrder
    MainContact?: SortOrder
    Deleted?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DeliveryLocationsOrderByRelevanceInput = {
    fields: Enumerable<DeliveryLocationsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type DeliveryLocationsCountOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsMinOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    CustomerID?: SortOrder
  }

  export type DeliveryLocationsSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DailiesListRelationFilter = {
    every?: DailiesWhereInput
    some?: DailiesWhereInput
    none?: DailiesWhereInput
  }

  export type PayStubsListRelationFilter = {
    every?: PayStubsWhereInput
    some?: PayStubsWhereInput
    none?: PayStubsWhereInput
  }

  export type TrucksDrivenListRelationFilter = {
    every?: TrucksDrivenWhereInput
    some?: TrucksDrivenWhereInput
    none?: TrucksDrivenWhereInput
  }

  export type DailiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayStubsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrucksDrivenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriversOrderByRelevanceInput = {
    fields: Enumerable<DriversOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type DriversCountOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
  }

  export type DriversAvgOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type DriversMaxOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
  }

  export type DriversMinOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    ZIP?: SortOrder
    DOB?: SortOrder
    License?: SortOrder
    Email?: SortOrder
    Phone?: SortOrder
    Notes?: SortOrder
    Deleted?: SortOrder
    HireDate?: SortOrder
    OwnerOperator?: SortOrder
  }

  export type DriversSumOrderByAggregateInput = {
    ID?: SortOrder
    State?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type InvoicesOrderByRelevanceInput = {
    fields: Enumerable<InvoicesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type InvoicesCountOrderByAggregateInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesAvgOrderByAggregateInput = {
    ID?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesMaxOrderByAggregateInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesMinOrderByAggregateInput = {
    ID?: SortOrder
    InvoiceDate?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    PaidDate?: SortOrder
    CheckNumber?: SortOrder
    Paid?: SortOrder
    Printed?: SortOrder
    Deleted?: SortOrder
    PaymentType?: SortOrder
    Consolidated?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type InvoicesSumOrderByAggregateInput = {
    ID?: SortOrder
    Number?: SortOrder
    CustomerID?: SortOrder
    TotalAmount?: SortOrder
    ConsolidatedID?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type LoadTypesOrderByRelevanceInput = {
    fields: Enumerable<LoadTypesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LoadTypesCountOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
  }

  export type LoadTypesAvgOrderByAggregateInput = {
    ID?: SortOrder
    SourceID?: SortOrder
  }

  export type LoadTypesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
  }

  export type LoadTypesMinOrderByAggregateInput = {
    ID?: SortOrder
    Description?: SortOrder
    Deleted?: SortOrder
    SourceID?: SortOrder
    Notes?: SortOrder
  }

  export type LoadTypesSumOrderByAggregateInput = {
    ID?: SortOrder
    SourceID?: SortOrder
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type DriversListRelationFilter = {
    every?: DriversWhereInput
    some?: DriversWhereInput
    none?: DriversWhereInput
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriversOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatesOrderByRelevanceInput = {
    fields: Enumerable<StatesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type StatesCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
  }

  export type StatesAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type StatesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
  }

  export type StatesMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Abbreviation?: SortOrder
  }

  export type StatesSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TrucksOrderByRelevanceInput = {
    fields: Enumerable<TrucksOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type TrucksCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
  }

  export type TrucksAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TrucksMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
  }

  export type TrucksMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    VIN?: SortOrder
    Deleted?: SortOrder
    Notes?: SortOrder
  }

  export type TrucksSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type DriversRelationFilter = {
    is?: DriversWhereInput
    isNot?: DriversWhereInput
  }

  export type TrucksRelationFilter = {
    is?: TrucksWhereInput
    isNot?: TrucksWhereInput
  }

  export type TrucksDrivenCountOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
  }

  export type TrucksDrivenAvgOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
  }

  export type TrucksDrivenMaxOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
  }

  export type TrucksDrivenMinOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    DateDriven?: SortOrder
  }

  export type TrucksDrivenSumOrderByAggregateInput = {
    ID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DeliveryLocationsRelationFilter = {
    is?: DeliveryLocationsWhereInput | null
    isNot?: DeliveryLocationsWhereInput | null
  }

  export type InvoicesRelationFilter = {
    is?: InvoicesWhereInput | null
    isNot?: InvoicesWhereInput | null
  }

  export type JobsRelationFilter = {
    is?: JobsWhereInput | null
    isNot?: JobsWhereInput | null
  }

  export type LoadsOrderByRelevanceInput = {
    fields: Enumerable<LoadsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LoadsCountOrderByAggregateInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsAvgOrderByAggregateInput = {
    ID?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    TicketNumber?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    JobID?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsMaxOrderByAggregateInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsMinOrderByAggregateInput = {
    ID?: SortOrder
    StartDate?: SortOrder
    Created?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    Received?: SortOrder
    Notes?: SortOrder
    TicketNumber?: SortOrder
    Invoiced?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    Deleted?: SortOrder
    JobID?: SortOrder
    Week?: SortOrder
    DriverRate?: SortOrder
  }

  export type LoadsSumOrderByAggregateInput = {
    ID?: SortOrder
    Weight?: SortOrder
    Hours?: SortOrder
    TotalRate?: SortOrder
    TotalAmount?: SortOrder
    TruckRate?: SortOrder
    MaterialRate?: SortOrder
    TicketNumber?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TruckID?: SortOrder
    DriverID?: SortOrder
    JobID?: SortOrder
    DriverRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type CustomerDeliveryLocationsCountOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
  }

  export type CustomerDeliveryLocationsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
  }

  export type CustomerDeliveryLocationsMaxOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
  }

  export type CustomerDeliveryLocationsMinOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
    DateUsed?: SortOrder
  }

  export type CustomerDeliveryLocationsSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    DeliveryLocationID?: SortOrder
  }

  export type DailiesOrderByRelevanceInput = {
    fields: Enumerable<DailiesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type DailiesCountOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
  }

  export type DailiesAvgOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
  }

  export type DailiesMaxOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
  }

  export type DailiesMinOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Week?: SortOrder
    LastPrinted?: SortOrder
  }

  export type DailiesSumOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
  }

  export type DailiesRelationFilter = {
    is?: DailiesWhereInput
    isNot?: DailiesWhereInput
  }

  export type PayStubsRelationFilter = {
    is?: PayStubsWhereInput | null
    isNot?: PayStubsWhereInput | null
  }

  export type WeekliesRelationFilter = {
    is?: WeekliesWhereInput
    isNot?: WeekliesWhereInput
  }

  export type JobsCountOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsAvgOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsMaxOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsMinOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    PaidOut?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type JobsSumOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    LoadTypeID?: SortOrder
    CustomerID?: SortOrder
    TruckingRevenue?: SortOrder
    CompanyRevenue?: SortOrder
    TruckingRate?: SortOrder
    CompanyRate?: SortOrder
    DeliveryLocationID?: SortOrder
    WeeklyID?: SortOrder
    DailyID?: SortOrder
    MaterialRate?: SortOrder
    DriverRate?: SortOrder
    PayStubID?: SortOrder
  }

  export type WeekliesOrderByRelevanceInput = {
    fields: Enumerable<WeekliesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type WeekliesCountOrderByAggregateInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesAvgOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesMinOrderByAggregateInput = {
    ID?: SortOrder
    Week?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    LastPrinted?: SortOrder
    TotalWeight?: SortOrder
  }

  export type WeekliesSumOrderByAggregateInput = {
    ID?: SortOrder
    CustomerID?: SortOrder
    InvoiceID?: SortOrder
    CompanyRate?: SortOrder
    Revenue?: SortOrder
    LoadTypeID?: SortOrder
    DeliveryLocationID?: SortOrder
    TotalWeight?: SortOrder
  }

  export type PayStubsOrderByRelevanceInput = {
    fields: Enumerable<PayStubsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PayStubsCountOrderByAggregateInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
  }

  export type PayStubsAvgOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
  }

  export type PayStubsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
  }

  export type PayStubsMinOrderByAggregateInput = {
    ID?: SortOrder
    Created?: SortOrder
    DriverID?: SortOrder
    CheckNumber?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    LastPrinted?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
    Notes?: SortOrder
    DepositDate?: SortOrder
  }

  export type PayStubsSumOrderByAggregateInput = {
    ID?: SortOrder
    DriverID?: SortOrder
    Gross?: SortOrder
    Percentage?: SortOrder
    NetTotal?: SortOrder
    TakeHome?: SortOrder
    Deductions?: SortOrder
    Additions?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomersCreateNestedOneWithoutCustomerLoadTypesInput = {
    create?: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerLoadTypesInput
    connect?: CustomersWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutCustomerLoadTypesInput = {
    create?: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutCustomerLoadTypesInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomersUpdateOneRequiredWithoutCustomerLoadTypesNestedInput = {
    create?: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerLoadTypesInput
    upsert?: CustomersUpsertWithoutCustomerLoadTypesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutCustomerLoadTypesInput, CustomersUncheckedUpdateWithoutCustomerLoadTypesInput>
  }

  export type LoadTypesUpdateOneRequiredWithoutCustomerLoadTypesNestedInput = {
    create?: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutCustomerLoadTypesInput
    upsert?: LoadTypesUpsertWithoutCustomerLoadTypesInput
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<LoadTypesUpdateWithoutCustomerLoadTypesInput, LoadTypesUncheckedUpdateWithoutCustomerLoadTypesInput>
  }

  export type StatesCreateNestedOneWithoutCustomersInput = {
    create?: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StatesCreateOrConnectWithoutCustomersInput
    connect?: StatesWhereUniqueInput
  }

  export type CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutCustomersInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
  }

  export type CustomerLoadTypesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutCustomersInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
  }

  export type DeliveryLocationsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<DeliveryLocationsCreateWithoutCustomersInput>, Enumerable<DeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<DeliveryLocationsCreateOrConnectWithoutCustomersInput>
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: Enumerable<DeliveryLocationsWhereUniqueInput>
  }

  export type InvoicesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<InvoicesCreateWithoutCustomersInput>, Enumerable<InvoicesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<InvoicesCreateOrConnectWithoutCustomersInput>
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    connect?: Enumerable<InvoicesWhereUniqueInput>
  }

  export type JobsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<JobsCreateWithoutCustomersInput>, Enumerable<JobsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutCustomersInput>
    createMany?: JobsCreateManyCustomersInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutCustomersInput>, Enumerable<LoadsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutCustomersInput>
    createMany?: LoadsCreateManyCustomersInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutCustomersInput>, Enumerable<WeekliesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutCustomersInput>
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutCustomersInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
  }

  export type CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutCustomersInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutCustomersInput>
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
  }

  export type DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<DeliveryLocationsCreateWithoutCustomersInput>, Enumerable<DeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<DeliveryLocationsCreateOrConnectWithoutCustomersInput>
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    connect?: Enumerable<DeliveryLocationsWhereUniqueInput>
  }

  export type InvoicesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<InvoicesCreateWithoutCustomersInput>, Enumerable<InvoicesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<InvoicesCreateOrConnectWithoutCustomersInput>
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    connect?: Enumerable<InvoicesWhereUniqueInput>
  }

  export type JobsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<JobsCreateWithoutCustomersInput>, Enumerable<JobsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutCustomersInput>
    createMany?: JobsCreateManyCustomersInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutCustomersInput>, Enumerable<LoadsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutCustomersInput>
    createMany?: LoadsCreateManyCustomersInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutCustomersInput>, Enumerable<WeekliesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutCustomersInput>
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type StatesUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StatesCreateOrConnectWithoutCustomersInput
    upsert?: StatesUpsertWithoutCustomersInput
    connect?: StatesWhereUniqueInput
    update?: XOR<StatesUpdateWithoutCustomersInput, StatesUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutCustomersInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    disconnect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    delete?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    update?: Enumerable<CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerDeliveryLocationsScalarWhereInput>
  }

  export type CustomerLoadTypesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutCustomersInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    disconnect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    delete?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    update?: Enumerable<CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerLoadTypesScalarWhereInput>
  }

  export type DeliveryLocationsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<DeliveryLocationsCreateWithoutCustomersInput>, Enumerable<DeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<DeliveryLocationsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    set?: Enumerable<DeliveryLocationsWhereUniqueInput>
    disconnect?: Enumerable<DeliveryLocationsWhereUniqueInput>
    delete?: Enumerable<DeliveryLocationsWhereUniqueInput>
    connect?: Enumerable<DeliveryLocationsWhereUniqueInput>
    update?: Enumerable<DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<DeliveryLocationsScalarWhereInput>
  }

  export type InvoicesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<InvoicesCreateWithoutCustomersInput>, Enumerable<InvoicesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<InvoicesCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<InvoicesUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    set?: Enumerable<InvoicesWhereUniqueInput>
    disconnect?: Enumerable<InvoicesWhereUniqueInput>
    delete?: Enumerable<InvoicesWhereUniqueInput>
    connect?: Enumerable<InvoicesWhereUniqueInput>
    update?: Enumerable<InvoicesUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<InvoicesUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<InvoicesScalarWhereInput>
  }

  export type JobsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutCustomersInput>, Enumerable<JobsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: JobsCreateManyCustomersInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutCustomersInput>, Enumerable<LoadsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: LoadsCreateManyCustomersInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutCustomersInput>, Enumerable<WeekliesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutCustomersInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerDeliveryLocationsCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    disconnect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    delete?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    update?: Enumerable<CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerDeliveryLocationsScalarWhereInput>
  }

  export type CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutCustomersInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: CustomerLoadTypesCreateManyCustomersInputEnvelope
    set?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    disconnect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    delete?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    update?: Enumerable<CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<CustomerLoadTypesScalarWhereInput>
  }

  export type DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<DeliveryLocationsCreateWithoutCustomersInput>, Enumerable<DeliveryLocationsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<DeliveryLocationsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: DeliveryLocationsCreateManyCustomersInputEnvelope
    set?: Enumerable<DeliveryLocationsWhereUniqueInput>
    disconnect?: Enumerable<DeliveryLocationsWhereUniqueInput>
    delete?: Enumerable<DeliveryLocationsWhereUniqueInput>
    connect?: Enumerable<DeliveryLocationsWhereUniqueInput>
    update?: Enumerable<DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<DeliveryLocationsScalarWhereInput>
  }

  export type InvoicesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<InvoicesCreateWithoutCustomersInput>, Enumerable<InvoicesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<InvoicesCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<InvoicesUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: InvoicesCreateManyCustomersInputEnvelope
    set?: Enumerable<InvoicesWhereUniqueInput>
    disconnect?: Enumerable<InvoicesWhereUniqueInput>
    delete?: Enumerable<InvoicesWhereUniqueInput>
    connect?: Enumerable<InvoicesWhereUniqueInput>
    update?: Enumerable<InvoicesUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<InvoicesUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<InvoicesScalarWhereInput>
  }

  export type JobsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutCustomersInput>, Enumerable<JobsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: JobsCreateManyCustomersInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutCustomersInput>, Enumerable<LoadsUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: LoadsCreateManyCustomersInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutCustomersInput>, Enumerable<WeekliesUncheckedCreateWithoutCustomersInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutCustomersInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutCustomersInput>
    createMany?: WeekliesCreateManyCustomersInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutCustomersInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutCustomersInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type CustomersCreateNestedOneWithoutDeliveryLocationsInput = {
    create?: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutDeliveryLocationsInput
    connect?: CustomersWhereUniqueInput
  }

  export type CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
  }

  export type JobsCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDeliveryLocationsInput>, Enumerable<JobsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDeliveryLocationsInput>, Enumerable<LoadsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutDeliveryLocationsInput>, Enumerable<WeekliesUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
  }

  export type JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDeliveryLocationsInput>, Enumerable<JobsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDeliveryLocationsInput>, Enumerable<LoadsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutDeliveryLocationsInput>, Enumerable<WeekliesUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutDeliveryLocationsInput>
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type CustomersUpdateOneWithoutDeliveryLocationsNestedInput = {
    create?: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutDeliveryLocationsInput
    upsert?: CustomersUpsertWithoutDeliveryLocationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutDeliveryLocationsInput, CustomersUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    disconnect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    delete?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    update?: Enumerable<CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<CustomerDeliveryLocationsScalarWhereInput>
  }

  export type JobsUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDeliveryLocationsInput>, Enumerable<JobsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDeliveryLocationsInput>, Enumerable<LoadsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutDeliveryLocationsInput>, Enumerable<WeekliesUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput>, Enumerable<CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    disconnect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    delete?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    connect?: Enumerable<CustomerDeliveryLocationsWhereUniqueInput>
    update?: Enumerable<CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<CustomerDeliveryLocationsScalarWhereInput>
  }

  export type JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDeliveryLocationsInput>, Enumerable<JobsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: JobsCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDeliveryLocationsInput>, Enumerable<LoadsUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: LoadsCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutDeliveryLocationsInput>, Enumerable<WeekliesUncheckedCreateWithoutDeliveryLocationsInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutDeliveryLocationsInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput>
    createMany?: WeekliesCreateManyDeliveryLocationsInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type StatesCreateNestedOneWithoutDriversInput = {
    create?: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
    connectOrCreate?: StatesCreateOrConnectWithoutDriversInput
    connect?: StatesWhereUniqueInput
  }

  export type DailiesCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<DailiesCreateWithoutDriversInput>, Enumerable<DailiesUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<DailiesCreateOrConnectWithoutDriversInput>
    createMany?: DailiesCreateManyDriversInputEnvelope
    connect?: Enumerable<DailiesWhereUniqueInput>
  }

  export type JobsCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDriversInput>, Enumerable<JobsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDriversInput>
    createMany?: JobsCreateManyDriversInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDriversInput>, Enumerable<LoadsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDriversInput>
    createMany?: LoadsCreateManyDriversInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type PayStubsCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<PayStubsCreateWithoutDriversInput>, Enumerable<PayStubsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<PayStubsCreateOrConnectWithoutDriversInput>
    createMany?: PayStubsCreateManyDriversInputEnvelope
    connect?: Enumerable<PayStubsWhereUniqueInput>
  }

  export type TrucksDrivenCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutDriversInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutDriversInput>
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
  }

  export type DailiesUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<DailiesCreateWithoutDriversInput>, Enumerable<DailiesUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<DailiesCreateOrConnectWithoutDriversInput>
    createMany?: DailiesCreateManyDriversInputEnvelope
    connect?: Enumerable<DailiesWhereUniqueInput>
  }

  export type JobsUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDriversInput>, Enumerable<JobsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDriversInput>
    createMany?: JobsCreateManyDriversInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDriversInput>, Enumerable<LoadsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDriversInput>
    createMany?: LoadsCreateManyDriversInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type PayStubsUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<PayStubsCreateWithoutDriversInput>, Enumerable<PayStubsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<PayStubsCreateOrConnectWithoutDriversInput>
    createMany?: PayStubsCreateManyDriversInputEnvelope
    connect?: Enumerable<PayStubsWhereUniqueInput>
  }

  export type TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutDriversInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutDriversInput>
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StatesUpdateOneWithoutDriversNestedInput = {
    create?: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
    connectOrCreate?: StatesCreateOrConnectWithoutDriversInput
    upsert?: StatesUpsertWithoutDriversInput
    disconnect?: boolean
    delete?: boolean
    connect?: StatesWhereUniqueInput
    update?: XOR<StatesUpdateWithoutDriversInput, StatesUncheckedUpdateWithoutDriversInput>
  }

  export type DailiesUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<DailiesCreateWithoutDriversInput>, Enumerable<DailiesUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<DailiesCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<DailiesUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: DailiesCreateManyDriversInputEnvelope
    set?: Enumerable<DailiesWhereUniqueInput>
    disconnect?: Enumerable<DailiesWhereUniqueInput>
    delete?: Enumerable<DailiesWhereUniqueInput>
    connect?: Enumerable<DailiesWhereUniqueInput>
    update?: Enumerable<DailiesUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<DailiesUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<DailiesScalarWhereInput>
  }

  export type JobsUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDriversInput>, Enumerable<JobsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: JobsCreateManyDriversInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDriversInput>, Enumerable<LoadsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: LoadsCreateManyDriversInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type PayStubsUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<PayStubsCreateWithoutDriversInput>, Enumerable<PayStubsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<PayStubsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<PayStubsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: PayStubsCreateManyDriversInputEnvelope
    set?: Enumerable<PayStubsWhereUniqueInput>
    disconnect?: Enumerable<PayStubsWhereUniqueInput>
    delete?: Enumerable<PayStubsWhereUniqueInput>
    connect?: Enumerable<PayStubsWhereUniqueInput>
    update?: Enumerable<PayStubsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<PayStubsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<PayStubsScalarWhereInput>
  }

  export type TrucksDrivenUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutDriversInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    set?: Enumerable<TrucksDrivenWhereUniqueInput>
    disconnect?: Enumerable<TrucksDrivenWhereUniqueInput>
    delete?: Enumerable<TrucksDrivenWhereUniqueInput>
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
    update?: Enumerable<TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<TrucksDrivenUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<TrucksDrivenScalarWhereInput>
  }

  export type DailiesUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<DailiesCreateWithoutDriversInput>, Enumerable<DailiesUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<DailiesCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<DailiesUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: DailiesCreateManyDriversInputEnvelope
    set?: Enumerable<DailiesWhereUniqueInput>
    disconnect?: Enumerable<DailiesWhereUniqueInput>
    delete?: Enumerable<DailiesWhereUniqueInput>
    connect?: Enumerable<DailiesWhereUniqueInput>
    update?: Enumerable<DailiesUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<DailiesUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<DailiesScalarWhereInput>
  }

  export type JobsUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDriversInput>, Enumerable<JobsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: JobsCreateManyDriversInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutDriversInput>, Enumerable<LoadsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: LoadsCreateManyDriversInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type PayStubsUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<PayStubsCreateWithoutDriversInput>, Enumerable<PayStubsUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<PayStubsCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<PayStubsUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: PayStubsCreateManyDriversInputEnvelope
    set?: Enumerable<PayStubsWhereUniqueInput>
    disconnect?: Enumerable<PayStubsWhereUniqueInput>
    delete?: Enumerable<PayStubsWhereUniqueInput>
    connect?: Enumerable<PayStubsWhereUniqueInput>
    update?: Enumerable<PayStubsUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<PayStubsUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<PayStubsScalarWhereInput>
  }

  export type TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutDriversInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutDriversInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutDriversInput>
    upsert?: Enumerable<TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput>
    createMany?: TrucksDrivenCreateManyDriversInputEnvelope
    set?: Enumerable<TrucksDrivenWhereUniqueInput>
    disconnect?: Enumerable<TrucksDrivenWhereUniqueInput>
    delete?: Enumerable<TrucksDrivenWhereUniqueInput>
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
    update?: Enumerable<TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput>
    updateMany?: Enumerable<TrucksDrivenUpdateManyWithWhereWithoutDriversInput>
    deleteMany?: Enumerable<TrucksDrivenScalarWhereInput>
  }

  export type CustomersCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutInvoicesInput
    connect?: CustomersWhereUniqueInput
  }

  export type LoadsCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutInvoicesInput>, Enumerable<LoadsUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutInvoicesInput>
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutInvoicesInput>, Enumerable<WeekliesUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutInvoicesInput>
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type LoadsUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutInvoicesInput>, Enumerable<LoadsUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutInvoicesInput>
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutInvoicesInput>, Enumerable<WeekliesUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutInvoicesInput>
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomersUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutInvoicesInput
    upsert?: CustomersUpsertWithoutInvoicesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutInvoicesInput, CustomersUncheckedUpdateWithoutInvoicesInput>
  }

  export type LoadsUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutInvoicesInput>, Enumerable<LoadsUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutInvoicesInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutInvoicesInput>
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutInvoicesInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutInvoicesInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutInvoicesInput>, Enumerable<WeekliesUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutInvoicesInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutInvoicesInput>
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutInvoicesInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutInvoicesInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type LoadsUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutInvoicesInput>, Enumerable<LoadsUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutInvoicesInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutInvoicesInput>
    createMany?: LoadsCreateManyInvoicesInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutInvoicesInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutInvoicesInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutInvoicesInput>, Enumerable<WeekliesUncheckedCreateWithoutInvoicesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutInvoicesInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutInvoicesInput>
    createMany?: WeekliesCreateManyInvoicesInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutInvoicesInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutInvoicesInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutLoadTypesInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput>
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
  }

  export type JobsCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<JobsCreateWithoutLoadTypesInput>, Enumerable<JobsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutLoadTypesInput>
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutLoadTypesInput>, Enumerable<LoadsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutLoadTypesInput>
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutLoadTypesInput>, Enumerable<WeekliesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutLoadTypesInput>
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutLoadTypesInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput>
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
  }

  export type JobsUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<JobsCreateWithoutLoadTypesInput>, Enumerable<JobsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutLoadTypesInput>
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type LoadsUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutLoadTypesInput>, Enumerable<LoadsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutLoadTypesInput>
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutLoadTypesInput>, Enumerable<WeekliesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutLoadTypesInput>
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    connect?: Enumerable<WeekliesWhereUniqueInput>
  }

  export type CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutLoadTypesInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    set?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    disconnect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    delete?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    update?: Enumerable<CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<CustomerLoadTypesScalarWhereInput>
  }

  export type JobsUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutLoadTypesInput>, Enumerable<JobsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutLoadTypesInput>, Enumerable<LoadsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutLoadTypesInput>, Enumerable<WeekliesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<CustomerLoadTypesCreateWithoutLoadTypesInput>, Enumerable<CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: CustomerLoadTypesCreateManyLoadTypesInputEnvelope
    set?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    disconnect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    delete?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    connect?: Enumerable<CustomerLoadTypesWhereUniqueInput>
    update?: Enumerable<CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<CustomerLoadTypesScalarWhereInput>
  }

  export type JobsUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutLoadTypesInput>, Enumerable<JobsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: JobsCreateManyLoadTypesInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutLoadTypesInput>, Enumerable<LoadsUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: LoadsCreateManyLoadTypesInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput = {
    create?: XOR<Enumerable<WeekliesCreateWithoutLoadTypesInput>, Enumerable<WeekliesUncheckedCreateWithoutLoadTypesInput>>
    connectOrCreate?: Enumerable<WeekliesCreateOrConnectWithoutLoadTypesInput>
    upsert?: Enumerable<WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput>
    createMany?: WeekliesCreateManyLoadTypesInputEnvelope
    set?: Enumerable<WeekliesWhereUniqueInput>
    disconnect?: Enumerable<WeekliesWhereUniqueInput>
    delete?: Enumerable<WeekliesWhereUniqueInput>
    connect?: Enumerable<WeekliesWhereUniqueInput>
    update?: Enumerable<WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput>
    updateMany?: Enumerable<WeekliesUpdateManyWithWhereWithoutLoadTypesInput>
    deleteMany?: Enumerable<WeekliesScalarWhereInput>
  }

  export type CustomersCreateNestedManyWithoutStatesInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutStatesInput>, Enumerable<CustomersUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutStatesInput>
    createMany?: CustomersCreateManyStatesInputEnvelope
    connect?: Enumerable<CustomersWhereUniqueInput>
  }

  export type DriversCreateNestedManyWithoutStatesInput = {
    create?: XOR<Enumerable<DriversCreateWithoutStatesInput>, Enumerable<DriversUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<DriversCreateOrConnectWithoutStatesInput>
    createMany?: DriversCreateManyStatesInputEnvelope
    connect?: Enumerable<DriversWhereUniqueInput>
  }

  export type CustomersUncheckedCreateNestedManyWithoutStatesInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutStatesInput>, Enumerable<CustomersUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutStatesInput>
    createMany?: CustomersCreateManyStatesInputEnvelope
    connect?: Enumerable<CustomersWhereUniqueInput>
  }

  export type DriversUncheckedCreateNestedManyWithoutStatesInput = {
    create?: XOR<Enumerable<DriversCreateWithoutStatesInput>, Enumerable<DriversUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<DriversCreateOrConnectWithoutStatesInput>
    createMany?: DriversCreateManyStatesInputEnvelope
    connect?: Enumerable<DriversWhereUniqueInput>
  }

  export type CustomersUpdateManyWithoutStatesNestedInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutStatesInput>, Enumerable<CustomersUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutStatesInput>
    upsert?: Enumerable<CustomersUpsertWithWhereUniqueWithoutStatesInput>
    createMany?: CustomersCreateManyStatesInputEnvelope
    set?: Enumerable<CustomersWhereUniqueInput>
    disconnect?: Enumerable<CustomersWhereUniqueInput>
    delete?: Enumerable<CustomersWhereUniqueInput>
    connect?: Enumerable<CustomersWhereUniqueInput>
    update?: Enumerable<CustomersUpdateWithWhereUniqueWithoutStatesInput>
    updateMany?: Enumerable<CustomersUpdateManyWithWhereWithoutStatesInput>
    deleteMany?: Enumerable<CustomersScalarWhereInput>
  }

  export type DriversUpdateManyWithoutStatesNestedInput = {
    create?: XOR<Enumerable<DriversCreateWithoutStatesInput>, Enumerable<DriversUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<DriversCreateOrConnectWithoutStatesInput>
    upsert?: Enumerable<DriversUpsertWithWhereUniqueWithoutStatesInput>
    createMany?: DriversCreateManyStatesInputEnvelope
    set?: Enumerable<DriversWhereUniqueInput>
    disconnect?: Enumerable<DriversWhereUniqueInput>
    delete?: Enumerable<DriversWhereUniqueInput>
    connect?: Enumerable<DriversWhereUniqueInput>
    update?: Enumerable<DriversUpdateWithWhereUniqueWithoutStatesInput>
    updateMany?: Enumerable<DriversUpdateManyWithWhereWithoutStatesInput>
    deleteMany?: Enumerable<DriversScalarWhereInput>
  }

  export type CustomersUncheckedUpdateManyWithoutStatesNestedInput = {
    create?: XOR<Enumerable<CustomersCreateWithoutStatesInput>, Enumerable<CustomersUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CustomersCreateOrConnectWithoutStatesInput>
    upsert?: Enumerable<CustomersUpsertWithWhereUniqueWithoutStatesInput>
    createMany?: CustomersCreateManyStatesInputEnvelope
    set?: Enumerable<CustomersWhereUniqueInput>
    disconnect?: Enumerable<CustomersWhereUniqueInput>
    delete?: Enumerable<CustomersWhereUniqueInput>
    connect?: Enumerable<CustomersWhereUniqueInput>
    update?: Enumerable<CustomersUpdateWithWhereUniqueWithoutStatesInput>
    updateMany?: Enumerable<CustomersUpdateManyWithWhereWithoutStatesInput>
    deleteMany?: Enumerable<CustomersScalarWhereInput>
  }

  export type DriversUncheckedUpdateManyWithoutStatesNestedInput = {
    create?: XOR<Enumerable<DriversCreateWithoutStatesInput>, Enumerable<DriversUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<DriversCreateOrConnectWithoutStatesInput>
    upsert?: Enumerable<DriversUpsertWithWhereUniqueWithoutStatesInput>
    createMany?: DriversCreateManyStatesInputEnvelope
    set?: Enumerable<DriversWhereUniqueInput>
    disconnect?: Enumerable<DriversWhereUniqueInput>
    delete?: Enumerable<DriversWhereUniqueInput>
    connect?: Enumerable<DriversWhereUniqueInput>
    update?: Enumerable<DriversUpdateWithWhereUniqueWithoutStatesInput>
    updateMany?: Enumerable<DriversUpdateManyWithWhereWithoutStatesInput>
    deleteMany?: Enumerable<DriversScalarWhereInput>
  }

  export type LoadsCreateNestedManyWithoutTrucksInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutTrucksInput>, Enumerable<LoadsUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutTrucksInput>
    createMany?: LoadsCreateManyTrucksInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type TrucksDrivenCreateNestedManyWithoutTrucksInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutTrucksInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutTrucksInput>
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
  }

  export type LoadsUncheckedCreateNestedManyWithoutTrucksInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutTrucksInput>, Enumerable<LoadsUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutTrucksInput>
    createMany?: LoadsCreateManyTrucksInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type TrucksDrivenUncheckedCreateNestedManyWithoutTrucksInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutTrucksInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutTrucksInput>
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
  }

  export type LoadsUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutTrucksInput>, Enumerable<LoadsUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutTrucksInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutTrucksInput>
    createMany?: LoadsCreateManyTrucksInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutTrucksInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutTrucksInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type TrucksDrivenUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutTrucksInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutTrucksInput>
    upsert?: Enumerable<TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput>
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    set?: Enumerable<TrucksDrivenWhereUniqueInput>
    disconnect?: Enumerable<TrucksDrivenWhereUniqueInput>
    delete?: Enumerable<TrucksDrivenWhereUniqueInput>
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
    update?: Enumerable<TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput>
    updateMany?: Enumerable<TrucksDrivenUpdateManyWithWhereWithoutTrucksInput>
    deleteMany?: Enumerable<TrucksDrivenScalarWhereInput>
  }

  export type LoadsUncheckedUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutTrucksInput>, Enumerable<LoadsUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutTrucksInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutTrucksInput>
    createMany?: LoadsCreateManyTrucksInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutTrucksInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutTrucksInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type TrucksDrivenUncheckedUpdateManyWithoutTrucksNestedInput = {
    create?: XOR<Enumerable<TrucksDrivenCreateWithoutTrucksInput>, Enumerable<TrucksDrivenUncheckedCreateWithoutTrucksInput>>
    connectOrCreate?: Enumerable<TrucksDrivenCreateOrConnectWithoutTrucksInput>
    upsert?: Enumerable<TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput>
    createMany?: TrucksDrivenCreateManyTrucksInputEnvelope
    set?: Enumerable<TrucksDrivenWhereUniqueInput>
    disconnect?: Enumerable<TrucksDrivenWhereUniqueInput>
    delete?: Enumerable<TrucksDrivenWhereUniqueInput>
    connect?: Enumerable<TrucksDrivenWhereUniqueInput>
    update?: Enumerable<TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput>
    updateMany?: Enumerable<TrucksDrivenUpdateManyWithWhereWithoutTrucksInput>
    deleteMany?: Enumerable<TrucksDrivenScalarWhereInput>
  }

  export type DriversCreateNestedOneWithoutTrucksDrivenInput = {
    create?: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: DriversCreateOrConnectWithoutTrucksDrivenInput
    connect?: DriversWhereUniqueInput
  }

  export type TrucksCreateNestedOneWithoutTrucksDrivenInput = {
    create?: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutTrucksDrivenInput
    connect?: TrucksWhereUniqueInput
  }

  export type DriversUpdateOneRequiredWithoutTrucksDrivenNestedInput = {
    create?: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: DriversCreateOrConnectWithoutTrucksDrivenInput
    upsert?: DriversUpsertWithoutTrucksDrivenInput
    connect?: DriversWhereUniqueInput
    update?: XOR<DriversUpdateWithoutTrucksDrivenInput, DriversUncheckedUpdateWithoutTrucksDrivenInput>
  }

  export type TrucksUpdateOneRequiredWithoutTrucksDrivenNestedInput = {
    create?: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutTrucksDrivenInput
    upsert?: TrucksUpsertWithoutTrucksDrivenInput
    connect?: TrucksWhereUniqueInput
    update?: XOR<TrucksUpdateWithoutTrucksDrivenInput, TrucksUncheckedUpdateWithoutTrucksDrivenInput>
  }

  export type CustomersCreateNestedOneWithoutLoadsInput = {
    create?: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutLoadsInput
    connect?: CustomersWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutLoadsInput = {
    create?: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutLoadsInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type DriversCreateNestedOneWithoutLoadsInput = {
    create?: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutLoadsInput
    connect?: DriversWhereUniqueInput
  }

  export type InvoicesCreateNestedOneWithoutLoadsInput = {
    create?: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutLoadsInput
    connect?: InvoicesWhereUniqueInput
  }

  export type JobsCreateNestedOneWithoutLoadsInput = {
    create?: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: JobsCreateOrConnectWithoutLoadsInput
    connect?: JobsWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutLoadsInput = {
    create?: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutLoadsInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type TrucksCreateNestedOneWithoutLoadsInput = {
    create?: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutLoadsInput
    connect?: TrucksWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomersUpdateOneRequiredWithoutLoadsNestedInput = {
    create?: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutLoadsInput
    upsert?: CustomersUpsertWithoutLoadsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutLoadsInput, CustomersUncheckedUpdateWithoutLoadsInput>
  }

  export type DeliveryLocationsUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutLoadsInput
    upsert?: DeliveryLocationsUpsertWithoutLoadsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<DeliveryLocationsUpdateWithoutLoadsInput, DeliveryLocationsUncheckedUpdateWithoutLoadsInput>
  }

  export type DriversUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutLoadsInput
    upsert?: DriversUpsertWithoutLoadsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DriversWhereUniqueInput
    update?: XOR<DriversUpdateWithoutLoadsInput, DriversUncheckedUpdateWithoutLoadsInput>
  }

  export type InvoicesUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutLoadsInput
    upsert?: InvoicesUpsertWithoutLoadsInput
    disconnect?: boolean
    delete?: boolean
    connect?: InvoicesWhereUniqueInput
    update?: XOR<InvoicesUpdateWithoutLoadsInput, InvoicesUncheckedUpdateWithoutLoadsInput>
  }

  export type JobsUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: JobsCreateOrConnectWithoutLoadsInput
    upsert?: JobsUpsertWithoutLoadsInput
    disconnect?: boolean
    delete?: boolean
    connect?: JobsWhereUniqueInput
    update?: XOR<JobsUpdateWithoutLoadsInput, JobsUncheckedUpdateWithoutLoadsInput>
  }

  export type LoadTypesUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutLoadsInput
    upsert?: LoadTypesUpsertWithoutLoadsInput
    disconnect?: boolean
    delete?: boolean
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<LoadTypesUpdateWithoutLoadsInput, LoadTypesUncheckedUpdateWithoutLoadsInput>
  }

  export type TrucksUpdateOneWithoutLoadsNestedInput = {
    create?: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
    connectOrCreate?: TrucksCreateOrConnectWithoutLoadsInput
    upsert?: TrucksUpsertWithoutLoadsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TrucksWhereUniqueInput
    update?: XOR<TrucksUpdateWithoutLoadsInput, TrucksUncheckedUpdateWithoutLoadsInput>
  }

  export type CustomersCreateNestedOneWithoutCustomerDeliveryLocationsInput = {
    create?: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerDeliveryLocationsInput
    connect?: CustomersWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutCustomerDeliveryLocationsInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomerDeliveryLocationsInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type CustomersUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput = {
    create?: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerDeliveryLocationsInput
    upsert?: CustomersUpsertWithoutCustomerDeliveryLocationsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
  }

  export type DeliveryLocationsUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutCustomerDeliveryLocationsInput
    upsert?: DeliveryLocationsUpsertWithoutCustomerDeliveryLocationsInput
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<DeliveryLocationsUpdateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
  }

  export type DriversCreateNestedOneWithoutDailiesInput = {
    create?: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
    connectOrCreate?: DriversCreateOrConnectWithoutDailiesInput
    connect?: DriversWhereUniqueInput
  }

  export type JobsCreateNestedManyWithoutDailiesInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDailiesInput>, Enumerable<JobsUncheckedCreateWithoutDailiesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDailiesInput>
    createMany?: JobsCreateManyDailiesInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type JobsUncheckedCreateNestedManyWithoutDailiesInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDailiesInput>, Enumerable<JobsUncheckedCreateWithoutDailiesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDailiesInput>
    createMany?: JobsCreateManyDailiesInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type DriversUpdateOneRequiredWithoutDailiesNestedInput = {
    create?: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
    connectOrCreate?: DriversCreateOrConnectWithoutDailiesInput
    upsert?: DriversUpsertWithoutDailiesInput
    connect?: DriversWhereUniqueInput
    update?: XOR<DriversUpdateWithoutDailiesInput, DriversUncheckedUpdateWithoutDailiesInput>
  }

  export type JobsUpdateManyWithoutDailiesNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDailiesInput>, Enumerable<JobsUncheckedCreateWithoutDailiesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDailiesInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutDailiesInput>
    createMany?: JobsCreateManyDailiesInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutDailiesInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutDailiesInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type JobsUncheckedUpdateManyWithoutDailiesNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutDailiesInput>, Enumerable<JobsUncheckedCreateWithoutDailiesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutDailiesInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutDailiesInput>
    createMany?: JobsCreateManyDailiesInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutDailiesInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutDailiesInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type CustomersCreateNestedOneWithoutJobsInput = {
    create?: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutJobsInput
    connect?: CustomersWhereUniqueInput
  }

  export type DailiesCreateNestedOneWithoutJobsInput = {
    create?: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DailiesCreateOrConnectWithoutJobsInput
    connect?: DailiesWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutJobsInput = {
    create?: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutJobsInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type DriversCreateNestedOneWithoutJobsInput = {
    create?: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutJobsInput
    connect?: DriversWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutJobsInput = {
    create?: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutJobsInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type PayStubsCreateNestedOneWithoutJobsInput = {
    create?: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayStubsCreateOrConnectWithoutJobsInput
    connect?: PayStubsWhereUniqueInput
  }

  export type WeekliesCreateNestedOneWithoutJobsInput = {
    create?: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: WeekliesCreateOrConnectWithoutJobsInput
    connect?: WeekliesWhereUniqueInput
  }

  export type LoadsCreateNestedManyWithoutJobsInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutJobsInput>, Enumerable<LoadsUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutJobsInput>
    createMany?: LoadsCreateManyJobsInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type LoadsUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutJobsInput>, Enumerable<LoadsUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutJobsInput>
    createMany?: LoadsCreateManyJobsInputEnvelope
    connect?: Enumerable<LoadsWhereUniqueInput>
  }

  export type CustomersUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutJobsInput
    upsert?: CustomersUpsertWithoutJobsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutJobsInput, CustomersUncheckedUpdateWithoutJobsInput>
  }

  export type DailiesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DailiesCreateOrConnectWithoutJobsInput
    upsert?: DailiesUpsertWithoutJobsInput
    connect?: DailiesWhereUniqueInput
    update?: XOR<DailiesUpdateWithoutJobsInput, DailiesUncheckedUpdateWithoutJobsInput>
  }

  export type DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutJobsInput
    upsert?: DeliveryLocationsUpsertWithoutJobsInput
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<DeliveryLocationsUpdateWithoutJobsInput, DeliveryLocationsUncheckedUpdateWithoutJobsInput>
  }

  export type DriversUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutJobsInput
    upsert?: DriversUpsertWithoutJobsInput
    connect?: DriversWhereUniqueInput
    update?: XOR<DriversUpdateWithoutJobsInput, DriversUncheckedUpdateWithoutJobsInput>
  }

  export type LoadTypesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutJobsInput
    upsert?: LoadTypesUpsertWithoutJobsInput
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<LoadTypesUpdateWithoutJobsInput, LoadTypesUncheckedUpdateWithoutJobsInput>
  }

  export type PayStubsUpdateOneWithoutJobsNestedInput = {
    create?: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayStubsCreateOrConnectWithoutJobsInput
    upsert?: PayStubsUpsertWithoutJobsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PayStubsWhereUniqueInput
    update?: XOR<PayStubsUpdateWithoutJobsInput, PayStubsUncheckedUpdateWithoutJobsInput>
  }

  export type WeekliesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: WeekliesCreateOrConnectWithoutJobsInput
    upsert?: WeekliesUpsertWithoutJobsInput
    connect?: WeekliesWhereUniqueInput
    update?: XOR<WeekliesUpdateWithoutJobsInput, WeekliesUncheckedUpdateWithoutJobsInput>
  }

  export type LoadsUpdateManyWithoutJobsNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutJobsInput>, Enumerable<LoadsUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutJobsInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutJobsInput>
    createMany?: LoadsCreateManyJobsInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutJobsInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutJobsInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type LoadsUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<Enumerable<LoadsCreateWithoutJobsInput>, Enumerable<LoadsUncheckedCreateWithoutJobsInput>>
    connectOrCreate?: Enumerable<LoadsCreateOrConnectWithoutJobsInput>
    upsert?: Enumerable<LoadsUpsertWithWhereUniqueWithoutJobsInput>
    createMany?: LoadsCreateManyJobsInputEnvelope
    set?: Enumerable<LoadsWhereUniqueInput>
    disconnect?: Enumerable<LoadsWhereUniqueInput>
    delete?: Enumerable<LoadsWhereUniqueInput>
    connect?: Enumerable<LoadsWhereUniqueInput>
    update?: Enumerable<LoadsUpdateWithWhereUniqueWithoutJobsInput>
    updateMany?: Enumerable<LoadsUpdateManyWithWhereWithoutJobsInput>
    deleteMany?: Enumerable<LoadsScalarWhereInput>
  }

  export type CustomersCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutWeekliesInput
    connect?: CustomersWhereUniqueInput
  }

  export type DeliveryLocationsCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutWeekliesInput
    connect?: DeliveryLocationsWhereUniqueInput
  }

  export type InvoicesCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutWeekliesInput
    connect?: InvoicesWhereUniqueInput
  }

  export type LoadTypesCreateNestedOneWithoutWeekliesInput = {
    create?: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutWeekliesInput
    connect?: LoadTypesWhereUniqueInput
  }

  export type JobsCreateNestedManyWithoutWeekliesInput = {
    create?: XOR<Enumerable<JobsCreateWithoutWeekliesInput>, Enumerable<JobsUncheckedCreateWithoutWeekliesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutWeekliesInput>
    createMany?: JobsCreateManyWeekliesInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type JobsUncheckedCreateNestedManyWithoutWeekliesInput = {
    create?: XOR<Enumerable<JobsCreateWithoutWeekliesInput>, Enumerable<JobsUncheckedCreateWithoutWeekliesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutWeekliesInput>
    createMany?: JobsCreateManyWeekliesInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type CustomersUpdateOneRequiredWithoutWeekliesNestedInput = {
    create?: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutWeekliesInput
    upsert?: CustomersUpsertWithoutWeekliesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutWeekliesInput, CustomersUncheckedUpdateWithoutWeekliesInput>
  }

  export type DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput = {
    create?: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: DeliveryLocationsCreateOrConnectWithoutWeekliesInput
    upsert?: DeliveryLocationsUpsertWithoutWeekliesInput
    connect?: DeliveryLocationsWhereUniqueInput
    update?: XOR<DeliveryLocationsUpdateWithoutWeekliesInput, DeliveryLocationsUncheckedUpdateWithoutWeekliesInput>
  }

  export type InvoicesUpdateOneWithoutWeekliesNestedInput = {
    create?: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutWeekliesInput
    upsert?: InvoicesUpsertWithoutWeekliesInput
    disconnect?: boolean
    delete?: boolean
    connect?: InvoicesWhereUniqueInput
    update?: XOR<InvoicesUpdateWithoutWeekliesInput, InvoicesUncheckedUpdateWithoutWeekliesInput>
  }

  export type LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput = {
    create?: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
    connectOrCreate?: LoadTypesCreateOrConnectWithoutWeekliesInput
    upsert?: LoadTypesUpsertWithoutWeekliesInput
    connect?: LoadTypesWhereUniqueInput
    update?: XOR<LoadTypesUpdateWithoutWeekliesInput, LoadTypesUncheckedUpdateWithoutWeekliesInput>
  }

  export type JobsUpdateManyWithoutWeekliesNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutWeekliesInput>, Enumerable<JobsUncheckedCreateWithoutWeekliesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutWeekliesInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutWeekliesInput>
    createMany?: JobsCreateManyWeekliesInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutWeekliesInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutWeekliesInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type JobsUncheckedUpdateManyWithoutWeekliesNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutWeekliesInput>, Enumerable<JobsUncheckedCreateWithoutWeekliesInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutWeekliesInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutWeekliesInput>
    createMany?: JobsCreateManyWeekliesInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutWeekliesInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutWeekliesInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type DriversCreateNestedOneWithoutPayStubsInput = {
    create?: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutPayStubsInput
    connect?: DriversWhereUniqueInput
  }

  export type JobsCreateNestedManyWithoutPayStubsInput = {
    create?: XOR<Enumerable<JobsCreateWithoutPayStubsInput>, Enumerable<JobsUncheckedCreateWithoutPayStubsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutPayStubsInput>
    createMany?: JobsCreateManyPayStubsInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type JobsUncheckedCreateNestedManyWithoutPayStubsInput = {
    create?: XOR<Enumerable<JobsCreateWithoutPayStubsInput>, Enumerable<JobsUncheckedCreateWithoutPayStubsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutPayStubsInput>
    createMany?: JobsCreateManyPayStubsInputEnvelope
    connect?: Enumerable<JobsWhereUniqueInput>
  }

  export type DriversUpdateOneRequiredWithoutPayStubsNestedInput = {
    create?: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
    connectOrCreate?: DriversCreateOrConnectWithoutPayStubsInput
    upsert?: DriversUpsertWithoutPayStubsInput
    connect?: DriversWhereUniqueInput
    update?: XOR<DriversUpdateWithoutPayStubsInput, DriversUncheckedUpdateWithoutPayStubsInput>
  }

  export type JobsUpdateManyWithoutPayStubsNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutPayStubsInput>, Enumerable<JobsUncheckedCreateWithoutPayStubsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutPayStubsInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutPayStubsInput>
    createMany?: JobsCreateManyPayStubsInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutPayStubsInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutPayStubsInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type JobsUncheckedUpdateManyWithoutPayStubsNestedInput = {
    create?: XOR<Enumerable<JobsCreateWithoutPayStubsInput>, Enumerable<JobsUncheckedCreateWithoutPayStubsInput>>
    connectOrCreate?: Enumerable<JobsCreateOrConnectWithoutPayStubsInput>
    upsert?: Enumerable<JobsUpsertWithWhereUniqueWithoutPayStubsInput>
    createMany?: JobsCreateManyPayStubsInputEnvelope
    set?: Enumerable<JobsWhereUniqueInput>
    disconnect?: Enumerable<JobsWhereUniqueInput>
    delete?: Enumerable<JobsWhereUniqueInput>
    connect?: Enumerable<JobsWhereUniqueInput>
    update?: Enumerable<JobsUpdateWithWhereUniqueWithoutPayStubsInput>
    updateMany?: Enumerable<JobsUpdateManyWithWhereWithoutPayStubsInput>
    deleteMany?: Enumerable<JobsScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type CustomersCreateWithoutCustomerLoadTypesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutCustomerLoadTypesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutCustomerLoadTypesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
  }

  export type LoadTypesCreateWithoutCustomerLoadTypesInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutCustomerLoadTypesInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
  }

  export type CustomersUpsertWithoutCustomerLoadTypesInput = {
    update: XOR<CustomersUpdateWithoutCustomerLoadTypesInput, CustomersUncheckedUpdateWithoutCustomerLoadTypesInput>
    create: XOR<CustomersCreateWithoutCustomerLoadTypesInput, CustomersUncheckedCreateWithoutCustomerLoadTypesInput>
  }

  export type CustomersUpdateWithoutCustomerLoadTypesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type LoadTypesUpsertWithoutCustomerLoadTypesInput = {
    update: XOR<LoadTypesUpdateWithoutCustomerLoadTypesInput, LoadTypesUncheckedUpdateWithoutCustomerLoadTypesInput>
    create: XOR<LoadTypesCreateWithoutCustomerLoadTypesInput, LoadTypesUncheckedCreateWithoutCustomerLoadTypesInput>
  }

  export type LoadTypesUpdateWithoutCustomerLoadTypesInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutCustomerLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type StatesCreateWithoutCustomersInput = {
    Name: string
    Abbreviation: string
    Drivers?: DriversCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    Name: string
    Abbreviation: string
    Drivers?: DriversUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesCreateOrConnectWithoutCustomersInput = {
    where: StatesWhereUniqueInput
    create: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsCreateWithoutCustomersInput = {
    DateUsed: Date | string
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutCustomerDeliveryLocationsInput
  }

  export type CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsCreateOrConnectWithoutCustomersInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    create: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsCreateManyCustomersInputEnvelope = {
    data: Enumerable<CustomerDeliveryLocationsCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type CustomerLoadTypesCreateWithoutCustomersInput = {
    DateDelivered: Date | string
    LoadTypes: LoadTypesCreateNestedOneWithoutCustomerLoadTypesInput
  }

  export type CustomerLoadTypesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesCreateOrConnectWithoutCustomersInput = {
    where: CustomerLoadTypesWhereUniqueInput
    create: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerLoadTypesCreateManyCustomersInputEnvelope = {
    data: Enumerable<CustomerLoadTypesCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type DeliveryLocationsCreateWithoutCustomersInput = {
    Description: string
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutCustomersInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type DeliveryLocationsCreateManyCustomersInputEnvelope = {
    data: Enumerable<DeliveryLocationsCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type InvoicesCreateWithoutCustomersInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutInvoicesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesCreateOrConnectWithoutCustomersInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput>
  }

  export type InvoicesCreateManyCustomersInputEnvelope = {
    data: Enumerable<InvoicesCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutCustomersInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutCustomersInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput>
  }

  export type JobsCreateManyCustomersInputEnvelope = {
    data: Enumerable<JobsCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutCustomersInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutCustomersInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutCustomersInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput>
  }

  export type LoadsCreateManyCustomersInputEnvelope = {
    data: Enumerable<LoadsCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutCustomersInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutCustomersInput = {
    ID?: number
    Week: string
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutCustomersInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput>
  }

  export type WeekliesCreateManyCustomersInputEnvelope = {
    data: Enumerable<WeekliesCreateManyCustomersInput>
    skipDuplicates?: boolean
  }

  export type StatesUpsertWithoutCustomersInput = {
    update: XOR<StatesUpdateWithoutCustomersInput, StatesUncheckedUpdateWithoutCustomersInput>
    create: XOR<StatesCreateWithoutCustomersInput, StatesUncheckedCreateWithoutCustomersInput>
  }

  export type StatesUpdateWithoutCustomersInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Drivers?: DriversUpdateManyWithoutStatesNestedInput
  }

  export type StatesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Drivers?: DriversUncheckedUpdateManyWithoutStatesNestedInput
  }

  export type CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    update: XOR<CustomerDeliveryLocationsUpdateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerDeliveryLocationsCreateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    data: XOR<CustomerDeliveryLocationsUpdateWithoutCustomersInput, CustomerDeliveryLocationsUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerDeliveryLocationsScalarWhereInput
    data: XOR<CustomerDeliveryLocationsUpdateManyMutationInput, CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomerDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsScalarWhereInput = {
    AND?: Enumerable<CustomerDeliveryLocationsScalarWhereInput>
    OR?: Enumerable<CustomerDeliveryLocationsScalarWhereInput>
    NOT?: Enumerable<CustomerDeliveryLocationsScalarWhereInput>
    ID?: IntFilter | number
    CustomerID?: IntFilter | number
    DeliveryLocationID?: IntFilter | number
    DateUsed?: DateTimeFilter | Date | string
  }

  export type CustomerLoadTypesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerLoadTypesWhereUniqueInput
    update: XOR<CustomerLoadTypesUpdateWithoutCustomersInput, CustomerLoadTypesUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerLoadTypesCreateWithoutCustomersInput, CustomerLoadTypesUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerLoadTypesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerLoadTypesWhereUniqueInput
    data: XOR<CustomerLoadTypesUpdateWithoutCustomersInput, CustomerLoadTypesUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerLoadTypesUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerLoadTypesScalarWhereInput
    data: XOR<CustomerLoadTypesUpdateManyMutationInput, CustomerLoadTypesUncheckedUpdateManyWithoutCustomerLoadTypesInput>
  }

  export type CustomerLoadTypesScalarWhereInput = {
    AND?: Enumerable<CustomerLoadTypesScalarWhereInput>
    OR?: Enumerable<CustomerLoadTypesScalarWhereInput>
    NOT?: Enumerable<CustomerLoadTypesScalarWhereInput>
    ID?: IntFilter | number
    CustomerID?: IntFilter | number
    LoadTypeID?: IntFilter | number
    DateDelivered?: DateTimeFilter | Date | string
  }

  export type DeliveryLocationsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: DeliveryLocationsWhereUniqueInput
    update: XOR<DeliveryLocationsUpdateWithoutCustomersInput, DeliveryLocationsUncheckedUpdateWithoutCustomersInput>
    create: XOR<DeliveryLocationsCreateWithoutCustomersInput, DeliveryLocationsUncheckedCreateWithoutCustomersInput>
  }

  export type DeliveryLocationsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: DeliveryLocationsWhereUniqueInput
    data: XOR<DeliveryLocationsUpdateWithoutCustomersInput, DeliveryLocationsUncheckedUpdateWithoutCustomersInput>
  }

  export type DeliveryLocationsUpdateManyWithWhereWithoutCustomersInput = {
    where: DeliveryLocationsScalarWhereInput
    data: XOR<DeliveryLocationsUpdateManyMutationInput, DeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsInput>
  }

  export type DeliveryLocationsScalarWhereInput = {
    AND?: Enumerable<DeliveryLocationsScalarWhereInput>
    OR?: Enumerable<DeliveryLocationsScalarWhereInput>
    NOT?: Enumerable<DeliveryLocationsScalarWhereInput>
    ID?: IntFilter | number
    Description?: StringFilter | string
    Deleted?: BoolNullableFilter | boolean | null
    CustomerID?: IntNullableFilter | number | null
  }

  export type InvoicesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: InvoicesWhereUniqueInput
    update: XOR<InvoicesUpdateWithoutCustomersInput, InvoicesUncheckedUpdateWithoutCustomersInput>
    create: XOR<InvoicesCreateWithoutCustomersInput, InvoicesUncheckedCreateWithoutCustomersInput>
  }

  export type InvoicesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: InvoicesWhereUniqueInput
    data: XOR<InvoicesUpdateWithoutCustomersInput, InvoicesUncheckedUpdateWithoutCustomersInput>
  }

  export type InvoicesUpdateManyWithWhereWithoutCustomersInput = {
    where: InvoicesScalarWhereInput
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type InvoicesScalarWhereInput = {
    AND?: Enumerable<InvoicesScalarWhereInput>
    OR?: Enumerable<InvoicesScalarWhereInput>
    NOT?: Enumerable<InvoicesScalarWhereInput>
    ID?: IntFilter | number
    InvoiceDate?: DateTimeFilter | Date | string
    Number?: IntNullableFilter | number | null
    CustomerID?: IntFilter | number
    TotalAmount?: FloatFilter | number
    PaidDate?: DateTimeNullableFilter | Date | string | null
    CheckNumber?: StringNullableFilter | string | null
    Paid?: BoolNullableFilter | boolean | null
    Printed?: BoolNullableFilter | boolean | null
    Deleted?: BoolNullableFilter | boolean | null
    PaymentType?: StringNullableFilter | string | null
    Consolidated?: BoolNullableFilter | boolean | null
    ConsolidatedID?: IntNullableFilter | number | null
  }

  export type JobsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutCustomersInput, JobsUncheckedUpdateWithoutCustomersInput>
    create: XOR<JobsCreateWithoutCustomersInput, JobsUncheckedCreateWithoutCustomersInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutCustomersInput, JobsUncheckedUpdateWithoutCustomersInput>
  }

  export type JobsUpdateManyWithWhereWithoutCustomersInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type JobsScalarWhereInput = {
    AND?: Enumerable<JobsScalarWhereInput>
    OR?: Enumerable<JobsScalarWhereInput>
    NOT?: Enumerable<JobsScalarWhereInput>
    ID?: IntFilter | number
    DriverID?: IntFilter | number
    LoadTypeID?: IntFilter | number
    CustomerID?: IntFilter | number
    PaidOut?: BoolFilter | boolean
    TruckingRevenue?: FloatNullableFilter | number | null
    CompanyRevenue?: FloatNullableFilter | number | null
    TruckingRate?: FloatFilter | number
    CompanyRate?: FloatFilter | number
    DeliveryLocationID?: IntFilter | number
    WeeklyID?: IntFilter | number
    DailyID?: IntFilter | number
    MaterialRate?: FloatFilter | number
    DriverRate?: FloatFilter | number
    PayStubID?: IntNullableFilter | number | null
  }

  export type LoadsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutCustomersInput, LoadsUncheckedUpdateWithoutCustomersInput>
    create: XOR<LoadsCreateWithoutCustomersInput, LoadsUncheckedCreateWithoutCustomersInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutCustomersInput, LoadsUncheckedUpdateWithoutCustomersInput>
  }

  export type LoadsUpdateManyWithWhereWithoutCustomersInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadsInput>
  }

  export type LoadsScalarWhereInput = {
    AND?: Enumerable<LoadsScalarWhereInput>
    OR?: Enumerable<LoadsScalarWhereInput>
    NOT?: Enumerable<LoadsScalarWhereInput>
    ID?: IntFilter | number
    StartDate?: DateTimeFilter | Date | string
    Created?: DateTimeFilter | Date | string
    Weight?: FloatNullableFilter | number | null
    Hours?: FloatNullableFilter | number | null
    TotalRate?: FloatNullableFilter | number | null
    TotalAmount?: FloatNullableFilter | number | null
    TruckRate?: FloatNullableFilter | number | null
    MaterialRate?: FloatNullableFilter | number | null
    Received?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    TicketNumber?: IntFilter | number
    Invoiced?: BoolNullableFilter | boolean | null
    CustomerID?: IntFilter | number
    InvoiceID?: IntNullableFilter | number | null
    LoadTypeID?: IntNullableFilter | number | null
    DeliveryLocationID?: IntNullableFilter | number | null
    TruckID?: IntNullableFilter | number | null
    DriverID?: IntNullableFilter | number | null
    Deleted?: BoolNullableFilter | boolean | null
    JobID?: IntNullableFilter | number | null
    Week?: StringFilter | string
    DriverRate?: FloatNullableFilter | number | null
  }

  export type WeekliesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutCustomersInput, WeekliesUncheckedUpdateWithoutCustomersInput>
    create: XOR<WeekliesCreateWithoutCustomersInput, WeekliesUncheckedCreateWithoutCustomersInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutCustomersInput, WeekliesUncheckedUpdateWithoutCustomersInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutCustomersInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutWeekliesInput>
  }

  export type WeekliesScalarWhereInput = {
    AND?: Enumerable<WeekliesScalarWhereInput>
    OR?: Enumerable<WeekliesScalarWhereInput>
    NOT?: Enumerable<WeekliesScalarWhereInput>
    ID?: IntFilter | number
    Week?: StringFilter | string
    CustomerID?: IntFilter | number
    InvoiceID?: IntNullableFilter | number | null
    CompanyRate?: FloatNullableFilter | number | null
    Revenue?: FloatNullableFilter | number | null
    LoadTypeID?: IntFilter | number
    DeliveryLocationID?: IntFilter | number
    LastPrinted?: DateTimeNullableFilter | Date | string | null
    TotalWeight?: FloatNullableFilter | number | null
  }

  export type CustomersCreateWithoutDeliveryLocationsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutDeliveryLocationsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput = {
    DateUsed: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerDeliveryLocationsInput
  }

  export type CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    CustomerID: number
    DateUsed: Date | string
  }

  export type CustomerDeliveryLocationsCreateOrConnectWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    create: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsCreateManyDeliveryLocationsInputEnvelope = {
    data: Enumerable<CustomerDeliveryLocationsCreateManyDeliveryLocationsInput>
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutDeliveryLocationsInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutDeliveryLocationsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type JobsCreateManyDeliveryLocationsInputEnvelope = {
    data: Enumerable<JobsCreateManyDeliveryLocationsInput>
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutDeliveryLocationsInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutDeliveryLocationsInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type LoadsCreateManyDeliveryLocationsInputEnvelope = {
    data: Enumerable<LoadsCreateManyDeliveryLocationsInput>
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutDeliveryLocationsInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutDeliveryLocationsInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutDeliveryLocationsInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type WeekliesCreateManyDeliveryLocationsInputEnvelope = {
    data: Enumerable<WeekliesCreateManyDeliveryLocationsInput>
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutDeliveryLocationsInput = {
    update: XOR<CustomersUpdateWithoutDeliveryLocationsInput, CustomersUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<CustomersCreateWithoutDeliveryLocationsInput, CustomersUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type CustomersUpdateWithoutDeliveryLocationsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerDeliveryLocationsUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    update: XOR<CustomerDeliveryLocationsUpdateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<CustomerDeliveryLocationsCreateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsWhereUniqueInput
    data: XOR<CustomerDeliveryLocationsUpdateWithoutDeliveryLocationsInput, CustomerDeliveryLocationsUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type CustomerDeliveryLocationsUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: CustomerDeliveryLocationsScalarWhereInput
    data: XOR<CustomerDeliveryLocationsUpdateManyMutationInput, CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomerDeliveryLocationsInput>
  }

  export type JobsUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutDeliveryLocationsInput, JobsUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<JobsCreateWithoutDeliveryLocationsInput, JobsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutDeliveryLocationsInput, JobsUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type JobsUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type LoadsUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutDeliveryLocationsInput, LoadsUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<LoadsCreateWithoutDeliveryLocationsInput, LoadsUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutDeliveryLocationsInput, LoadsUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type LoadsUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadsInput>
  }

  export type WeekliesUpsertWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutDeliveryLocationsInput, WeekliesUncheckedUpdateWithoutDeliveryLocationsInput>
    create: XOR<WeekliesCreateWithoutDeliveryLocationsInput, WeekliesUncheckedCreateWithoutDeliveryLocationsInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutDeliveryLocationsInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutDeliveryLocationsInput, WeekliesUncheckedUpdateWithoutDeliveryLocationsInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutDeliveryLocationsInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutWeekliesInput>
  }

  export type StatesCreateWithoutDriversInput = {
    Name: string
    Abbreviation: string
    Customers?: CustomersCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateWithoutDriversInput = {
    ID?: number
    Name: string
    Abbreviation: string
    Customers?: CustomersUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesCreateOrConnectWithoutDriversInput = {
    where: StatesWhereUniqueInput
    create: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
  }

  export type DailiesCreateWithoutDriversInput = {
    Week: string
    LastPrinted?: Date | string | null
    Jobs?: JobsCreateNestedManyWithoutDailiesInput
  }

  export type DailiesUncheckedCreateWithoutDriversInput = {
    ID?: number
    Week: string
    LastPrinted?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutDailiesInput
  }

  export type DailiesCreateOrConnectWithoutDriversInput = {
    where: DailiesWhereUniqueInput
    create: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput>
  }

  export type DailiesCreateManyDriversInputEnvelope = {
    data: Enumerable<DailiesCreateManyDriversInput>
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutDriversInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutDriversInput = {
    ID?: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutDriversInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput>
  }

  export type JobsCreateManyDriversInputEnvelope = {
    data: Enumerable<JobsCreateManyDriversInput>
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutDriversInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutDriversInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutDriversInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput>
  }

  export type LoadsCreateManyDriversInputEnvelope = {
    data: Enumerable<LoadsCreateManyDriversInput>
    skipDuplicates?: boolean
  }

  export type PayStubsCreateWithoutDriversInput = {
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Jobs?: JobsCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsUncheckedCreateWithoutDriversInput = {
    ID?: number
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutPayStubsInput
  }

  export type PayStubsCreateOrConnectWithoutDriversInput = {
    where: PayStubsWhereUniqueInput
    create: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput>
  }

  export type PayStubsCreateManyDriversInputEnvelope = {
    data: Enumerable<PayStubsCreateManyDriversInput>
    skipDuplicates?: boolean
  }

  export type TrucksDrivenCreateWithoutDriversInput = {
    DateDriven: Date | string
    Trucks: TrucksCreateNestedOneWithoutTrucksDrivenInput
  }

  export type TrucksDrivenUncheckedCreateWithoutDriversInput = {
    ID?: number
    TruckID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenCreateOrConnectWithoutDriversInput = {
    where: TrucksDrivenWhereUniqueInput
    create: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput>
  }

  export type TrucksDrivenCreateManyDriversInputEnvelope = {
    data: Enumerable<TrucksDrivenCreateManyDriversInput>
    skipDuplicates?: boolean
  }

  export type StatesUpsertWithoutDriversInput = {
    update: XOR<StatesUpdateWithoutDriversInput, StatesUncheckedUpdateWithoutDriversInput>
    create: XOR<StatesCreateWithoutDriversInput, StatesUncheckedCreateWithoutDriversInput>
  }

  export type StatesUpdateWithoutDriversInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUpdateManyWithoutStatesNestedInput
  }

  export type StatesUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Abbreviation?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUncheckedUpdateManyWithoutStatesNestedInput
  }

  export type DailiesUpsertWithWhereUniqueWithoutDriversInput = {
    where: DailiesWhereUniqueInput
    update: XOR<DailiesUpdateWithoutDriversInput, DailiesUncheckedUpdateWithoutDriversInput>
    create: XOR<DailiesCreateWithoutDriversInput, DailiesUncheckedCreateWithoutDriversInput>
  }

  export type DailiesUpdateWithWhereUniqueWithoutDriversInput = {
    where: DailiesWhereUniqueInput
    data: XOR<DailiesUpdateWithoutDriversInput, DailiesUncheckedUpdateWithoutDriversInput>
  }

  export type DailiesUpdateManyWithWhereWithoutDriversInput = {
    where: DailiesScalarWhereInput
    data: XOR<DailiesUpdateManyMutationInput, DailiesUncheckedUpdateManyWithoutDailiesInput>
  }

  export type DailiesScalarWhereInput = {
    AND?: Enumerable<DailiesScalarWhereInput>
    OR?: Enumerable<DailiesScalarWhereInput>
    NOT?: Enumerable<DailiesScalarWhereInput>
    ID?: IntFilter | number
    DriverID?: IntFilter | number
    Week?: StringFilter | string
    LastPrinted?: DateTimeNullableFilter | Date | string | null
  }

  export type JobsUpsertWithWhereUniqueWithoutDriversInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutDriversInput, JobsUncheckedUpdateWithoutDriversInput>
    create: XOR<JobsCreateWithoutDriversInput, JobsUncheckedCreateWithoutDriversInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutDriversInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutDriversInput, JobsUncheckedUpdateWithoutDriversInput>
  }

  export type JobsUpdateManyWithWhereWithoutDriversInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type LoadsUpsertWithWhereUniqueWithoutDriversInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutDriversInput, LoadsUncheckedUpdateWithoutDriversInput>
    create: XOR<LoadsCreateWithoutDriversInput, LoadsUncheckedCreateWithoutDriversInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutDriversInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutDriversInput, LoadsUncheckedUpdateWithoutDriversInput>
  }

  export type LoadsUpdateManyWithWhereWithoutDriversInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadsInput>
  }

  export type PayStubsUpsertWithWhereUniqueWithoutDriversInput = {
    where: PayStubsWhereUniqueInput
    update: XOR<PayStubsUpdateWithoutDriversInput, PayStubsUncheckedUpdateWithoutDriversInput>
    create: XOR<PayStubsCreateWithoutDriversInput, PayStubsUncheckedCreateWithoutDriversInput>
  }

  export type PayStubsUpdateWithWhereUniqueWithoutDriversInput = {
    where: PayStubsWhereUniqueInput
    data: XOR<PayStubsUpdateWithoutDriversInput, PayStubsUncheckedUpdateWithoutDriversInput>
  }

  export type PayStubsUpdateManyWithWhereWithoutDriversInput = {
    where: PayStubsScalarWhereInput
    data: XOR<PayStubsUpdateManyMutationInput, PayStubsUncheckedUpdateManyWithoutPayStubsInput>
  }

  export type PayStubsScalarWhereInput = {
    AND?: Enumerable<PayStubsScalarWhereInput>
    OR?: Enumerable<PayStubsScalarWhereInput>
    NOT?: Enumerable<PayStubsScalarWhereInput>
    ID?: IntFilter | number
    Created?: DateTimeFilter | Date | string
    DriverID?: IntFilter | number
    CheckNumber?: StringFilter | string
    Gross?: FloatFilter | number
    Percentage?: FloatFilter | number
    NetTotal?: FloatFilter | number
    LastPrinted?: DateTimeNullableFilter | Date | string | null
    TakeHome?: FloatFilter | number
    Deductions?: FloatFilter | number
    Additions?: FloatFilter | number
    Notes?: StringNullableFilter | string | null
    DepositDate?: DateTimeNullableFilter | Date | string | null
  }

  export type TrucksDrivenUpsertWithWhereUniqueWithoutDriversInput = {
    where: TrucksDrivenWhereUniqueInput
    update: XOR<TrucksDrivenUpdateWithoutDriversInput, TrucksDrivenUncheckedUpdateWithoutDriversInput>
    create: XOR<TrucksDrivenCreateWithoutDriversInput, TrucksDrivenUncheckedCreateWithoutDriversInput>
  }

  export type TrucksDrivenUpdateWithWhereUniqueWithoutDriversInput = {
    where: TrucksDrivenWhereUniqueInput
    data: XOR<TrucksDrivenUpdateWithoutDriversInput, TrucksDrivenUncheckedUpdateWithoutDriversInput>
  }

  export type TrucksDrivenUpdateManyWithWhereWithoutDriversInput = {
    where: TrucksDrivenScalarWhereInput
    data: XOR<TrucksDrivenUpdateManyMutationInput, TrucksDrivenUncheckedUpdateManyWithoutTrucksDrivenInput>
  }

  export type TrucksDrivenScalarWhereInput = {
    AND?: Enumerable<TrucksDrivenScalarWhereInput>
    OR?: Enumerable<TrucksDrivenScalarWhereInput>
    NOT?: Enumerable<TrucksDrivenScalarWhereInput>
    ID?: IntFilter | number
    TruckID?: IntFilter | number
    DriverID?: IntFilter | number
    DateDriven?: DateTimeFilter | Date | string
  }

  export type CustomersCreateWithoutInvoicesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutInvoicesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutInvoicesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
  }

  export type LoadsCreateWithoutInvoicesInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutInvoicesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutInvoicesInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput>
  }

  export type LoadsCreateManyInvoicesInputEnvelope = {
    data: Enumerable<LoadsCreateManyInvoicesInput>
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutInvoicesInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutInvoicesInput = {
    ID?: number
    Week: string
    CustomerID: number
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutInvoicesInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput>
  }

  export type WeekliesCreateManyInvoicesInputEnvelope = {
    data: Enumerable<WeekliesCreateManyInvoicesInput>
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutInvoicesInput = {
    update: XOR<CustomersUpdateWithoutInvoicesInput, CustomersUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomersCreateWithoutInvoicesInput, CustomersUncheckedCreateWithoutInvoicesInput>
  }

  export type CustomersUpdateWithoutInvoicesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type LoadsUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutInvoicesInput, LoadsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<LoadsCreateWithoutInvoicesInput, LoadsUncheckedCreateWithoutInvoicesInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutInvoicesInput, LoadsUncheckedUpdateWithoutInvoicesInput>
  }

  export type LoadsUpdateManyWithWhereWithoutInvoicesInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadsInput>
  }

  export type WeekliesUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutInvoicesInput, WeekliesUncheckedUpdateWithoutInvoicesInput>
    create: XOR<WeekliesCreateWithoutInvoicesInput, WeekliesUncheckedCreateWithoutInvoicesInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutInvoicesInput, WeekliesUncheckedUpdateWithoutInvoicesInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutInvoicesInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutWeekliesInput>
  }

  export type CustomerLoadTypesCreateWithoutLoadTypesInput = {
    DateDelivered: Date | string
    Customers: CustomersCreateNestedOneWithoutCustomerLoadTypesInput
  }

  export type CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    CustomerID: number
    DateDelivered: Date | string
  }

  export type CustomerLoadTypesCreateOrConnectWithoutLoadTypesInput = {
    where: CustomerLoadTypesWhereUniqueInput
    create: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>
  }

  export type CustomerLoadTypesCreateManyLoadTypesInputEnvelope = {
    data: Enumerable<CustomerLoadTypesCreateManyLoadTypesInput>
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutLoadTypesInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    DriverID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutLoadTypesInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput>
  }

  export type JobsCreateManyLoadTypesInputEnvelope = {
    data: Enumerable<JobsCreateManyLoadTypesInput>
    skipDuplicates?: boolean
  }

  export type LoadsCreateWithoutLoadTypesInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutLoadTypesInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput>
  }

  export type LoadsCreateManyLoadTypesInputEnvelope = {
    data: Enumerable<LoadsCreateManyLoadTypesInput>
    skipDuplicates?: boolean
  }

  export type WeekliesCreateWithoutLoadTypesInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    Jobs?: JobsCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutLoadTypesInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutWeekliesInput
  }

  export type WeekliesCreateOrConnectWithoutLoadTypesInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput>
  }

  export type WeekliesCreateManyLoadTypesInputEnvelope = {
    data: Enumerable<WeekliesCreateManyLoadTypesInput>
    skipDuplicates?: boolean
  }

  export type CustomerLoadTypesUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: CustomerLoadTypesWhereUniqueInput
    update: XOR<CustomerLoadTypesUpdateWithoutLoadTypesInput, CustomerLoadTypesUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<CustomerLoadTypesCreateWithoutLoadTypesInput, CustomerLoadTypesUncheckedCreateWithoutLoadTypesInput>
  }

  export type CustomerLoadTypesUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: CustomerLoadTypesWhereUniqueInput
    data: XOR<CustomerLoadTypesUpdateWithoutLoadTypesInput, CustomerLoadTypesUncheckedUpdateWithoutLoadTypesInput>
  }

  export type CustomerLoadTypesUpdateManyWithWhereWithoutLoadTypesInput = {
    where: CustomerLoadTypesScalarWhereInput
    data: XOR<CustomerLoadTypesUpdateManyMutationInput, CustomerLoadTypesUncheckedUpdateManyWithoutCustomerLoadTypesInput>
  }

  export type JobsUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutLoadTypesInput, JobsUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<JobsCreateWithoutLoadTypesInput, JobsUncheckedCreateWithoutLoadTypesInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutLoadTypesInput, JobsUncheckedUpdateWithoutLoadTypesInput>
  }

  export type JobsUpdateManyWithWhereWithoutLoadTypesInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type LoadsUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutLoadTypesInput, LoadsUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<LoadsCreateWithoutLoadTypesInput, LoadsUncheckedCreateWithoutLoadTypesInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutLoadTypesInput, LoadsUncheckedUpdateWithoutLoadTypesInput>
  }

  export type LoadsUpdateManyWithWhereWithoutLoadTypesInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadsInput>
  }

  export type WeekliesUpsertWithWhereUniqueWithoutLoadTypesInput = {
    where: WeekliesWhereUniqueInput
    update: XOR<WeekliesUpdateWithoutLoadTypesInput, WeekliesUncheckedUpdateWithoutLoadTypesInput>
    create: XOR<WeekliesCreateWithoutLoadTypesInput, WeekliesUncheckedCreateWithoutLoadTypesInput>
  }

  export type WeekliesUpdateWithWhereUniqueWithoutLoadTypesInput = {
    where: WeekliesWhereUniqueInput
    data: XOR<WeekliesUpdateWithoutLoadTypesInput, WeekliesUncheckedUpdateWithoutLoadTypesInput>
  }

  export type WeekliesUpdateManyWithWhereWithoutLoadTypesInput = {
    where: WeekliesScalarWhereInput
    data: XOR<WeekliesUpdateManyMutationInput, WeekliesUncheckedUpdateManyWithoutWeekliesInput>
  }

  export type CustomersCreateWithoutStatesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutStatesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutStatesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput>
  }

  export type CustomersCreateManyStatesInputEnvelope = {
    data: Enumerable<CustomersCreateManyStatesInput>
    skipDuplicates?: boolean
  }

  export type DriversCreateWithoutStatesInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutStatesInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutStatesInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput>
  }

  export type DriversCreateManyStatesInputEnvelope = {
    data: Enumerable<DriversCreateManyStatesInput>
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithWhereUniqueWithoutStatesInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutStatesInput, CustomersUncheckedUpdateWithoutStatesInput>
    create: XOR<CustomersCreateWithoutStatesInput, CustomersUncheckedCreateWithoutStatesInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutStatesInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutStatesInput, CustomersUncheckedUpdateWithoutStatesInput>
  }

  export type CustomersUpdateManyWithWhereWithoutStatesInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: Enumerable<CustomersScalarWhereInput>
    OR?: Enumerable<CustomersScalarWhereInput>
    NOT?: Enumerable<CustomersScalarWhereInput>
    ID?: IntFilter | number
    Name?: StringFilter | string
    Street?: StringFilter | string
    City?: StringFilter | string
    State?: IntFilter | number
    ZIP?: StringFilter | string
    Phone?: StringNullableFilter | string | null
    Email?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    MainContact?: StringNullableFilter | string | null
    Deleted?: BoolNullableFilter | boolean | null
  }

  export type DriversUpsertWithWhereUniqueWithoutStatesInput = {
    where: DriversWhereUniqueInput
    update: XOR<DriversUpdateWithoutStatesInput, DriversUncheckedUpdateWithoutStatesInput>
    create: XOR<DriversCreateWithoutStatesInput, DriversUncheckedCreateWithoutStatesInput>
  }

  export type DriversUpdateWithWhereUniqueWithoutStatesInput = {
    where: DriversWhereUniqueInput
    data: XOR<DriversUpdateWithoutStatesInput, DriversUncheckedUpdateWithoutStatesInput>
  }

  export type DriversUpdateManyWithWhereWithoutStatesInput = {
    where: DriversScalarWhereInput
    data: XOR<DriversUpdateManyMutationInput, DriversUncheckedUpdateManyWithoutDriversInput>
  }

  export type DriversScalarWhereInput = {
    AND?: Enumerable<DriversScalarWhereInput>
    OR?: Enumerable<DriversScalarWhereInput>
    NOT?: Enumerable<DriversScalarWhereInput>
    ID?: IntFilter | number
    FirstName?: StringFilter | string
    MiddleName?: StringNullableFilter | string | null
    LastName?: StringFilter | string
    Street?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    State?: IntNullableFilter | number | null
    ZIP?: StringNullableFilter | string | null
    DOB?: DateTimeNullableFilter | Date | string | null
    License?: StringNullableFilter | string | null
    Email?: StringNullableFilter | string | null
    Phone?: StringNullableFilter | string | null
    Notes?: StringNullableFilter | string | null
    Deleted?: BoolNullableFilter | boolean | null
    HireDate?: StringNullableFilter | string | null
    OwnerOperator?: BoolFilter | boolean
  }

  export type LoadsCreateWithoutTrucksInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    Jobs?: JobsCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutTrucksInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutTrucksInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput>
  }

  export type LoadsCreateManyTrucksInputEnvelope = {
    data: Enumerable<LoadsCreateManyTrucksInput>
    skipDuplicates?: boolean
  }

  export type TrucksDrivenCreateWithoutTrucksInput = {
    DateDriven: Date | string
    Drivers: DriversCreateNestedOneWithoutTrucksDrivenInput
  }

  export type TrucksDrivenUncheckedCreateWithoutTrucksInput = {
    ID?: number
    DriverID: number
    DateDriven: Date | string
  }

  export type TrucksDrivenCreateOrConnectWithoutTrucksInput = {
    where: TrucksDrivenWhereUniqueInput
    create: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput>
  }

  export type TrucksDrivenCreateManyTrucksInputEnvelope = {
    data: Enumerable<TrucksDrivenCreateManyTrucksInput>
    skipDuplicates?: boolean
  }

  export type LoadsUpsertWithWhereUniqueWithoutTrucksInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutTrucksInput, LoadsUncheckedUpdateWithoutTrucksInput>
    create: XOR<LoadsCreateWithoutTrucksInput, LoadsUncheckedCreateWithoutTrucksInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutTrucksInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutTrucksInput, LoadsUncheckedUpdateWithoutTrucksInput>
  }

  export type LoadsUpdateManyWithWhereWithoutTrucksInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadsInput>
  }

  export type TrucksDrivenUpsertWithWhereUniqueWithoutTrucksInput = {
    where: TrucksDrivenWhereUniqueInput
    update: XOR<TrucksDrivenUpdateWithoutTrucksInput, TrucksDrivenUncheckedUpdateWithoutTrucksInput>
    create: XOR<TrucksDrivenCreateWithoutTrucksInput, TrucksDrivenUncheckedCreateWithoutTrucksInput>
  }

  export type TrucksDrivenUpdateWithWhereUniqueWithoutTrucksInput = {
    where: TrucksDrivenWhereUniqueInput
    data: XOR<TrucksDrivenUpdateWithoutTrucksInput, TrucksDrivenUncheckedUpdateWithoutTrucksInput>
  }

  export type TrucksDrivenUpdateManyWithWhereWithoutTrucksInput = {
    where: TrucksDrivenScalarWhereInput
    data: XOR<TrucksDrivenUpdateManyMutationInput, TrucksDrivenUncheckedUpdateManyWithoutTrucksDrivenInput>
  }

  export type DriversCreateWithoutTrucksDrivenInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutTrucksDrivenInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutTrucksDrivenInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
  }

  export type TrucksCreateWithoutTrucksDrivenInput = {
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUncheckedCreateWithoutTrucksDrivenInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutTrucksInput
  }

  export type TrucksCreateOrConnectWithoutTrucksDrivenInput = {
    where: TrucksWhereUniqueInput
    create: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
  }

  export type DriversUpsertWithoutTrucksDrivenInput = {
    update: XOR<DriversUpdateWithoutTrucksDrivenInput, DriversUncheckedUpdateWithoutTrucksDrivenInput>
    create: XOR<DriversCreateWithoutTrucksDrivenInput, DriversUncheckedCreateWithoutTrucksDrivenInput>
  }

  export type DriversUpdateWithoutTrucksDrivenInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutTrucksDrivenInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type TrucksUpsertWithoutTrucksDrivenInput = {
    update: XOR<TrucksUpdateWithoutTrucksDrivenInput, TrucksUncheckedUpdateWithoutTrucksDrivenInput>
    create: XOR<TrucksCreateWithoutTrucksDrivenInput, TrucksUncheckedCreateWithoutTrucksDrivenInput>
  }

  export type TrucksUpdateWithoutTrucksDrivenInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksUncheckedUpdateWithoutTrucksDrivenInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loads?: LoadsUncheckedUpdateManyWithoutTrucksNestedInput
  }

  export type CustomersCreateWithoutLoadsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutLoadsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
  }

  export type DeliveryLocationsCreateWithoutLoadsInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutLoadsInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
  }

  export type DriversCreateWithoutLoadsInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutLoadsInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutLoadsInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
  }

  export type InvoicesCreateWithoutLoadsInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Customers: CustomersCreateNestedOneWithoutInvoicesInput
    Weeklies?: WeekliesCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateWithoutLoadsInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesCreateOrConnectWithoutLoadsInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
  }

  export type JobsCreateWithoutLoadsInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutLoadsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsCreateOrConnectWithoutLoadsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
  }

  export type LoadTypesCreateWithoutLoadsInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutLoadsInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
  }

  export type TrucksCreateWithoutLoadsInput = {
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutTrucksInput
  }

  export type TrucksUncheckedCreateWithoutLoadsInput = {
    ID?: number
    Name: string
    VIN?: string | null
    Deleted?: boolean | null
    Notes?: string | null
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutTrucksInput
  }

  export type TrucksCreateOrConnectWithoutLoadsInput = {
    where: TrucksWhereUniqueInput
    create: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
  }

  export type CustomersUpsertWithoutLoadsInput = {
    update: XOR<CustomersUpdateWithoutLoadsInput, CustomersUncheckedUpdateWithoutLoadsInput>
    create: XOR<CustomersCreateWithoutLoadsInput, CustomersUncheckedCreateWithoutLoadsInput>
  }

  export type CustomersUpdateWithoutLoadsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DeliveryLocationsUpsertWithoutLoadsInput = {
    update: XOR<DeliveryLocationsUpdateWithoutLoadsInput, DeliveryLocationsUncheckedUpdateWithoutLoadsInput>
    create: XOR<DeliveryLocationsCreateWithoutLoadsInput, DeliveryLocationsUncheckedCreateWithoutLoadsInput>
  }

  export type DeliveryLocationsUpdateWithoutLoadsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DriversUpsertWithoutLoadsInput = {
    update: XOR<DriversUpdateWithoutLoadsInput, DriversUncheckedUpdateWithoutLoadsInput>
    create: XOR<DriversCreateWithoutLoadsInput, DriversUncheckedCreateWithoutLoadsInput>
  }

  export type DriversUpdateWithoutLoadsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type InvoicesUpsertWithoutLoadsInput = {
    update: XOR<InvoicesUpdateWithoutLoadsInput, InvoicesUncheckedUpdateWithoutLoadsInput>
    create: XOR<InvoicesCreateWithoutLoadsInput, InvoicesUncheckedCreateWithoutLoadsInput>
  }

  export type InvoicesUpdateWithoutLoadsInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutInvoicesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Weeklies?: WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type JobsUpsertWithoutLoadsInput = {
    update: XOR<JobsUpdateWithoutLoadsInput, JobsUncheckedUpdateWithoutLoadsInput>
    create: XOR<JobsCreateWithoutLoadsInput, JobsUncheckedCreateWithoutLoadsInput>
  }

  export type JobsUpdateWithoutLoadsInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadTypesUpsertWithoutLoadsInput = {
    update: XOR<LoadTypesUpdateWithoutLoadsInput, LoadTypesUncheckedUpdateWithoutLoadsInput>
    create: XOR<LoadTypesCreateWithoutLoadsInput, LoadTypesUncheckedCreateWithoutLoadsInput>
  }

  export type LoadTypesUpdateWithoutLoadsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type TrucksUpsertWithoutLoadsInput = {
    update: XOR<TrucksUpdateWithoutLoadsInput, TrucksUncheckedUpdateWithoutLoadsInput>
    create: XOR<TrucksCreateWithoutLoadsInput, TrucksUncheckedCreateWithoutLoadsInput>
  }

  export type TrucksUpdateWithoutLoadsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TrucksDriven?: TrucksDrivenUpdateManyWithoutTrucksNestedInput
  }

  export type TrucksUncheckedUpdateWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutTrucksNestedInput
  }

  export type CustomersCreateWithoutCustomerDeliveryLocationsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutCustomerDeliveryLocationsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
  }

  export type DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutCustomerDeliveryLocationsInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
  }

  export type CustomersUpsertWithoutCustomerDeliveryLocationsInput = {
    update: XOR<CustomersUpdateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
    create: XOR<CustomersCreateWithoutCustomerDeliveryLocationsInput, CustomersUncheckedCreateWithoutCustomerDeliveryLocationsInput>
  }

  export type CustomersUpdateWithoutCustomerDeliveryLocationsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DeliveryLocationsUpsertWithoutCustomerDeliveryLocationsInput = {
    update: XOR<DeliveryLocationsUpdateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedUpdateWithoutCustomerDeliveryLocationsInput>
    create: XOR<DeliveryLocationsCreateWithoutCustomerDeliveryLocationsInput, DeliveryLocationsUncheckedCreateWithoutCustomerDeliveryLocationsInput>
  }

  export type DeliveryLocationsUpdateWithoutCustomerDeliveryLocationsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutCustomerDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DriversCreateWithoutDailiesInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutDailiesInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutDailiesInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
  }

  export type JobsCreateWithoutDailiesInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutDailiesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutDailiesInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput>
  }

  export type JobsCreateManyDailiesInputEnvelope = {
    data: Enumerable<JobsCreateManyDailiesInput>
    skipDuplicates?: boolean
  }

  export type DriversUpsertWithoutDailiesInput = {
    update: XOR<DriversUpdateWithoutDailiesInput, DriversUncheckedUpdateWithoutDailiesInput>
    create: XOR<DriversCreateWithoutDailiesInput, DriversUncheckedCreateWithoutDailiesInput>
  }

  export type DriversUpdateWithoutDailiesInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutDailiesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type JobsUpsertWithWhereUniqueWithoutDailiesInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutDailiesInput, JobsUncheckedUpdateWithoutDailiesInput>
    create: XOR<JobsCreateWithoutDailiesInput, JobsUncheckedCreateWithoutDailiesInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutDailiesInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutDailiesInput, JobsUncheckedUpdateWithoutDailiesInput>
  }

  export type JobsUpdateManyWithWhereWithoutDailiesInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type CustomersCreateWithoutJobsInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutJobsInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutJobsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
  }

  export type DailiesCreateWithoutJobsInput = {
    Week: string
    LastPrinted?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutDailiesInput
  }

  export type DailiesUncheckedCreateWithoutJobsInput = {
    ID?: number
    DriverID: number
    Week: string
    LastPrinted?: Date | string | null
  }

  export type DailiesCreateOrConnectWithoutJobsInput = {
    where: DailiesWhereUniqueInput
    create: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
  }

  export type DeliveryLocationsCreateWithoutJobsInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutJobsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutJobsInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
  }

  export type DriversCreateWithoutJobsInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutJobsInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    PayStubs?: PayStubsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutJobsInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
  }

  export type LoadTypesCreateWithoutJobsInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutJobsInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
    Weeklies?: WeekliesUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutJobsInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
  }

  export type PayStubsCreateWithoutJobsInput = {
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
    Drivers: DriversCreateNestedOneWithoutPayStubsInput
  }

  export type PayStubsUncheckedCreateWithoutJobsInput = {
    ID?: number
    Created?: Date | string
    DriverID: number
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
  }

  export type PayStubsCreateOrConnectWithoutJobsInput = {
    where: PayStubsWhereUniqueInput
    create: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
  }

  export type WeekliesCreateWithoutJobsInput = {
    Week: string
    CompanyRate?: number | null
    Revenue?: number | null
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
    Customers: CustomersCreateNestedOneWithoutWeekliesInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutWeekliesInput
    Invoices?: InvoicesCreateNestedOneWithoutWeekliesInput
    LoadTypes: LoadTypesCreateNestedOneWithoutWeekliesInput
  }

  export type WeekliesUncheckedCreateWithoutJobsInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type WeekliesCreateOrConnectWithoutJobsInput = {
    where: WeekliesWhereUniqueInput
    create: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
  }

  export type LoadsCreateWithoutJobsInput = {
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
    Customers: CustomersCreateNestedOneWithoutLoadsInput
    DeliveryLocations?: DeliveryLocationsCreateNestedOneWithoutLoadsInput
    Drivers?: DriversCreateNestedOneWithoutLoadsInput
    Invoices?: InvoicesCreateNestedOneWithoutLoadsInput
    LoadTypes?: LoadTypesCreateNestedOneWithoutLoadsInput
    Trucks?: TrucksCreateNestedOneWithoutLoadsInput
  }

  export type LoadsUncheckedCreateWithoutJobsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsCreateOrConnectWithoutJobsInput = {
    where: LoadsWhereUniqueInput
    create: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput>
  }

  export type LoadsCreateManyJobsInputEnvelope = {
    data: Enumerable<LoadsCreateManyJobsInput>
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutJobsInput = {
    update: XOR<CustomersUpdateWithoutJobsInput, CustomersUncheckedUpdateWithoutJobsInput>
    create: XOR<CustomersCreateWithoutJobsInput, CustomersUncheckedCreateWithoutJobsInput>
  }

  export type CustomersUpdateWithoutJobsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DailiesUpsertWithoutJobsInput = {
    update: XOR<DailiesUpdateWithoutJobsInput, DailiesUncheckedUpdateWithoutJobsInput>
    create: XOR<DailiesCreateWithoutJobsInput, DailiesUncheckedCreateWithoutJobsInput>
  }

  export type DailiesUpdateWithoutJobsInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryLocationsUpsertWithoutJobsInput = {
    update: XOR<DeliveryLocationsUpdateWithoutJobsInput, DeliveryLocationsUncheckedUpdateWithoutJobsInput>
    create: XOR<DeliveryLocationsCreateWithoutJobsInput, DeliveryLocationsUncheckedCreateWithoutJobsInput>
  }

  export type DeliveryLocationsUpdateWithoutJobsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DriversUpsertWithoutJobsInput = {
    update: XOR<DriversUpdateWithoutJobsInput, DriversUncheckedUpdateWithoutJobsInput>
    create: XOR<DriversCreateWithoutJobsInput, DriversUncheckedCreateWithoutJobsInput>
  }

  export type DriversUpdateWithoutJobsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type LoadTypesUpsertWithoutJobsInput = {
    update: XOR<LoadTypesUpdateWithoutJobsInput, LoadTypesUncheckedUpdateWithoutJobsInput>
    create: XOR<LoadTypesCreateWithoutJobsInput, LoadTypesUncheckedCreateWithoutJobsInput>
  }

  export type LoadTypesUpdateWithoutJobsInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type PayStubsUpsertWithoutJobsInput = {
    update: XOR<PayStubsUpdateWithoutJobsInput, PayStubsUncheckedUpdateWithoutJobsInput>
    create: XOR<PayStubsCreateWithoutJobsInput, PayStubsUncheckedCreateWithoutJobsInput>
  }

  export type PayStubsUpdateWithoutJobsInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Drivers?: DriversUpdateOneRequiredWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverID?: IntFieldUpdateOperationsInput | number
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WeekliesUpsertWithoutJobsInput = {
    update: XOR<WeekliesUpdateWithoutJobsInput, WeekliesUncheckedUpdateWithoutJobsInput>
    create: XOR<WeekliesCreateWithoutJobsInput, WeekliesUncheckedCreateWithoutJobsInput>
  }

  export type WeekliesUpdateWithoutJobsInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUpsertWithWhereUniqueWithoutJobsInput = {
    where: LoadsWhereUniqueInput
    update: XOR<LoadsUpdateWithoutJobsInput, LoadsUncheckedUpdateWithoutJobsInput>
    create: XOR<LoadsCreateWithoutJobsInput, LoadsUncheckedCreateWithoutJobsInput>
  }

  export type LoadsUpdateWithWhereUniqueWithoutJobsInput = {
    where: LoadsWhereUniqueInput
    data: XOR<LoadsUpdateWithoutJobsInput, LoadsUncheckedUpdateWithoutJobsInput>
  }

  export type LoadsUpdateManyWithWhereWithoutJobsInput = {
    where: LoadsScalarWhereInput
    data: XOR<LoadsUpdateManyMutationInput, LoadsUncheckedUpdateManyWithoutLoadsInput>
  }

  export type CustomersCreateWithoutWeekliesInput = {
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    States?: StatesCreateNestedOneWithoutCustomersInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesCreateNestedManyWithoutCustomersInput
    Jobs?: JobsCreateNestedManyWithoutCustomersInput
    Loads?: LoadsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    State?: number
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutCustomersInput
    DeliveryLocations?: DeliveryLocationsUncheckedCreateNestedManyWithoutCustomersInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCustomersInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutCustomersInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutWeekliesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
  }

  export type DeliveryLocationsCreateWithoutWeekliesInput = {
    Description: string
    Deleted?: boolean | null
    Customers?: CustomersCreateNestedOneWithoutDeliveryLocationsInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    CustomerID?: number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDeliveryLocationsInput
  }

  export type DeliveryLocationsCreateOrConnectWithoutWeekliesInput = {
    where: DeliveryLocationsWhereUniqueInput
    create: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
  }

  export type InvoicesCreateWithoutWeekliesInput = {
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Customers: CustomersCreateNestedOneWithoutInvoicesInput
    Loads?: LoadsCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    CustomerID: number
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type InvoicesCreateOrConnectWithoutWeekliesInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
  }

  export type LoadTypesCreateWithoutWeekliesInput = {
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
    SourceID?: number | null
    Notes?: string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedCreateNestedManyWithoutLoadTypesInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutLoadTypesInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutLoadTypesInput
  }

  export type LoadTypesCreateOrConnectWithoutWeekliesInput = {
    where: LoadTypesWhereUniqueInput
    create: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
  }

  export type JobsCreateWithoutWeekliesInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    PayStubs?: PayStubsCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutWeekliesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutWeekliesInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput>
  }

  export type JobsCreateManyWeekliesInputEnvelope = {
    data: Enumerable<JobsCreateManyWeekliesInput>
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutWeekliesInput = {
    update: XOR<CustomersUpdateWithoutWeekliesInput, CustomersUncheckedUpdateWithoutWeekliesInput>
    create: XOR<CustomersCreateWithoutWeekliesInput, CustomersUncheckedCreateWithoutWeekliesInput>
  }

  export type CustomersUpdateWithoutWeekliesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    States?: StatesUpdateOneRequiredWithoutCustomersNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: IntFieldUpdateOperationsInput | number
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type DeliveryLocationsUpsertWithoutWeekliesInput = {
    update: XOR<DeliveryLocationsUpdateWithoutWeekliesInput, DeliveryLocationsUncheckedUpdateWithoutWeekliesInput>
    create: XOR<DeliveryLocationsCreateWithoutWeekliesInput, DeliveryLocationsUncheckedCreateWithoutWeekliesInput>
  }

  export type DeliveryLocationsUpdateWithoutWeekliesInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customers?: CustomersUpdateOneWithoutDeliveryLocationsNestedInput
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type InvoicesUpsertWithoutWeekliesInput = {
    update: XOR<InvoicesUpdateWithoutWeekliesInput, InvoicesUncheckedUpdateWithoutWeekliesInput>
    create: XOR<InvoicesCreateWithoutWeekliesInput, InvoicesUncheckedCreateWithoutWeekliesInput>
  }

  export type InvoicesUpdateWithoutWeekliesInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutInvoicesNestedInput
    Loads?: LoadsUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type LoadTypesUpsertWithoutWeekliesInput = {
    update: XOR<LoadTypesUpdateWithoutWeekliesInput, LoadTypesUncheckedUpdateWithoutWeekliesInput>
    create: XOR<LoadTypesCreateWithoutWeekliesInput, LoadTypesUncheckedCreateWithoutWeekliesInput>
  }

  export type LoadTypesUpdateWithoutWeekliesInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUpdateManyWithoutLoadTypesNestedInput
  }

  export type LoadTypesUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceID?: NullableIntFieldUpdateOperationsInput | number | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutLoadTypesNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutLoadTypesNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutLoadTypesNestedInput
  }

  export type JobsUpsertWithWhereUniqueWithoutWeekliesInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutWeekliesInput, JobsUncheckedUpdateWithoutWeekliesInput>
    create: XOR<JobsCreateWithoutWeekliesInput, JobsUncheckedCreateWithoutWeekliesInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutWeekliesInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutWeekliesInput, JobsUncheckedUpdateWithoutWeekliesInput>
  }

  export type JobsUpdateManyWithWhereWithoutWeekliesInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type DriversCreateWithoutPayStubsInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    States?: StatesCreateNestedOneWithoutDriversInput
    Dailies?: DailiesCreateNestedManyWithoutDriversInput
    Jobs?: JobsCreateNestedManyWithoutDriversInput
    Loads?: LoadsCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenCreateNestedManyWithoutDriversInput
  }

  export type DriversUncheckedCreateWithoutPayStubsInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    State?: number | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
    Dailies?: DailiesUncheckedCreateNestedManyWithoutDriversInput
    Jobs?: JobsUncheckedCreateNestedManyWithoutDriversInput
    Loads?: LoadsUncheckedCreateNestedManyWithoutDriversInput
    TrucksDriven?: TrucksDrivenUncheckedCreateNestedManyWithoutDriversInput
  }

  export type DriversCreateOrConnectWithoutPayStubsInput = {
    where: DriversWhereUniqueInput
    create: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
  }

  export type JobsCreateWithoutPayStubsInput = {
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    MaterialRate: number
    DriverRate: number
    Customers: CustomersCreateNestedOneWithoutJobsInput
    Dailies: DailiesCreateNestedOneWithoutJobsInput
    DeliveryLocations: DeliveryLocationsCreateNestedOneWithoutJobsInput
    Drivers: DriversCreateNestedOneWithoutJobsInput
    LoadTypes: LoadTypesCreateNestedOneWithoutJobsInput
    Weeklies: WeekliesCreateNestedOneWithoutJobsInput
    Loads?: LoadsCreateNestedManyWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutPayStubsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    Loads?: LoadsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutPayStubsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput>
  }

  export type JobsCreateManyPayStubsInputEnvelope = {
    data: Enumerable<JobsCreateManyPayStubsInput>
    skipDuplicates?: boolean
  }

  export type DriversUpsertWithoutPayStubsInput = {
    update: XOR<DriversUpdateWithoutPayStubsInput, DriversUncheckedUpdateWithoutPayStubsInput>
    create: XOR<DriversCreateWithoutPayStubsInput, DriversUncheckedCreateWithoutPayStubsInput>
  }

  export type DriversUpdateWithoutPayStubsInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    States?: StatesUpdateOneWithoutDriversNestedInput
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutPayStubsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    State?: NullableIntFieldUpdateOperationsInput | number | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type JobsUpsertWithWhereUniqueWithoutPayStubsInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutPayStubsInput, JobsUncheckedUpdateWithoutPayStubsInput>
    create: XOR<JobsCreateWithoutPayStubsInput, JobsUncheckedCreateWithoutPayStubsInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutPayStubsInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutPayStubsInput, JobsUncheckedUpdateWithoutPayStubsInput>
  }

  export type JobsUpdateManyWithWhereWithoutPayStubsInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type CustomerDeliveryLocationsCreateManyCustomersInput = {
    ID?: number
    DeliveryLocationID: number
    DateUsed: Date | string
  }

  export type CustomerLoadTypesCreateManyCustomersInput = {
    ID?: number
    LoadTypeID: number
    DateDelivered: Date | string
  }

  export type DeliveryLocationsCreateManyCustomersInput = {
    ID?: number
    Description: string
    Deleted?: boolean | null
  }

  export type InvoicesCreateManyCustomersInput = {
    ID?: number
    InvoiceDate: Date | string
    Number?: number | null
    TotalAmount: number
    PaidDate?: Date | string | null
    CheckNumber?: string | null
    Paid?: boolean | null
    Printed?: boolean | null
    Deleted?: boolean | null
    PaymentType?: string | null
    Consolidated?: boolean | null
    ConsolidatedID?: number | null
  }

  export type JobsCreateManyCustomersInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyCustomersInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyCustomersInput = {
    ID?: number
    Week: string
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type CustomerDeliveryLocationsUpdateWithoutCustomersInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
  }

  export type CustomerDeliveryLocationsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomerDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesUpdateWithoutCustomersInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
  }

  export type CustomerLoadTypesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLoadTypesUncheckedUpdateManyWithoutCustomerLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLocationsUpdateWithoutCustomersInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutDeliveryLocationsNestedInput
  }

  export type DeliveryLocationsUncheckedUpdateManyWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InvoicesUpdateWithoutCustomersInput = {
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutInvoicesNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type InvoicesUncheckedUpdateManyWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    InvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Number?: NullableIntFieldUpdateOperationsInput | number | null
    TotalAmount?: FloatFieldUpdateOperationsInput | number
    PaidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CheckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Printed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Consolidated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ConsolidatedID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JobsUpdateWithoutCustomersInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoadsUpdateWithoutCustomersInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LoadsUncheckedUpdateManyWithoutLoadsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutCustomersInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateManyWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerDeliveryLocationsCreateManyDeliveryLocationsInput = {
    ID?: number
    CustomerID: number
    DateUsed: Date | string
  }

  export type JobsCreateManyDeliveryLocationsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyDeliveryLocationsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyDeliveryLocationsInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type CustomerDeliveryLocationsUpdateWithoutDeliveryLocationsInput = {
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerDeliveryLocationsNestedInput
  }

  export type CustomerDeliveryLocationsUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DateUsed?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsUpdateWithoutDeliveryLocationsInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type LoadsUpdateWithoutDeliveryLocationsInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutDeliveryLocationsInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutDeliveryLocationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type DailiesCreateManyDriversInput = {
    ID?: number
    Week: string
    LastPrinted?: Date | string | null
  }

  export type JobsCreateManyDriversInput = {
    ID?: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyDriversInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type PayStubsCreateManyDriversInput = {
    ID?: number
    Created?: Date | string
    CheckNumber: string
    Gross: number
    Percentage: number
    NetTotal: number
    LastPrinted?: Date | string | null
    TakeHome: number
    Deductions?: number
    Additions?: number
    Notes?: string | null
    DepositDate?: Date | string | null
  }

  export type TrucksDrivenCreateManyDriversInput = {
    ID?: number
    TruckID: number
    DateDriven: Date | string
  }

  export type DailiesUpdateWithoutDriversInput = {
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutDailiesNestedInput
  }

  export type DailiesUncheckedUpdateManyWithoutDailiesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobsUpdateWithoutDriversInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type LoadsUpdateWithoutDriversInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PayStubsUpdateWithoutDriversInput = {
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Jobs?: JobsUncheckedUpdateManyWithoutPayStubsNestedInput
  }

  export type PayStubsUncheckedUpdateManyWithoutPayStubsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    CheckNumber?: StringFieldUpdateOperationsInput | string
    Gross?: FloatFieldUpdateOperationsInput | number
    Percentage?: FloatFieldUpdateOperationsInput | number
    NetTotal?: FloatFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TakeHome?: FloatFieldUpdateOperationsInput | number
    Deductions?: FloatFieldUpdateOperationsInput | number
    Additions?: FloatFieldUpdateOperationsInput | number
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    DepositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrucksDrivenUpdateWithoutDriversInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
    Trucks?: TrucksUpdateOneRequiredWithoutTrucksDrivenNestedInput
  }

  export type TrucksDrivenUncheckedUpdateWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrucksDrivenUncheckedUpdateManyWithoutTrucksDrivenInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TruckID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoadsCreateManyInvoicesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyInvoicesInput = {
    ID?: number
    Week: string
    CustomerID: number
    CompanyRate?: number | null
    Revenue?: number | null
    LoadTypeID: number
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type LoadsUpdateWithoutInvoicesInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutInvoicesInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutInvoicesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type CustomerLoadTypesCreateManyLoadTypesInput = {
    ID?: number
    CustomerID: number
    DateDelivered: Date | string
  }

  export type JobsCreateManyLoadTypesInput = {
    ID?: number
    DriverID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type LoadsCreateManyLoadTypesInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type WeekliesCreateManyLoadTypesInput = {
    ID?: number
    Week: string
    CustomerID: number
    InvoiceID?: number | null
    CompanyRate?: number | null
    Revenue?: number | null
    DeliveryLocationID: number
    LastPrinted?: Date | string | null
    TotalWeight?: number | null
  }

  export type CustomerLoadTypesUpdateWithoutLoadTypesInput = {
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneRequiredWithoutCustomerLoadTypesNestedInput
  }

  export type CustomerLoadTypesUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    DateDelivered?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsUpdateWithoutLoadTypesInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type LoadsUpdateWithoutLoadTypesInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WeekliesUpdateWithoutLoadTypesInput = {
    Week?: StringFieldUpdateOperationsInput | string
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutWeekliesNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutWeekliesNestedInput
    Invoices?: InvoicesUpdateOneWithoutWeekliesNestedInput
    Jobs?: JobsUpdateManyWithoutWeekliesNestedInput
  }

  export type WeekliesUncheckedUpdateWithoutLoadTypesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Week?: StringFieldUpdateOperationsInput | string
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    CompanyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    LastPrinted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TotalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    Jobs?: JobsUncheckedUpdateManyWithoutWeekliesNestedInput
  }

  export type CustomersCreateManyStatesInput = {
    ID?: number
    Name: string
    Street: string
    City: string
    ZIP: string
    Phone?: string | null
    Email?: string | null
    Notes?: string | null
    MainContact?: string | null
    Deleted?: boolean | null
  }

  export type DriversCreateManyStatesInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Street?: string | null
    City?: string | null
    ZIP?: string | null
    DOB?: Date | string | null
    License?: string | null
    Email?: string | null
    Phone?: string | null
    Notes?: string | null
    Deleted?: boolean | null
    HireDate?: string | null
    OwnerOperator: boolean
  }

  export type CustomersUpdateWithoutStatesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutStatesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerDeliveryLocations?: CustomerDeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    CustomerLoadTypes?: CustomerLoadTypesUncheckedUpdateManyWithoutCustomersNestedInput
    DeliveryLocations?: DeliveryLocationsUncheckedUpdateManyWithoutCustomersNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCustomersNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutCustomersNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutCustomersNestedInput
    Weeklies?: WeekliesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateManyWithoutCustomersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    ZIP?: StringFieldUpdateOperationsInput | string
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    MainContact?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DriversUpdateWithoutStatesInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateWithoutStatesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
    Dailies?: DailiesUncheckedUpdateManyWithoutDriversNestedInput
    Jobs?: JobsUncheckedUpdateManyWithoutDriversNestedInput
    Loads?: LoadsUncheckedUpdateManyWithoutDriversNestedInput
    PayStubs?: PayStubsUncheckedUpdateManyWithoutDriversNestedInput
    TrucksDriven?: TrucksDrivenUncheckedUpdateManyWithoutDriversNestedInput
  }

  export type DriversUncheckedUpdateManyWithoutDriversInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    ZIP?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    License?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    HireDate?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerOperator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LoadsCreateManyTrucksInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    JobID?: number | null
    Week: string
    DriverRate?: number | null
  }

  export type TrucksDrivenCreateManyTrucksInput = {
    ID?: number
    DriverID: number
    DateDriven: Date | string
  }

  export type LoadsUpdateWithoutTrucksInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    Jobs?: JobsUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutTrucksInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    JobID?: NullableIntFieldUpdateOperationsInput | number | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TrucksDrivenUpdateWithoutTrucksInput = {
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
    Drivers?: DriversUpdateOneRequiredWithoutTrucksDrivenNestedInput
  }

  export type TrucksDrivenUncheckedUpdateWithoutTrucksInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    DateDriven?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsCreateManyDailiesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsUpdateWithoutDailiesInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutDailiesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type LoadsCreateManyJobsInput = {
    ID?: number
    StartDate: Date | string
    Created?: Date | string
    Weight?: number | null
    Hours?: number | null
    TotalRate?: number | null
    TotalAmount?: number | null
    TruckRate?: number | null
    MaterialRate?: number | null
    Received?: string | null
    Notes?: string | null
    TicketNumber: number
    Invoiced?: boolean | null
    CustomerID: number
    InvoiceID?: number | null
    LoadTypeID?: number | null
    DeliveryLocationID?: number | null
    TruckID?: number | null
    DriverID?: number | null
    Deleted?: boolean | null
    Week: string
    DriverRate?: number | null
  }

  export type LoadsUpdateWithoutJobsInput = {
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Customers?: CustomersUpdateOneRequiredWithoutLoadsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneWithoutLoadsNestedInput
    Drivers?: DriversUpdateOneWithoutLoadsNestedInput
    Invoices?: InvoicesUpdateOneWithoutLoadsNestedInput
    LoadTypes?: LoadTypesUpdateOneWithoutLoadsNestedInput
    Trucks?: TrucksUpdateOneWithoutLoadsNestedInput
  }

  export type LoadsUncheckedUpdateWithoutJobsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    StartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Created?: DateTimeFieldUpdateOperationsInput | Date | string
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    Hours?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    TotalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckRate?: NullableFloatFieldUpdateOperationsInput | number | null
    MaterialRate?: NullableFloatFieldUpdateOperationsInput | number | null
    Received?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    TicketNumber?: IntFieldUpdateOperationsInput | number
    Invoiced?: NullableBoolFieldUpdateOperationsInput | boolean | null
    CustomerID?: IntFieldUpdateOperationsInput | number
    InvoiceID?: NullableIntFieldUpdateOperationsInput | number | null
    LoadTypeID?: NullableIntFieldUpdateOperationsInput | number | null
    DeliveryLocationID?: NullableIntFieldUpdateOperationsInput | number | null
    TruckID?: NullableIntFieldUpdateOperationsInput | number | null
    DriverID?: NullableIntFieldUpdateOperationsInput | number | null
    Deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Week?: StringFieldUpdateOperationsInput | string
    DriverRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobsCreateManyWeekliesInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
    PayStubID?: number | null
  }

  export type JobsUpdateWithoutWeekliesInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    PayStubs?: PayStubsUpdateOneWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutWeekliesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    PayStubID?: NullableIntFieldUpdateOperationsInput | number | null
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type JobsCreateManyPayStubsInput = {
    ID?: number
    DriverID: number
    LoadTypeID: number
    CustomerID: number
    PaidOut?: boolean
    TruckingRevenue?: number | null
    CompanyRevenue?: number | null
    TruckingRate: number
    CompanyRate: number
    DeliveryLocationID: number
    WeeklyID: number
    DailyID: number
    MaterialRate: number
    DriverRate: number
  }

  export type JobsUpdateWithoutPayStubsInput = {
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Customers?: CustomersUpdateOneRequiredWithoutJobsNestedInput
    Dailies?: DailiesUpdateOneRequiredWithoutJobsNestedInput
    DeliveryLocations?: DeliveryLocationsUpdateOneRequiredWithoutJobsNestedInput
    Drivers?: DriversUpdateOneRequiredWithoutJobsNestedInput
    LoadTypes?: LoadTypesUpdateOneRequiredWithoutJobsNestedInput
    Weeklies?: WeekliesUpdateOneRequiredWithoutJobsNestedInput
    Loads?: LoadsUpdateManyWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutPayStubsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    DriverID?: IntFieldUpdateOperationsInput | number
    LoadTypeID?: IntFieldUpdateOperationsInput | number
    CustomerID?: IntFieldUpdateOperationsInput | number
    PaidOut?: BoolFieldUpdateOperationsInput | boolean
    TruckingRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    CompanyRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    TruckingRate?: FloatFieldUpdateOperationsInput | number
    CompanyRate?: FloatFieldUpdateOperationsInput | number
    DeliveryLocationID?: IntFieldUpdateOperationsInput | number
    WeeklyID?: IntFieldUpdateOperationsInput | number
    DailyID?: IntFieldUpdateOperationsInput | number
    MaterialRate?: FloatFieldUpdateOperationsInput | number
    DriverRate?: FloatFieldUpdateOperationsInput | number
    Loads?: LoadsUncheckedUpdateManyWithoutJobsNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}